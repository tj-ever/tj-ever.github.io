<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ever的个人博客</title>
  
  
  <link href="https://tj-ever.github.io/atom.xml" rel="self"/>
  
  <link href="https://tj-ever.github.io/"/>
  <updated>2021-11-26T08:09:15.453Z</updated>
  <id>https://tj-ever.github.io/</id>
  
  <author>
    <name>Ever</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka 生产环境问题及性能优化</title>
    <link href="https://tj-ever.github.io/2021/11/26/Kafka%20%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://tj-ever.github.io/2021/11/26/Kafka%20%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-11-25T16:00:00.000Z</published>
    <updated>2021-11-26T08:09:15.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线上环境规划"><a href="#线上环境规划" class="headerlink" title="线上环境规划"></a>线上环境规划</h1><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211126152330.png" alt="image-20211126152330702" style="zoom:50%;" /><h1 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h1><p>kafka是scala语言开发，运行在JVM上，需要对JVM参数合理设置，参看JVM调优专题 修改bin/kafka-start-server.sh中的jvm设置，假设机器是32G内存，可以如下设置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KAFKA_HEAP_OPTS = <span class="string">&quot; ‐Xmx16G ‐Xms16G ‐Xmn10G ‐XX:MetaspaceSize=256M ‐XX:+UseG1GC ‐XX:MaxGCPauseMillis=50 ‐XX:G1HeapRegionSize=16M&quot;</span></span><br></pre></td></tr></table></figure><p>这种大内存的情况一般都要用G1垃圾收集器，因为年轻代内存比较大，用G1可以设置GC最大停顿时间，不至于一次minor gc就花费太长 时间，当然，因为像kafka，rocketmq，es这些中间件，写数据到磁盘会用到操作系统的page cache，所以JVM内存不宜分配过大，需 要给操作系统的缓存留出几个G。</p><h1 id="线上问题及优化"><a href="#线上问题及优化" class="headerlink" title="线上问题及优化"></a>线上问题及优化</h1><h2 id="消息丢失情况"><a href="#消息丢失情况" class="headerlink" title="消息丢失情况"></a>消息丢失情况</h2><p><strong>消息发送端</strong></p><ol><li>acks=0: 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。大数据统计报表场景，对性能要求很高，对数据丢失不敏感的情况可以用这种。</li><li>acks=1: 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消 息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</li><li>acks=-1或all: 这意味着leader需要等待所有备份(min.insync.replicas配置的备份个数)都成功写入日志，这种策略会保证只要有一 个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。当然如果 min.insync.replicas配置的是1则也可能丢消息，跟acks=1情况类似。</li></ol><p><strong>消息消费端</strong></p><p>如果消费这边配置的是自动提交，万一消费到数据还没处理完，就自动提交offset了，但是此时你consumer直接宕机了，未处理完的数据 丢失了，下次也消费不到了。</p><h2 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h2><p><strong>消息发送端</strong></p><p>发送消息如果配置了重试机制，比如网络抖动时间过长导致发送端发送超时，实际broker可能已经接收到消息，但发送方会重新发送消息 </p><p><strong>消息消费端</strong></p><p>如果消费这边配置的是自动提交，刚拉取了一批数据处理了一部分，但还没来得及提交，服务挂了，下次重启又会拉取相同的一批数据重 复处理一般消费端都是要做消费幂等处理的。</p><h2 id="消息乱序"><a href="#消息乱序" class="headerlink" title="消息乱序"></a>消息乱序</h2><p>如果发送端配置了重试机制，kafka不会等之前那条消息完全发送成功才去发送下一条消息，这样可能会出现，发送了1，2，3条消息，第 一条超时了，后面两条发送成功，再重试发送第1条消息，这时消息在broker端的顺序就是2，3，1了。所以，是否一定要配置重试要根据业务情况而定。也可以用同步发送的模式去发消息，当然acks不能设置为0，这样也能保证消息从发送端到消费端全链路有序。 kafka保证全链路消息顺序消费，需要从发送端开始，将所有有序消息发送到同一个分区，然后用一个消费者去消费，但是这种性能比较低，可以在消费者端接收到消息后将需要保证顺序消费的几条消费发到内存队列(可以搞多个)，一个内存队列开启一个线程顺序处理消息。</p><h2 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h2><p>线上有时因为发送方发送消息速度过快，或者消费方处理消息过慢，可能会导致broker积压大量未消费消息。 </p><p>此种情况如果积压了上百万未消费消息需要紧急处理，可以修改消费端程序，让其将收到的消息快速转发到其他topic(可以设置很多分区)，然后再启动多个消费者同时消费新主题的不同分区。</p><p>由于消息数据格式变动或消费者程序有bug，导致消费者一直消费不成功，也可能导致broker积压大量未消费消息。</p><p>此种情况可以将这些消费不成功的消息转发到其它队列里去(类似死信队列)，后面再慢慢分析死信队列里的消息处理问题。</p><h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><p>延时队列存储的对象是延时消息。所谓的“延时消息”是指消息被发送以后，并不想让消费者立刻获取，而是等待特定的时间后，消费者才能获取这个消息进行消费，延时队列的使用场景有很多， 比如 :</p><ol><li>在订单系统中， 一个用户下单之后通常有 30 分钟的时间进行支付，如果 30 分钟之内没有支付成功，那么这个订单将进行异常处理， 这时就可以使用延时队列来处理这些订单了。</li><li>订单完成1小时后通知用户进行评价。</li></ol><p>实现思路:发送延时消息时先把消息按照不同的延迟时间段发送到指定的队列中(topic_1s，topic_5s，topic_10s，…topic_2h，这个一 般不能支持任意时间段的延时)，然后通过定时器进行轮训消费这些topic，查看消息是否到期，如果到期就把这个消息发送到具体业务处 理的topic中，队列中消息越靠前的到期时间越早，具体来说就是定时器在一次消费过程中，对消息的发送时间做判断，看下是否延迟到对 应时间了，如果到了就转发，如果还没到这一次定时任务就可以提前结束了。</p><h2 id="消息回溯"><a href="#消息回溯" class="headerlink" title="消息回溯"></a>消息回溯</h2><p>如果某段时间对已消费消息计算的结果觉得有问题，可能是由于程序bug导致的计算错误，当程序bug修复后，这时可能需要对之前已消 费的消息重新消费，可以指定从多久之前的消息回溯消费，这种可以用consumer的offsetsForTimes、seek等方法指定从某个offset偏移 的消息开始消费。</p><h2 id="分区数越多吞吐量越高吗"><a href="#分区数越多吞吐量越高吗" class="headerlink" title="分区数越多吞吐量越高吗"></a>分区数越多吞吐量越高吗</h2><p>可以用kafka压测工具自己测试分区数不同，各种情况下的吞吐量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 往test里发送一百万消息，每条设置1KB</span><br><span class="line"># throughput 用来进行限流控制，当设定的值小于 0 时不限流，当设定的值大于 0 时，当发送的吞吐量大于该值时就会被阻塞一段时间</span><br><span class="line">bin&#x2F;kafka‐producer‐perf‐test.sh ‐‐topic test ‐‐num‐records 1000000 ‐‐record‐size 1024 ‐‐throughput ‐1 ‐‐producer‐props bootstrap.servers &#x3D; 192.168.65.60:9092 acks&#x3D;1</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211126160311.png" alt="image-20211126160311115"></p><p>网络上很多资料都说分区数越多吞吐量越高 ， 但从压测结果来看，分区数到达某个值吞吐量反而开始下降，实际上很多事情都会有一个 临界值，当超过这个临界值之后，很多原本符合既定逻辑的走向又会变得不同。一般情况分区数跟集群机器数量相当就差不多了。 </p><p>当然吞吐量的数值和走势还会和磁盘、文件系统、 I/O调度策略等因素相关。 </p><p>注意:如果分区数设置过大，比如设置10000，可能会设置不成功，后台会报错”java.io.IOException : Too many open files”。 异常中最关键的信息是“ Too many open flies”，这是一种常见的 Linux 系统错误，通常意味着文件描述符不足，它一般发生在创建线程、创建 Socket、打开文件这些场景下 。 </p><p>在 Linux系统的默认设置下，这个文件描述符的个数不是很多 ，通过 ulimit -n 命令可以查 看:一般默认是1024，可以将该值增大，比如:ulimit -n 65535</p><h2 id="消息传递保障"><a href="#消息传递保障" class="headerlink" title="消息传递保障"></a>消息传递保障</h2><p>at most once(消费者最多收到一次消息，0-1次):acks = 0 可以实现。<br>at least once(消费者至少收到一次消息，1-多次):ack = all 可以实现。<br>exactly once(消费者刚好收到一次消息):at least once 加上消费者幂等性可以实现，还可以用kafka生产者的幂等性来实现。</p><p><strong>kafka生产者的幂等性</strong></p><p>因为发送端重试导致的消息重复发送问题，kafka的幂等性可以保证重复发送的消息只接收一次，只需在生产者加 上参数 props.put(“enable.idempotence”, true) 即可，默认是false不开启。 具体实现原理是，kafka每次发送消息会生成PID和Sequence Number，并将这两个属性一起发送给broker，broker会将PID和 Sequence Number跟消息绑定一起存起来，下次如果生产者重发相同消息，broker会检查PID和Sequence Number，如果相同不会再接收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PID:每个新的 Producer 在初始化的时候会被分配一个唯一的 PID，这个PID 对用户完全是透明的。生产者如果重启则会生成新的PID</span><br><span class="line">Sequence Number:对于每个 PID，该 Producer 发送到每个 Partition 的数据都有对应的序列号，这些序列号是从0开始单调递增的。</span><br></pre></td></tr></table></figure><h2 id="kafka的事务"><a href="#kafka的事务" class="headerlink" title="kafka的事务"></a>kafka的事务</h2><p>Kafka的事务不同于Rocketmq，Rocketmq是保障本地事务(比如数据库)与mq消息发送的事务一致性，Kafka的事务主要是保障一次发送 多条消息的事务一致性(要么同时成功要么同时失败)，一般在kafka的流式计算场景用得多一点，比如，kafka需要对一个topic里的消息做 不同的流式计算处理，处理完分别发到不同的topic里，这些topic分别被不同的下游系统消费(比如hbase，redis，es等)，这种我们肯定 希望系统发送到多个topic的数据保持事务一致性。Kafka要实现类似Rocketmq的分布式事务需要额外开发功能。 kafka的事务处理可以参考官方文档。</p><h2 id="kafka高性能的原因"><a href="#kafka高性能的原因" class="headerlink" title="kafka高性能的原因"></a>kafka高性能的原因</h2><ul><li>磁盘顺序读写:kafka消息不能修改以及不会从文件中间删除保证了磁盘顺序读，kafka的消息写入文件都是追加在文件末尾，不会写入文件中的某个位置(随机写)保证了磁盘顺序写。 </li><li>数据传输的零拷贝</li><li>读写数据的批量batch处理以及压缩传输</li></ul><p>数据传输零拷贝原理:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211126160902.png" alt="image-20211126160902015" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线上环境规划&quot;&gt;&lt;a href=&quot;#线上环境规划&quot; class=&quot;headerlink&quot; title=&quot;线上环境规划&quot;&gt;&lt;/a&gt;线上环境规划&lt;/h1&gt;&lt;img src=&quot;https://hexo-img-1301602913.cos.ap-shanghai.myq</summary>
      
    
    
    
    
    <category term="Kafka" scheme="https://tj-ever.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 设计原理</title>
    <link href="https://tj-ever.github.io/2021/11/25/Kafka%20%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    <id>https://tj-ever.github.io/2021/11/25/Kafka%20%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-24T16:00:00.000Z</published>
    <updated>2021-11-25T07:56:28.743Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211125133431.png" alt="image-20211125133431531"></p><h1 id="核心总控制器Controller"><a href="#核心总控制器Controller" class="headerlink" title="核心总控制器Controller"></a>核心总控制器Controller</h1><p>在Kafka集群中会有一个或者多个broker，其中有一个broker会被选举为控制器(Kafka Controller)，它负责管理整个 集群中所有分区和副本的状态。</p><ul><li>当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。 </li><li>当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。 </li><li>当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是由控制器负责让新分区被其他节点感知到。</li></ul><h2 id="Controller选举机制"><a href="#Controller选举机制" class="headerlink" title="Controller选举机制"></a>Controller选举机制</h2><p>在kafka集群启动的时候，会自动选举一台broker作为controller来管理整个集群，选举的过程是集群中每个broker都会尝试在zookeeper上创建一个 /controller 临时节点，zookeeper会保证有且仅有一个broker能创建成功，这个broker 就会成为集群的总控器controller。</p><p>当这个controller角色的broker宕机了，此时zookeeper临时节点会消失，集群里其他broker会一直监听这个临时节 点，发现临时节点消失了，就竞争再次创建临时节点，就是我们上面说的选举机制，zookeeper又会保证有一个broker 成为新的controller。</p><p>具备控制器身份的broker需要比其他普通的broker多一份职责，具体细节如下:</p><ol><li><p>监听broker相关的变化。</p><p>为Zookeeper中的/brokers/ids/节点添加BrokerChangeListener，用来处理broker 增减的变化。</p></li><li><p>监听topic相关的变化。</p><p>为Zookeeper中的/brokers/topics节点添加TopicChangeListener，用来处理topic增减的变化。</p><p>为Zookeeper中的/admin/delete_topics节点添加TopicDeletionListener，用来处理删除topic的动作。</p></li><li><p>从Zookeeper中读取获取当前所有与topic、partition以及broker有关的信息并进行相应的管理。</p><p>对于所有topic 所对应的Zookeeper中的/brokers/topics/[topic]节点添加PartitionModificationsListener，用来监听topic中的分区分配变化。</p></li><li><p> 更新集群的元数据信息，同步到其他普通的broker节点中。</p></li></ol><h2 id="Partition副本选举Leader机制"><a href="#Partition副本选举Leader机制" class="headerlink" title="Partition副本选举Leader机制"></a>Partition副本选举Leader机制</h2><p>controller感知到分区leader所在的broker挂了(controller监听了很多zk节点可以感知到broker存活)，controller会从 ISR列表(参数unclean.leader.election.enable=false的前提下)里挑第一个broker作为leader(第一个broker最先放进ISR 列表，可能是同步数据最多的副本)，如果参数unclean.leader.election.enable为true，代表在ISR列表里所有副本都挂了的时候可以在ISR列表以外的副本中选leader，这种设置，可以提高可用性，但是选出的新leader有可能数据少很多。 </p><p>副本进入ISR列表有两个条件: </p><ol><li>副本节点不能产生分区，必须能与zookeeper保持会话以及跟leader副本网络连通</li><li>副本能复制leader上的所有写操作，并且不能落后太多。(与leader副本同步滞后的副本，是由 replica.lag.time.max.ms 配置决定的，超过这个时间都没有跟leader同步过的一次的副本会被移出ISR列表)</li></ol><h2 id="消费者消费消息的offset记录机制"><a href="#消费者消费消息的offset记录机制" class="headerlink" title="消费者消费消息的offset记录机制"></a>消费者消费消息的offset记录机制</h2><p>每个consumer会定期将自己消费分区的offset提交给kafka内部topic:__consumer_offsets，提交过去的时候，key是 consumerGroupId+topic+分区号，value就是当前offset的值，kafka会定期清理topic里的消息，最后就保留最新的那条数据</p><p>因为__consumer_offsets可能会接收高并发的请求，kafka默认给其分配50个分区(可以通过 offsets.topic.num.partitions设置)，这样可以通过加机器的方式抗大并发。</p><h2 id="消费者Rebalance机制"><a href="#消费者Rebalance机制" class="headerlink" title="消费者Rebalance机制"></a>消费者Rebalance机制</h2><p>rebalance就是说如果消费组里的消费者数量有变化或消费的分区数有变化，kafka会重新分配消费者消费分区的关系。 比如consumer group中某个消费者挂了，此时会自动把分配给他的分区交给其他的消费者，如果他又重启了，那么又会 把一些分区重新交还给他。 注意:rebalance只针对subscribe这种不指定分区消费的情况，如果通过assign这种消费方式指定了分区，kafka不会进行rebanlance。</p><p>如下情况可能会触发消费者rebalance</p><ol><li>消费组里的consumer增加或减少了</li><li>动态给topic增加了分区</li><li>消费组订阅了更多的topic</li></ol><p>rebalance过程中，消费者无法从kafka消费消息，这对kafka的TPS会有影响，如果kafka集群内节点较多，比如数百个，那重平衡可能会耗时极多，所以应尽量避免在系统高峰期的重平衡发生。</p><h3 id="Rebalance过程"><a href="#Rebalance过程" class="headerlink" title="Rebalance过程"></a>Rebalance过程</h3><p>当有消费者加入消费组时，消费者、消费组及组协调器之间会经历以下几个阶段。</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211125140509.png" alt="image-20211125140509655"></p><h4 id="第一阶段-选择组协调器"><a href="#第一阶段-选择组协调器" class="headerlink" title="第一阶段:选择组协调器"></a>第一阶段:选择组协调器</h4><p><strong>组协调器GroupCoordinator</strong></p><p>每个consumer group都会选择一个broker作为自己的组协调器coordinator，负责监控这个消费组里的所有消费者的心跳，以及判断是否宕机，然后开启消费者rebalance。</p><p>consumer group中的每个consumer启动时会向kafka集群中的某个节点发送 FindCoordinatorRequest 请求来查找对应的组协调器GroupCoordinator，并跟其建立网络连接。</p><p><strong>组协调器选择方式</strong></p><p>通过如下公式可以选出consumer消费的offset要提交到__consumer_offsets的哪个分区，这个分区leader对应的broker 就是这个consumer group的coordinator<br> 公式:hash(consumer group id) % __consumer_offsets主题的分区数</p><h4 id="第二阶段-加入消费组JOIN-GROUP"><a href="#第二阶段-加入消费组JOIN-GROUP" class="headerlink" title="第二阶段:加入消费组JOIN GROUP"></a>第二阶段:加入消费组JOIN GROUP</h4><p>在成功找到消费组所对应的 GroupCoordinator 之后就进入加入消费组的阶段，在此阶段的消费者会向 GroupCoordinator 发送 JoinGroupRequest 请求，并处理响应。然后GroupCoordinator 从一个consumer group中 选择第一个加入group的consumer作为leader(消费组协调器)，把consumer group情况发送给这个leader，接着这个leader会负责制定分区方案。</p><h4 id="第三阶段-SYNC-GROUP"><a href="#第三阶段-SYNC-GROUP" class="headerlink" title="第三阶段( SYNC GROUP)"></a>第三阶段( SYNC GROUP)</h4><p>consumer leader通过给GroupCoordinator发送SyncGroupRequest，接着GroupCoordinator就把分区方案下发给各 个consumer，他们会根据指定分区的leader broker进行网络连接以及消息消费。</p><h2 id="消费者Rebalance分区分配策略"><a href="#消费者Rebalance分区分配策略" class="headerlink" title="消费者Rebalance分区分配策略"></a>消费者Rebalance分区分配策略</h2><p>主要有三种rebalance的策略:range、round-robin、sticky。<br>Kafka 提供了消费者客户端参数partition.assignment.strategy 来设置消费者与订阅主题之间的分区分配策略。默认情况为range分配策略。</p><p><strong>range策略</strong></p><p>假设一个主题有10个分区(0-9)，现在有三个consumer消费:<br>range策略就是按照分区序号排序，假设 n=分区数/消费者数量 = 3， m=分区数%消费者数量 = 1，那么前 m 个消 费者每个分配 n+1 个分区，后面的(消费者数量-m )个消费者每个分配 n 个分区。 比如分区0<del>3给一个consumer，分区4</del>6给一个consumer，分区7~9给一个consumer。</p><p><strong>round-robin策略</strong></p><p>轮询分配，比如分区0、3、6、9给一个consumer，分区1、4、7给一个consumer，分区2、5、 8给一个consumer</p><p><strong>sticky策略</strong></p><p>初始时分配策略与round-robin类似，但是在rebalance的时候，需要保证如下两个原则：</p><ol><li>分区的分配要尽可能均匀 。</li><li>分区的分配尽可能与上次分配的保持相同。</li></ol><p>当两者发生冲突时，第一个目标优先于第二个目标 。这样可以最大程度维持原来的分区分配的策略。 比如对于第一种range情况的分配，如果第三个consumer挂了，那么重新用sticky策略分配的结果如下: consumer1除了原有的0<del>3，会再分配一个7 consumer2除了原有的4</del>6，会再分配8和9</p><h1 id="producer发布消息机制剖析"><a href="#producer发布消息机制剖析" class="headerlink" title="producer发布消息机制剖析"></a>producer发布消息机制剖析</h1><p><strong>写入方式</strong><br>producer 采用 push 模式将消息发布到 broker，每条消息都被 append 到 patition 中，属于顺序写磁盘(顺序写磁盘 效率比随机写内存要高，保障 kafka 吞吐率)。</p><p><strong>消息路由</strong></p><p>producer 发送消息到 broker 时，会根据分区算法选择将其存储到哪一个 partition。其路由机制为:</p><ol><li>指定了 patition，则直接使用;</li><li>未指定 patition 但指定 key，通过对 key 的 value 进行hash 选出一个 patition</li><li>patition 和 key 都未指定，使用轮询选出一个 patition。</li></ol><p><strong>写入流程</strong></p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211125145056.png" alt="image-20211125145056305" style="zoom:50%;" /><ol><li>producer 先从 zookeeper 的 “/brokers/…/state” 节点找到该 partition 的 leader</li><li>producer 将消息发送给该 leader</li><li>leader 将消息写入本地 log</li><li>followers 从 leader pull 消息，写入本地 log 后 向leader 发送 ACK</li><li>leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW(high watermark，最后 commit 的 offset) 并向 producer 发送 ACK</li></ol><h1 id="HW与LEO详解"><a href="#HW与LEO详解" class="headerlink" title="HW与LEO详解"></a>HW与LEO详解</h1><p>HW俗称高水位，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO(log-end-offset)作为HW， consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状 态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW， 此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。对于来自内部broker的读取请求，没有HW的限制。</p><p>下图详细的说明了当producer生产消息至broker后，ISR以及HW和LEO的流转过程:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211125150937.png" alt="image-20211125150937816"></p><p>由此可见，Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的follower都复制完，这条消息才会被commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，follower异步的从leader复制数据，数据只要被leader写入log就被认为已经commit，这种情况下如果follower都还没有复制完，落后于leader时，突然leader宕机，则会丢失数据。而Kafka的这种使用ISR的方式则很好的均衡了确保数据不丢失以及吞吐率。再回顾下消息发送端对发出消息持久化机制参数acks的设置，我们结合HW 和LEO来看下acks=1的情况</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211125151842.png" alt="image-20211125151842618" style="zoom:50%;" /><h1 id="日志分段存储"><a href="#日志分段存储" class="headerlink" title="日志分段存储"></a>日志分段存储</h1><p>Kafka 一个分区的消息数据对应存储在一个文件夹下，以topic名称+分区号命名，消息在分区内是分段(segment)存储， 每个段的消息都存储在不一样的log文件里，这种特性方便old segment file快速被删除，kafka规定了一个段位的 log 文 件最大为 1G，做这个限制目的是为了方便把 log 文件加载到内存去操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 部分消息的offset索引文件，kafka每次往分区发4K(可配置)消息就会记录一条当前消息的offset到index文件</span><br><span class="line"># 如果要定位消息的offset会先在这个文件里快速定位，再去log文件里找具体消息 </span><br><span class="line">00000000000000000000.index</span><br><span class="line"></span><br><span class="line"># 消息存储文件，主要存offset和消息体</span><br><span class="line">00000000000000000000.log</span><br><span class="line"></span><br><span class="line"># 消息的发送时间索引文件，kafka每次往分区发4K(可配置)消息就会记录一条当前消息的发送时间戳与对应的offset到timeindex文件， </span><br><span class="line"># 如果需要按照时间来定位消息的offset，会先在这个文件里查找</span><br><span class="line">00000000000000000000.timeindex</span><br><span class="line">00000000000005367851.index </span><br><span class="line">00000000000005367851.log </span><br><span class="line">00000000000005367851.timeindex</span><br><span class="line">00000000000009936472.index </span><br><span class="line">00000000000009936472.log </span><br><span class="line">00000000000009936472.timeindex</span><br></pre></td></tr></table></figure><p>这个 9936472 之类的数字，就是代表了这个日志段文件里包含的起始 Offset，也就说明这个分区里至少都写入了接近 1000 万条数据了。<br> Kafka Broker 有一个参数，log.segment.bytes，限定了每个日志段文件的大小，最大就是 1GB。 一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做 log rolling，正在被写入的那个日志段文件，叫做 active log segment。</p><h1 id="zookeeper节点数据图"><a href="#zookeeper节点数据图" class="headerlink" title="zookeeper节点数据图"></a>zookeeper节点数据图</h1><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211125155401.png" alt="image-20211125155401550"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211125133431.png&quot; alt=&quot;image-20211125133431531&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;核心总控制器C</summary>
      
    
    
    
    
    <category term="Kafka" scheme="https://tj-ever.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 基本原理</title>
    <link href="https://tj-ever.github.io/2021/11/22/Kafka%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>https://tj-ever.github.io/2021/11/22/Kafka%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-21T16:00:00.000Z</published>
    <updated>2021-11-25T05:34:14.631Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的(partition)、多副本的(replica)，基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景:比如基于hadoop的批处理系统、低延迟的实时系统、Storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写， Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li>日志收集：一个公司可以用Kafka收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li><li>消息系统：解耦和生产者和消费者、缓存消息等。 </li><li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到 hadoop、数据仓库中做离线分析和挖掘。</li><li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211122140710.png" alt="image-20211122140710552" style="zoom:50%;" /><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>kafka是一个分布式的，分区的消息(官方称之为commit log)服务。它提供一个消息系统应该具备的功能，但是确有着独特的设计。可以这样来说，Kafka借鉴了JMS规范的思想，但是确并没有完全遵循JMS规范。</p><p>相关术语:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211122140856.png" alt="image-20211122140856928"></p><p>从一个较高的层面上来看，producer通过网络发送消息到Kafka集群，然后consumer来进行消费，如下图:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211122141159.png" alt="image-20211122141159847"></p><p>服务端(brokers)和客户端(producer、consumer)之间通信通过TCP协议来完成。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>安装前的环境准备</p><p>由于Kafka是用Scala语言开发的，运行在JVM上，因此在安装Kafka之前需要先安装JDK。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java‐1.8.0‐openjdk* ‐y</span><br></pre></td></tr></table></figure><p>kafka依赖zookeeper，所以需要先安装zookeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper‐3.5.8/apache‐zookeeper‐3.5.8‐bin.tar.gz</span><br><span class="line">tar ‐zxvf apache‐zookeeper‐3.5.8‐bin.tar.gz</span><br><span class="line">cd apache‐zookeeper‐3.5.8‐bin</span><br><span class="line">cp conf/zoo_sample.cfg conf/zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动zookeeper</span></span><br><span class="line">bin/zkServer.sh start</span><br><span class="line">bin/zkCli.sh</span><br><span class="line">ls /#查看zk的根目录相关节点</span><br></pre></td></tr></table></figure><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>下载2.4.1 release版本，并解压:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">2.11是scala的版本，2.4.1是kafka的版本</span></span><br><span class="line">wget https://mirror.bit.edu.cn/apache/kafka/2.4.1/kafka_2.11‐2.4.1.tgz</span><br><span class="line">tar ‐xzf kafka_2.11‐2.4.1.tgz</span><br><span class="line">cd kafka_2.11‐2.4.1</span><br></pre></td></tr></table></figure><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>修改配置文件config/server.properties:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">broker.id属性在kafka集群中必须要是唯一</span></span><br><span class="line">broker.id=0</span><br><span class="line"><span class="meta">#</span><span class="bash">kafka部署的机器ip和提供服务的端口号</span></span><br><span class="line">listeners=PLAINTEXT://192.168.65.60:9092 </span><br><span class="line"><span class="meta">#</span><span class="bash">kafka的消息存储文件</span></span><br><span class="line">log.dir=/usr/local/data/kafka‐logs</span><br><span class="line"><span class="meta">#</span><span class="bash">kafka连接zookeeper的地址</span></span><br><span class="line">zookeeper.connect=192.168.65.60:2181</span><br></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>现在来启动kafka服务:<br>启动脚本语法: <code>kafka­-server-­start.sh [-­daemon] server.properties</code> 可以看到，server.properties的配置路径是一个强制的参数，<code>­-daemon</code>表示以后台进程运行，否则ssh客户端退出后， 就会停止服务。</p><p>(注意，在启动kafka时会使用linux主机名关联的ip地址，所以需要把主机名和linux的ip映射配置到本地 host里，用vim /etc/hosts)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动kafka，运行日志在logs目录的server.log文件里</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">后台启动，不会打印日志到控制台</span></span><br><span class="line">bin/kafka‐server‐start.sh ‐daemon config/server.properties</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">或者用</span></span><br><span class="line">bin/kafka‐server‐start.sh config/server.properties&amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入zookeeper目录通过zookeeper客户端查看下zookeeper的目录树</span></span><br><span class="line">bin/zkCli.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">查看zk的根目录kafka相关节点</span></span><br><span class="line">ls /</span><br><span class="line"><span class="meta">#</span><span class="bash">查看kafka节点</span></span><br><span class="line">ls /brokers/ids</span><br><span class="line"><span class="meta">#</span><span class="bash">停止kafka</span></span><br><span class="line">bin/kafka‐server‐stop.sh</span><br></pre></td></tr></table></figure><p>server.properties核心配置详解</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://broker.id/">broker.id</a> =0</td><td>每一个broker在集群中的唯一表示，要求是正数。当该服务器的IP地址发生改变时，broker.id没有变化，则不会影响consumers的消息情况</td></tr><tr><td>log.dirs=/data/kafka-logs</td><td>kafka数据的存放地址，多个地址的话用逗号分割,多个目录分布在不同磁盘上可以提高读写性能 /data/kafka-logs-1，/data/kafka-logs-2</td></tr><tr><td>port =9092</td><td>broker server服务端口</td></tr><tr><td>message.max.bytes =6525000</td><td>表示消息体的最大大小，单位是字节</td></tr><tr><td>num.network.threads =4</td><td>broker处理消息的最大线程数，一般情况下数量为cpu核数</td></tr><tr><td>num.io.threads =8</td><td>broker处理磁盘IO的线程数，数值为cpu核数2倍</td></tr><tr><td>background.threads =4</td><td>一些后台任务处理的线程数，例如过期消息文件的删除等，一般情况下不需要去做修改</td></tr><tr><td>queued.max.requests =500</td><td>等待IO线程处理的请求队列最大数，若是等待IO的请求超过这个数值，那么会停止接受外部消息，应该是一种自我保护机制。</td></tr><tr><td><a href="http://host.name/">host.name</a></td><td>broker的主机地址，若是设置了，那么会绑定到这个地址上，若是没有，会绑定到所有的接口上，并将其中之一发送到ZK，一般不设置</td></tr><tr><td>socket.send.buffer.bytes=100*1024</td><td>socket的发送缓冲区，socket的调优参数SO_SNDBUFF</td></tr><tr><td>socket.receive.buffer.bytes =100*1024</td><td>socket的接受缓冲区，socket的调优参数SO_RCVBUFF</td></tr><tr><td>socket.request.max.bytes =100<em>1024</em>1024</td><td>socket请求的最大数值，防止serverOOM，message.max.bytes必然要小于socket.request.max.bytes，会被topic创建时的指定参数覆盖</td></tr><tr><td>log.segment.bytes =1024<em>1024</em>1024</td><td>topic的分区是以一堆segment文件存储的，这个控制每个segment的大小，会被topic创建时的指定参数覆盖</td></tr><tr><td>log.roll.hours =24*7</td><td>这个参数会在日志segment没有达到log.segment.bytes设置的大小，也会强制新建一个segment会被 topic创建时的指定参数覆盖</td></tr><tr><td>log.cleanup.policy = delete</td><td>日志清理策略选择有：delete和compact主要针对过期数据的处理，或是日志文件达到限制的额度，会被 topic创建时的指定参数覆盖</td></tr><tr><td>log.retention.minutes=300 或 log.retention.hours=24</td><td>数据文件保留多长时间， 存储的最大时间超过这个时间会根据log.cleanup.policy设置数据清除策略log.retention.bytes和log.retention.minutes或log.retention.hours任意一个达到要求，都会执行删除有2删除数据文件方式：按照文件大小删除：log.retention.bytes，按照2中不同时间粒度删除：分别为分钟，小时</td></tr><tr><td>log.retention.bytes=-1</td><td>topic每个分区的最大文件大小，一个topic的大小限制 = 分区数*log.retention.bytes。-1没有大小限log.retention.bytes和log.retention.minutes任意一个达到要求，都会执行删除，会被topic创建时的指定参数覆盖</td></tr><tr><td>log.retention.check.interval.ms=5minutes</td><td>文件大小检查的周期时间，是否处罚 log.cleanup.policy中设置的策略</td></tr><tr><td>log.cleaner.enable=false</td><td>是否开启日志清理</td></tr><tr><td>log.cleaner.threads = 2</td><td>日志清理运行的线程数</td></tr><tr><td>log.cleaner.io.max.bytes.per.second=None</td><td>日志清理时候处理的最大大小</td></tr><tr><td>log.cleaner.dedupe.buffer.size=500<em>1024</em>1024</td><td>日志清理去重时候的缓存空间，在空间允许的情况下，越大越好</td></tr><tr><td>log.cleaner.io.buffer.size=512*1024</td><td>日志清理时候用到的IO块大小一般不需要修改</td></tr><tr><td>log.cleaner.io.buffer.load.factor =0.9</td><td>日志清理中hash表的扩大因子一般不需要修改</td></tr><tr><td><a href="http://log.cleaner.backoff.ms/">log.cleaner.backoff.ms</a> =15000</td><td>检查是否处罚日志清理的间隔</td></tr><tr><td>log.cleaner.min.cleanable.ratio=0.5</td><td>日志清理的频率控制，越大意味着更高效的清理，同时会存在一些空间上的浪费，会被topic创建时的指定参数覆盖</td></tr><tr><td><a href="http://log.cleaner.delete.retention.ms/">log.cleaner.delete.retention.ms</a> =1day</td><td>对于压缩的日志保留的最长时间，也是客户端消费消息的最长时间，同log.retention.minutes的区别在于一个控制未压缩数据，一个控制压缩后的数据。会被topic创建时的指定参数覆盖</td></tr><tr><td>log.index.size.max.bytes =10<em>1024</em>1024</td><td>对于segment日志的索引文件大小限制，会被topic创建时的指定参数覆盖</td></tr><tr><td>log.index.interval.bytes=4096</td><td>当执行一个fetch操作后,需要一定的空间来扫描最近的offset大小，设置越大，代表扫描速度越快，但是也更好内存，一般情况下不需要搭理这个参数</td></tr><tr><td>log.flush.interval.messages=None</td><td>例如log.flush.interval.messages=1000表示每当消息记录数达到1000时flush一次数据到磁盘，log文件”sync”到磁盘之前累积的消息条数,因为磁盘IO操作是一个慢操作,但又是一个”数据可靠性”的必要手段,所以此参数的设置,需要在”数据可靠性”与”性能”之间做必要的权衡.如果此值过大,将会导致每次”fsync”的时间较长(IO阻塞),如果此值过小,将会导致”fsync”的次数较多,这也意味着整体的client请求有一定的延迟.物理server故障,将会导致没有fsync的消息丢失</td></tr><tr><td><a href="http://log.flush.scheduler.interval.ms/">log.flush.scheduler.interval.ms</a> =3000</td><td>检查是否需要固化到硬盘的时间间隔</td></tr><tr><td><a href="http://log.flush.interval.ms/">log.flush.interval.ms</a> = None</td><td>例如：log.flush.interval.ms=1000,表示每间隔1000毫秒flush一次数据到磁盘仅仅通过interval来控制消息的磁盘写入时机,是不足的.此参数用于控制”fsync”的时间间隔,如果消息量始终没有达到阀值,但是离上一次磁盘同步的时间间隔达到阀值,也将触发.</td></tr><tr><td><a href="http://log.delete.delay.ms/">log.delete.delay.ms</a> =60000</td><td>文件在索引中清除后保留的时间一般不需要去修改</td></tr><tr><td><a href="http://log.flush.offset.checkpoint.interval.ms/">log.flush.offset.checkpoint.interval.ms</a> =60000</td><td>控制上次固化硬盘的时间点，以便于数据恢复一般不需要去修改</td></tr><tr><td>auto.create.topics.enable =true</td><td>是否允许自动创建topic，若是false，就需要通过命令创建topic</td></tr><tr><td>default.replication.factor =1</td><td>是否允许自动创建topic，若是false，就需要通过命令创建topic</td></tr><tr><td>num.partitions =1</td><td>每个topic的分区个数，若是在topic创建时候没有指定的话会被topic创建时的指定参数覆盖</td></tr></tbody></table><h2 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h2><p>现在我们来创建一个名字为“test”的Topic，这个topic只有一个partition，并且备份因子也设置为1:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka‐topics.sh ‐‐create ‐‐zookeeper 192.168.65.60:2181 ‐‐replication‐factor 1 ‐‐partitions 1 ‐‐topic test</span><br></pre></td></tr></table></figure><p>现在我们可以通过以下命令来查看kafka中目前存在的topic</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐topics.sh ‐‐list ‐‐zookeeper 192.168.65.60:2181</span><br></pre></td></tr></table></figure><p>除了我们通过手工的方式创建Topic，当producer发布一个消息到某个指定的Topic，这个Topic如果不存在，就自动创建。</p><h3 id="删除主题"><a href="#删除主题" class="headerlink" title="删除主题"></a>删除主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐topics.sh ‐‐delete ‐‐topic test ‐‐zookeeper 192.168.65.60:2181</span><br></pre></td></tr></table></figure><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以以命令行中直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。 </p><p>首先我们要运行发布消息的脚本，然后在命令中输入要发送的消息的内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐console‐producer.sh ‐‐broker‐list 192.168.65.60:9092 ‐‐topic test</span><br><span class="line">&gt;this is a msg</span><br><span class="line">&gt;this is a another msg</span><br></pre></td></tr></table></figure><h2 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h2><p>对于consumer，kafka同样也携带了一个命令行客户端，会将获取到内容在命令中进行输出，默认是消费最新的消息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐console‐consumer.sh ‐‐bootstrap‐server 192.168.65.60:9092 ‐‐topic test </span><br></pre></td></tr></table></figure><p>如果想要消费之前的消息可以通过–from-beginning参数指定，如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐console‐consumer.sh ‐‐bootstrap‐server 192.168.65.60:9092 ‐‐from‐beginning ‐‐topic test</span><br></pre></td></tr></table></figure><p>如果你是通过不同的终端窗口来运行以上的命令，你将会看到在producer终端输入的内容，很快就会在consumer的终端窗口上显示出来。</p><p>以上所有的命令都有一些附加的选项;当我们不携带任何参数运行命令的时候，将会显示出这个命令的详细用法。</p><h3 id="消费多主题"><a href="#消费多主题" class="headerlink" title="消费多主题"></a>消费多主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐console‐consumer.sh ‐‐bootstrap‐server 192.168.65.60:9092 ‐‐whitelist &quot;test|test‐2&quot;</span><br></pre></td></tr></table></figure><h3 id="单播消费"><a href="#单播消费" class="headerlink" title="单播消费"></a>单播消费</h3><p>一条消息只能被某一个消费者消费的模式，类似queue模式，只需让所有消费者在同一个消费组里即可 分别在两个客户端执行如下消费命令，然后往主题里发送消息，结果只有一个客户端能收到消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐console‐consumer.sh ‐‐bootstrap‐server 192.168.65.60:9092 ‐‐consumer‐property group.id&#x3D;testGroup ‐‐topic test</span><br></pre></td></tr></table></figure><h3 id="多播消费"><a href="#多播消费" class="headerlink" title="多播消费"></a>多播消费</h3><p>一条消息能被多个消费者消费的模式，类似publish-subscribe模式费，针对Kafka同一条消息只能被同一个消费组下的某一个消费者消费的特性，要实现多播只要保证这些消费者属于不同的消费组即可。我们再增加一个消费者，该消费者属于testGroup-2消费 组，结果两个客户端都能收到消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐console‐consumer.sh ‐‐bootstrap‐server 192.168.65.60:9092 ‐‐consumer‐property group.id&#x3D;testGroup‐2 ‐‐topic test</span><br></pre></td></tr></table></figure><h3 id="查看消费组名"><a href="#查看消费组名" class="headerlink" title="查看消费组名"></a>查看消费组名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐consumer‐groups.sh ‐‐bootstrap‐server 192.168.65.60:9092 ‐‐list</span><br></pre></td></tr></table></figure><h3 id="查看消费组的消费偏移量"><a href="#查看消费组的消费偏移量" class="headerlink" title="查看消费组的消费偏移量"></a>查看消费组的消费偏移量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐consumer‐groups.sh ‐‐bootstrap‐server 192.168.65.60:9092 ‐‐describe ‐‐group testGroup</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211122145133.png" alt="image-20211122145133743"></p><p>current-offset:当前消费组的已消费偏移量 </p><p>log-end-offset:主题对应分区消息的结束偏移量(HW)</p><p>lag:当前消费组未消费的消息数</p><h1 id="主题Topic和消息日志Log"><a href="#主题Topic和消息日志Log" class="headerlink" title="主题Topic和消息日志Log"></a>主题Topic和消息日志Log</h1><p>可以理解Topic是一个类别的名称，同类消息发送到同一个Topic下面。对于每一个Topic，下面可以有多个分区(Partition)日志文件:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211122145608.png" alt="image-20211122145608190" style="zoom:50%;" /><p>Partition是一个有序的message序列，这些message按顺序添加到一个叫做commit log的文件中。每个partition中的消息都有一个唯一的编号，称之为offset，用来唯一标示某个分区中的message。</p><p>每个partition，都对应一个commit log文件。一个partition中的message的offset都是唯一的，但是不同的partition 中的message的offset可能是相同的。 kafka一般不会删除消息，不管这些消息有没有被消费。只会根据配置的日志保留时间(log.retention.hours)确认消息多久被删除，默认保留最近一周的日志消息。kafka的性能与保留的消息数据量大小没有关系，因此保存大量的数据消息日志信息不会有什么影响。</p><p>每个consumer是基于自己在commit log中的消费进度(offset)来进行工作的。在kafka中，消费offset由consumer自己来维护;一般情况下我们按照顺序逐条消费commit log中的消息，当然我可以通过指定offset来重复消费某些消息， 或者跳过某些消息。 这意味kafka中的consumer对集群的影响是非常小的，添加一个或者减少一个consumer，对于集群或者其他consumer 来说，都是没有影响的，因为每个consumer维护各自的消费offset。</p><h2 id="创建多个分区的主题"><a href="#创建多个分区的主题" class="headerlink" title="创建多个分区的主题"></a>创建多个分区的主题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐topics.sh ‐‐create ‐‐zookeeper 192.168.65.60:2181 ‐‐replication ‐factor 1 ‐‐partitions 2 ‐‐topic test1</span><br></pre></td></tr></table></figure><p>查看下topic的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐topics.sh ‐‐describe ‐‐zookeeper 192.168.65.60:2181 ‐‐topic test1</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211122173445.png" alt="image-20211122173445648"></p><p>以下是输出内容的解释，第一行是所有分区的概要信息，之后的每一行表示每一个partition的信息。</p><ul><li>leader节点负责给定partition的所有读写请求。</li><li>replicas 表示某个partition在哪几个broker上存在备份。不管这个几点是不是”leader“，甚至这个节点挂了，也会列出。 </li><li>isr 是replicas的一个子集，它只列出当前还存活着的，并且已同步备份了该partition的节点。</li></ul><p>我们可以运行相同的命令查看之前创建的名称为”test“的topic</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐topics.sh ‐‐describe ‐‐zookeeper 192.168.65.60:2181 ‐‐topic test</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211122181507.png" alt="image-20211122181507559"></p><p>之前设置了topic的partition数量为1，备份因子为1，因此显示就如上所示了。</p><p>可以进入kafka的数据文件存储目录查看test和test1主题的消息日志文件:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211122181817.png" alt="image-20211122181817678"></p><p>消息日志文件主要存放在分区文件夹里的以log结尾的日志文件里，如下是test1主题对应的分区0的消息日志:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211122181836.png" alt="image-20211122181836204"></p><p>当然我们也可以通过如下命令增加topic的分区数量(目前kafka不支持减少分区):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐topics.sh ‐alter ‐‐partitions 3 ‐‐zookeeper 192.168.65.60:2181 ‐‐topic test</span><br></pre></td></tr></table></figure><h2 id="理解Topic，Partition和Broker"><a href="#理解Topic，Partition和Broker" class="headerlink" title="理解Topic，Partition和Broker"></a>理解Topic，Partition和Broker</h2><p>一个topic，代表逻辑上的一个业务数据集，比如按数据库里不同表的数据操作消息区分放入不同topic，订单相关操作消息放入订单topic，用户相关操作消息放入用户topic，对于大型网站来说，后端数据都是海量的，订单消息很可能是非常巨量的，比如有几百个G甚至达到TB级别，如果把这么多数据都放在一台机器上可定会有容量限制问题，那么就可以在 topic内部划分多个partition来分片存储数据，不同的partition可以位于不同的机器上，每台机器上都运行一个Kafka的 进程Broker。</p><h2 id="为什么要对Topic下数据进行分区存储"><a href="#为什么要对Topic下数据进行分区存储" class="headerlink" title="为什么要对Topic下数据进行分区存储?"></a>为什么要对Topic下数据进行分区存储?</h2><p> 1、commit log文件会受到所在机器的文件系统大小的限制，分区之后可以将不同的分区放在不同的机器上，相当于对数据做了分布式存储，理论上一个topic可以处理任意数量的数据。<br> 2、为了提高并行度。</p><h1 id="kafka集群实战"><a href="#kafka集群实战" class="headerlink" title="kafka集群实战"></a>kafka集群实战</h1><p>对于kafka来说，一个单独的broker意味着kafka集群中只有一个节点。要想增加kafka集群中的节点数量，只需要多启动几个broker实例即可。</p><p>我们在一台机器上同时启动三个broker实例。 首先，建立好其他2个broker的配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp config&#x2F;server.properties config&#x2F;server‐1.properties </span><br><span class="line">cp config&#x2F;server.properties config&#x2F;server‐2.properties</span><br></pre></td></tr></table></figure><p>配置文件的需要修改的内容分别如下: </p><p>config/server-1.properties:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#broker.id属性在kafka集群中必须要是唯一</span><br><span class="line">broker.id&#x3D;1</span><br><span class="line">#kafka部署的机器ip和提供服务的端口号</span><br><span class="line">listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;192.168.65.60:9093</span><br><span class="line">log.dir&#x3D;&#x2F;usr&#x2F;local&#x2F;data&#x2F;kafka‐logs‐1</span><br><span class="line">#kafka连接zookeeper的地址，要把多个kafka实例组成集群，对应连接的zookeeper必须相同</span><br><span class="line">zookeeper.connect&#x3D;192.168.65.60:2181</span><br></pre></td></tr></table></figure><p>config/server-2.properties:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">broker.id&#x3D;2</span><br><span class="line">listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;192.168.65.60:9094</span><br><span class="line">log.dir&#x3D;&#x2F;usr&#x2F;local&#x2F;data&#x2F;kafka‐logs‐2</span><br><span class="line">zookeeper.connect&#x3D;192.168.65.60:2181</span><br></pre></td></tr></table></figure><p>目前已经有一个zookeeper实例和一个broker实例在运行了，现在我们只需要在启动2个broker实例即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐server‐start.sh ‐daemon config&#x2F;server‐1.properties </span><br><span class="line">bin&#x2F;kafka‐server‐start.sh ‐daemon config&#x2F;server‐2.properties</span><br></pre></td></tr></table></figure><p>查看zookeeper确认集群节点是否都注册成功:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211123102753.png" alt="image-20211123102753045"></p><p>现在我们创建一个新的topic，副本数设置为3，分区数设置为2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐topics.sh ‐‐create ‐‐zookeeper 192.168.65.60:2181 ‐‐replication ‐factor 3 ‐‐partitions 2 ‐‐topic my‐replica ted‐topic</span><br></pre></td></tr></table></figure><p>查看下topic的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐topics.sh ‐‐describe ‐‐zookeeper 192.168.65.60:2181 ‐‐topic my‐replicated‐topic</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211123102902.png" alt="image-20211123102902780"></p><p>以下是输出内容的解释，第一行是所有分区的概要信息，之后的每一行表示每一个partition的信息。</p><ul><li>leader节点负责给定partition的所有读写请求，同一个主题不同分区leader副本一般不一样(为了容灾)</li><li>replicas 表示某个partition在哪几个broker上存在备份。不管这个几点是不是”leader“，甚至这个节点挂了，也会列出。 </li><li>isr 是replicas的一个子集，它只列出当前还存活着的，并且已同步备份了该partition的节点。</li></ul><p>现在我们向新建的 my-replicated-topic 中发送一些message，kafka集群可以加上所有kafka节点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐console‐producer.sh ‐‐broker‐list 192.168.65.60:9092,192.168.65.60:9093,192.168.65.60:9094 ‐‐topic my‐repl icated‐topic</span><br><span class="line">&gt;my test msg1</span><br><span class="line">&gt;my test msg2</span><br></pre></td></tr></table></figure><p>现在开始消费:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐console‐consumer.sh ‐‐bootstrap ‐server 192.168.65.60:9092,192.168.65.60:9093,192.168.65.60:9094 ‐‐from‐beg inning ‐‐topic my‐replicated‐topic</span><br><span class="line">my test msg1</span><br><span class="line">my test msg2</span><br></pre></td></tr></table></figure><p>现在测试容错性，因为broker1目前是my-replicated-topic的分区0的leader，所以我们要将其kill</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps ‐ef|grep server.properties </span><br><span class="line">kill 14776</span><br></pre></td></tr></table></figure><p>现在再执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐topics.sh ‐‐describe ‐‐zookeeper 192.168.65.60:9092 ‐‐topic my‐replicated‐topic</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211123103929.png" alt="image-20211123103929198"></p><p>我们可以看到，分区0的leader节点已经变成了broker 0。要注意的是，在Isr中，已经没有了1号节点。leader的选举也是从ISR(in-sync replica)中进行的。<br>此时，我们依然可以消费新消息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka‐console‐consumer.sh ‐‐bootstrap ‐server 192.168.65.60:9092,192.168.65.60:9093,192.168.65.60:9094 ‐‐from‐beg inning ‐‐topic my‐replicated‐topic</span><br><span class="line">my test msg1</span><br><span class="line">my test msg2</span><br></pre></td></tr></table></figure><p>查看主题分区对应的leader信息:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211123104138.png" alt="image-20211123104138024"></p><p>kafka将很多集群关键信息记录在zookeeper里，保证自己的无状态，从而在水平扩容时非常方便。</p><h1 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h1><p>log的partitions分布在kafka集群中不同的broker上，每个broker可以请求备份其他broker上partition上的数据。</p><p>kafka 集群支持配置一个partition备份的数量。 针对每个partition，都有一个broker起到“leader”的作用，0个或多个其他的broker作为“follwers”的作用。 leader处理所有的针对这个partition的读写请求，而followers被动复制leader的结果，不提供读写(主要是为了保证多 副本数据与消费的一致性)。如果这个leader失效了，其中的一个follower将会自动的变成新的leader。</p><h2 id="Producers"><a href="#Producers" class="headerlink" title="Producers"></a>Producers</h2><p>生产者将消息发送到topic中去，同时负责选择将message发送到topic的哪一个partition中。通过round­-robin做简单的负载均衡。也可以根据消息中的某一个关键字来进行区分。通常第二种方式使用的更多。</p><h2 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h2><p>传统的消息传递模式有2种:队列( queue) 和(publish-subscribe)</p><ul><li>queue模式:多个consumer从服务器中读取数据，消息只会到达一个consumer。</li><li>publish-subscribe模式:消息会被广播给所有的consumer。</li></ul><p>Kafka基于这2种模式提供了一种consumer的抽象概念:consumer group。</p><ul><li>queue模式:所有的consumer都位于同一个consumer group 下。</li><li>publish-subscribe模式:所有的consumer都有着自己唯一的consumer group。</li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211123104831.png" alt="image-20211123104831310" style="zoom:50%;" /><p>上图说明:由2个broker组成的kafka集群，某个主题总共有4个partition(P0-P3)，分别位于不同的broker上。这个集群由2个Consumer Group消费， A有2个consumer instances ，B有4个。</p><p>通常一个topic会有几个consumer group，每个consumer group都是一个逻辑上的订阅者( logical subscriber )。每个consumer group由多个consumer instance组成，从而达到可扩展和容灾的功能。</p><h2 id="消费顺序"><a href="#消费顺序" class="headerlink" title="消费顺序"></a>消费顺序</h2><p>一个partition同一个时刻在一个consumer group中只能有一个consumer instance在消费，从而保证消费顺序。 consumer group中的consumer instance的数量不能比一个Topic中的partition的数量多，否则，多出来的 consumer消费不到消息。 Kafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序 性。<br>如果有在总体上保证消费顺序的需求，那么我们可以通过将topic的partition数量设置为1，将consumer group中的 consumer instance数量也设置为1，但是这样会影响性能，所以kafka的顺序消费很少用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的(partition)、多副本的(replica)，基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景:比如基于hadoop的批处理系统、低延迟的实时系统</summary>
      
    
    
    
    
    <category term="Kafka" scheme="https://tj-ever.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq 消息可靠性投递两种方案</title>
    <link href="https://tj-ever.github.io/2021/11/01/Rabbitmq%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/"/>
    <id>https://tj-ever.github.io/2021/11/01/Rabbitmq%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92/</id>
    <published>2021-10-31T16:00:00.000Z</published>
    <updated>2021-11-01T08:33:38.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息入库打标方案（需要跨库事务）"><a href="#消息入库打标方案（需要跨库事务）" class="headerlink" title="消息入库打标方案（需要跨库事务）"></a>消息入库打标方案（需要跨库事务）</h1><p>消息可靠性投递，就是确保生产端的消息准确无误的发送到消费端进行消费。</p><p>流程图如下，共七步：</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20201120135510.png" alt="image-20201120135510489"></p><blockquote><p>正常链路流程 </p><ol><li>(该环节调用了操作了二次数据库):在创建订单的操作的时候，把数据插入到订单相关的表中,并且构造调用物流模块的数据消息，把消息插入到消息表中,初始状态为0</li><li>把物流消息投递到消息队列中</li><li>消息队列访问一个确认消息，并且由订单服务来监控mq-server的确认消息</li><li>根据收到的确认消息来更新数据库中的消息记录的状态</li></ol></blockquote><blockquote><p>异常链路流程 </p><ol><li>(该环节调用了操作了二次数据库):在创建订单的操作的时候，把数据插入到订单相关的表中,并且构造调用物流模块的数据消息，把消息插入到消息表中,初始状态为0</li><li>把物流消息投递到消息队列中</li><li>由于网络闪断，导致消费端监控mq服务访问的确认消息没有收到，那么在msg_db中的那条消息的状态永远就是0状态。这个时候，我们需要对这种情况下做出补偿</li></ol></blockquote><blockquote><p>补偿机制:</p><p>启动一个分布式的定时任务,不定时的去扫描msg_db的这个表，状态为0的消息记录，在这里我们可以根据业务来设置扫描重发规则</p><p>规则1：插入msg_db 表中5Min后状态还是为0的记录，进行消息重试</p><p>规则2:若重试的次数超过五次状态还是为0的话，我们就把消息状态改为2，此时我们需要人工的去确认状态为2的消息是什么原因导致没有成功的</p></blockquote><p><strong>消息入库打标的缺点:</strong></p><p><strong>在第一步的过程中，既插入了业务数据表，也同时插入了消息记录表，进行了二次db操作，在高并发的环境下，这个环境就会造成性能瓶颈</strong></p><p>直接上代码，以保存订单消费库存为例。</p><h2 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h2><p>消息路由配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">orderExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DirectExchange directExchange = <span class="keyword">new</span> DirectExchange(<span class="string">&quot;order-exchange&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> directExchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;order-queue&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">orderBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(orderQueue()).to(orderExchange()).with(<span class="string">&quot;order-key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息发送组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgComfirm msgComfirm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgRetrunListener msgRetrunListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">senderMsg</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(order.getId());</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;order-exchange&quot;</span>,<span class="string">&quot;order-key&quot;</span>, msgTxtBo, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(msgComfirm);</span><br><span class="line">        rabbitTemplate.setReturnCallback(msgRetrunListener);</span><br><span class="line">        <span class="comment">//设置消息转换器</span></span><br><span class="line">        Jackson2JsonMessageConverter jackson2JsonMessageConverter = <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">        rabbitTemplate.setMessageConverter(jackson2JsonMessageConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消息确认回调组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgComfirm</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgContentMapper msgContentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String msgId = correlationData.getId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息Id:&#123;&#125;对应的消息被broker签收成功&quot;</span>,msgId);</span><br><span class="line">            <span class="comment">//更新消息表状态发送成功</span></span><br><span class="line">            updateMsgStatusWithAck(msgId);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;消息Id:&#123;&#125;对应的消息被broker签收失败:&#123;&#125;&quot;</span>,msgId,cause);</span><br><span class="line">            <span class="comment">//更新消息表状态发送失败</span></span><br><span class="line">            updateMsgStatusWithNack(msgId,cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息不可达回调组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgRetrunListener</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgContentMapper msgContentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            MsgTxtBo msgTxtBo = objectMapper.readValue(message.getBody(),MsgTxtBo.class);</span><br><span class="line">            log.info(<span class="string">&quot;无法路由消息内容:&#123;&#125;,cause:&#123;&#125;&quot;</span>,msgTxtBo,replyText);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构建消息对象</span></span><br><span class="line">            MessageContent messageContent = <span class="keyword">new</span> MessageContent();</span><br><span class="line">            messageContent.setErrCause(replyText);</span><br><span class="line">            messageContent.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line">            messageContent.setMsgStatus(<span class="string">&quot;send faild&quot;</span>);</span><br><span class="line">            messageContent.setMsgId(msgTxtBo.getMsgId());</span><br><span class="line">            <span class="comment">//更新消息表</span></span><br><span class="line">            msgContentMapper.updateMsgStatus(messageContent);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;更新消息表异常:&#123;&#125;&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/saveOrder&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrder</span><span class="params">(Order order)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        orderInfoService.saveOrderInfoWithMessage(oid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrderInfoWithMessage</span><span class="params">(Order order)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">//构建消息对象 (省略构建)</span></span><br><span class="line">        MessageContent messageContent = <span class="keyword">new</span> MessageContent();</span><br><span class="line">        <span class="comment">//保存数据库</span></span><br><span class="line">        saveOrderInfo(order,messageContent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建消息发送对象 (省略构建)</span></span><br><span class="line">        MsgTxtBo msgTxtBo = <span class="keyword">new</span> MsgTxtBo();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        msgSender.senderMsg(msgTxtBo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存数据操作</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrderInfo</span><span class="params">(Order order, MessageContent messageContent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//插入业务表</span></span><br><span class="line">            orderInfoMapper.saveOrderInfo(order);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//插入消息表</span></span><br><span class="line">            msgContentMapper.saveMsgContent(messageContent);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;操作数据库失败:&#123;&#125;&quot;</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;操作数据库失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时任务 重发未送达消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryMsgTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgSender msgSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgContentMapper msgContentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 5000,fixedDelay = 5000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retrySend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询五分钟消息状态还没有完结的消息</span></span><br><span class="line">        List&lt;MessageContent&gt; messageContentList = msgContentMapper.qryNeedRetryMsg();</span><br><span class="line"><span class="comment">//满足重发状态的重新发送</span></span><br><span class="line">        <span class="keyword">for</span>(MessageContent messageContent:messageContentList) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(messageContent.getMaxRetry()&gt;messageContent.getCurrentRetry()) &#123;</span><br><span class="line">                MsgTxtBo msgTxtBo = <span class="keyword">new</span> MsgTxtBo();</span><br><span class="line">                msgTxtBo.setMsgId(messageContent.getMsgId());</span><br><span class="line">                msgTxtBo.setProductNo(messageContent.getProductNo());</span><br><span class="line">                msgTxtBo.setOrderNo(messageContent.getOrderNo());</span><br><span class="line">                <span class="comment">//更新消息重试次数</span></span><br><span class="line">                msgContentMapper.updateMsgRetryCount(msgTxtBo.getMsgId());</span><br><span class="line">                msgSender.senderMsg(msgTxtBo);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;消息:&#123;&#125;以及达到最大重试次数&quot;</span>,messageContent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h2><p>消费者组件（未加分布式锁，可能存在重复消费问题）</p><p>ps：比如消息刚到消费者正准备处理，服务端网络抖动又重发一条，这是就消费两条</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ORDER_TO_PRODUCT_QUEUE_NAME = <span class="string">&quot;order-to-product.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_KEY=<span class="string">&quot;LOCK_KEY&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgContentMapper msgContentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有加分布式锁的版本,可能存在重复消费问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;ORDER_TO_PRODUCT_QUEUE_NAME&#125;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        MsgTxtBo msgTxtBo = objectMapper.readValue(message.getBody(),MsgTxtBo.class);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消费消息:&#123;&#125;&quot;</span>,msgTxtBo);</span><br><span class="line">        Long deliveryTag = (Long) message.getMessageProperties().getDeliveryTag();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//更新消息表业务表</span></span><br><span class="line">            productService.updateProductStore(msgTxtBo);</span><br><span class="line">            <span class="comment">//模拟网络抖动 导致重复发送</span></span><br><span class="line">            System.out.println(<span class="number">1</span>/<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//消息签收</span></span><br><span class="line">            channel.basicAck(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//更新msg表为消费失败</span></span><br><span class="line">            <span class="comment">//更新消息表状态</span></span><br><span class="line">            MessageContent messageContent = <span class="keyword">new</span> MessageContent();</span><br><span class="line">            messageContent.setMsgId(msgTxtBo.getMsgId());</span><br><span class="line">            messageContent.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line">            messageContent.setMsgStatus(MsgStatusEnum.CONSUMER_FAIL.getCode());</span><br><span class="line">            msgContentMapper.updateMsgStatus(messageContent);</span><br><span class="line"></span><br><span class="line">            channel.basicReject(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者组件（带分布式锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ORDER_TO_PRODUCT_QUEUE_NAME = <span class="string">&quot;order-to-product.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_KEY=<span class="string">&quot;LOCK_KEY&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgContentMapper msgContentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;ORDER_TO_PRODUCT_QUEUE_NAME&#125;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerMsgWithLock</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        MsgTxtBo msgTxtBo = objectMapper.readValue(message.getBody(), MsgTxtBo.class);</span><br><span class="line">        Long deliveryTag = (Long) message.getMessageProperties().getDeliveryTag();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.opsForValue().setIfAbsent(LOCK_KEY + msgTxtBo.getMsgId(), msgTxtBo.getMsgId())) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消费消息:&#123;&#125;&quot;</span>, msgTxtBo);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//更新消息表也业务表</span></span><br><span class="line">                productService.updateProductStore(msgTxtBo);</span><br><span class="line">                <span class="comment">//消息签收</span></span><br><span class="line">                System.out.println(<span class="number">1</span>/<span class="number">0</span>);</span><br><span class="line">                channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 更新数据库异常说明业务没有操作成功需要删除分布式锁</span></span><br><span class="line"><span class="comment">                 * BizExp自行封装业务异常</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BizExp) &#123;</span><br><span class="line">                    BizExp bizExp = (BizExp) e;</span><br><span class="line">                    log.info(<span class="string">&quot;数据业务异常:&#123;&#125;,即将删除分布式锁&quot;</span>, bizExp.getErrMsg());</span><br><span class="line">                    <span class="comment">//删除分布式锁</span></span><br><span class="line">                    redisTemplate.delete(LOCK_KEY);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新消息表状态</span></span><br><span class="line">                MessageContent messageContent = <span class="keyword">new</span> MessageContent();</span><br><span class="line">                messageContent.setMsgStatus(<span class="string">&quot;send success&quot;</span>);</span><br><span class="line">                messageContent.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line">                messageContent.setErrCause(e.getMessage());</span><br><span class="line">                messageContent.setMsgId(msgTxtBo.getMsgId());</span><br><span class="line">                msgContentMapper.updateMsgStatus(messageContent);</span><br><span class="line">                channel.basicReject(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;请不要重复消费消息&#123;&#125;&quot;</span>, msgTxtBo);</span><br><span class="line">            channel.basicReject(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateProductStore</span><span class="params">(MsgTxtBo msgTxtBo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> updateFlag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//更新库存</span></span><br><span class="line">        productInfoMapper.updateProductStoreById(msgTxtBo.getProductNo());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新消息表状态</span></span><br><span class="line">            MessageContent messageContent = <span class="keyword">new</span> MessageContent();</span><br><span class="line">            messageContent.setMsgId(msgTxtBo.getMsgId());</span><br><span class="line">            messageContent.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line">            messageContent.setMsgStatus(<span class="string">&quot;send success&quot;</span>);</span><br><span class="line">            msgContentMapper.updateMsgStatus(messageContent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(1/0);</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;更新数据库失败:&#123;&#125;&quot;</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BizExp(<span class="number">0</span>,<span class="string">&quot;更新数据库异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updateFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="延时投递，二次确认检测，回调检测方案（无需跨库事务）"><a href="#延时投递，二次确认检测，回调检测方案（无需跨库事务）" class="headerlink" title="延时投递，二次确认检测，回调检测方案（无需跨库事务）"></a>延时投递，二次确认检测，回调检测方案（无需跨库事务）</h1><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211101155432.png" alt="image-20211101155432383"></p><p>需要新增一个毁掉检查服务。</p><p><strong>在order服务中，执行1，2，3步骤</strong></p><p><strong>第1，2步将业务数据插入数据库，同时发送入库消息给到mq服务</strong></p><p><strong>其中第三步发送延迟检查消息的时间要大于库存服务和回调检查服务的执行时间，目的是为了在一开始创建订单后，立马发送个延迟消息，半小时后再检查是否操作成功，没有成功则重发消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrderInfoWithMessage</span><span class="params">(OrderInfo orderInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//构建消息对象</span></span><br><span class="line">       MessageContent messageContent = builderMessageContent(orderInfo.getOrderNo(),orderInfo.getProductNo());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//保存数据库</span></span><br><span class="line">       saveOrderInfo(orderInfo);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//构建消息发送对象</span></span><br><span class="line">       MsgTxtBo msgTxtBo = <span class="keyword">new</span> MsgTxtBo();</span><br><span class="line">       msgTxtBo.setMsgId(messageContent.getMsgId());</span><br><span class="line">       msgTxtBo.setOrderNo(orderInfo.getOrderNo());</span><br><span class="line">       msgTxtBo.setProductNo(orderInfo.getProductNo());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//第一次发送消息</span></span><br><span class="line">       msgSender.senderMsg(msgTxtBo);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//发送延时消息</span></span><br><span class="line">       msgSender.senderDelayCheckMsg(msgTxtBo);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>在库存服务中，执行4，5步骤</strong></p><p><strong>第四步监听入库消息，执行业务操作。第五步发送业务成功的消息到mq服务器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;ORDER_TO_PRODUCT_QUEUE_NAME&#125;)</span></span><br><span class="line">   <span class="meta">@RabbitHandler</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerMsgWithLock</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       MsgTxtBo msgTxtBo = objectMapper.readValue(message.getBody(), MsgTxtBo.class);</span><br><span class="line">       Long deliveryTag = (Long) message.getMessageProperties().getDeliveryTag();</span><br><span class="line">       <span class="keyword">if</span> (redisTemplate.opsForValue().setIfAbsent(LOCK_KEY + msgTxtBo.getMsgId(), msgTxtBo.getMsgId())) &#123;</span><br><span class="line">           log.info(<span class="string">&quot;消费消息:&#123;&#125;&quot;</span>, msgTxtBo);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//更新消息表也业务表</span></span><br><span class="line">               productService.updateProductStore(msgTxtBo);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//发送一条确认消费消息到callback服务上</span></span><br><span class="line">               msgSender.senderMsg(msgTxtBo);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//消息签收</span></span><br><span class="line">               channel.basicAck(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BizExp) &#123;</span><br><span class="line">                   BizExp bizExp = (BizExp) e;</span><br><span class="line">                   log.info(<span class="string">&quot;数据业务异常:&#123;&#125;,即将删除分布式锁&quot;</span>, bizExp.getErrMsg());</span><br><span class="line">                   <span class="comment">//删除分布式锁</span></span><br><span class="line">                   redisTemplate.delete(LOCK_KEY);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           log.warn(<span class="string">&quot;请不要重复消费消息&#123;&#125;&quot;</span>, msgTxtBo);</span><br><span class="line">           channel.basicReject(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>在回调服务中，执行6，7，8，9，10操作</strong></p><p><strong>第六步需要创建监听方法，监听第五步的业务操作成功消息</strong></p><p><strong>第七步入库消息表（能存在表里说明业务肯定执行成功）</strong></p><p><strong>第8，9，10步需要创建监听方法，监听订单服务发出的延迟检查消息，然后判断消息是否存在于消息表中，若不存在，则重发消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;MqConst.ORDER_TO_PRODUCT_DELAY_QUEUE_NAME&#125;)</span></span><br><span class="line"> <span class="meta">@RabbitHandler</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerCheckMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">     MsgTxtBo msgTxtBo = objectMapper.readValue(message.getBody(), MsgTxtBo.class);</span><br><span class="line">     System.out.println(<span class="string">&quot;==================&gt;&quot;</span>+msgTxtBo.toString());</span><br><span class="line">     Long deliveryTag = (Long) message.getMessageProperties().getDeliveryTag();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//替换延时消息ID</span></span><br><span class="line">     String msgId = msgTxtBo.getMsgId().replace(<span class="string">&quot;_delay&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">     MessageContent messageContent = msgContentMapper.qryMessageContentById(msgId);</span><br><span class="line"></span><br><span class="line">     log.info(<span class="string">&quot;消费延时消息:&#123;&#125;&quot;</span>,msgTxtBo.toString());</span><br><span class="line"></span><br><span class="line">     <span class="comment">//表示消息消费者没有发送确认消息,需要回调生产者重新发送消息</span></span><br><span class="line">     <span class="keyword">if</span>(messageContent == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//回调订单服务,从新发送消息</span></span><br><span class="line">         RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">         restTemplate.postForEntity(<span class="string">&quot;http://localhost:8080/retryMsg&quot;</span>,msgTxtBo,String.class);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//签收消息</span></span><br><span class="line">     channel.basicAck(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;消息入库打标方案（需要跨库事务）&quot;&gt;&lt;a href=&quot;#消息入库打标方案（需要跨库事务）&quot; class=&quot;headerlink&quot; title=&quot;消息入库打标方案（需要跨库事务）&quot;&gt;&lt;/a&gt;消息入库打标方案（需要跨库事务）&lt;/h1&gt;&lt;p&gt;消息可靠性投递，就是确保生产</summary>
      
    
    
    
    
    <category term="rabbitmq" scheme="https://tj-ever.github.io/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq 高级特性及整合springboot</title>
    <link href="https://tj-ever.github.io/2021/10/25/Rabbitmq%20%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%8F%8A%E6%95%B4%E5%90%88springboot/"/>
    <id>https://tj-ever.github.io/2021/10/25/Rabbitmq%20%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%8F%8A%E6%95%B4%E5%90%88springboot/</id>
    <published>2021-10-24T16:00:00.000Z</published>
    <updated>2021-11-01T07:07:26.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h1><p>对接口发起的一次调用和多次调用，结果都是一致的。</p><p>某些接口具有天然的幂等性: 比如长查询接口，不管是查询一次还是多次，返回的结果都 是一致的</p><h2 id="MQ-是如何解决幂等性的"><a href="#MQ-是如何解决幂等性的" class="headerlink" title="MQ 是如何解决幂等性的"></a>MQ 是如何解决幂等性的</h2><p>发送消息的流程</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211101150545.png" alt="image-20211101150545762" style="zoom:50%;" /><ol><li>消息生产者向Mq服务端发送消息</li><li>mq 服务端把消息进行落地</li><li>消息服务端向消息生产者发送ack</li><li>消息消费者消费消息</li><li>消费者发送ack</li><li>mq服务将落地消息删除</li></ol><h2 id="消息重复发送的原因"><a href="#消息重复发送的原因" class="headerlink" title="消息重复发送的原因"></a>消息重复发送的原因</h2><p>为了保障消息的百分之百的投递，我们使用了消息重发，确认机制，使得消息可能被重复发送，由上图可知，由于网络原因，第三步ack丢失还是第五步的ack丢失，都会导致消息重复发送</p><h2 id="mq服务端如何保证幂等性"><a href="#mq服务端如何保证幂等性" class="headerlink" title="mq服务端如何保证幂等性"></a>mq服务端如何保证幂等性</h2><p>消息队列的服务中，对每一条消息都会生成一个全局唯一的与业务无关的ID(inner_msg_id),当mq_server 接受到消息的时候，先根据inner_msg_id 是否需要重复发送，再决定消息是否落DB ,这样保证每条消息都 只会落一次DB</p><h2 id="消费端如何来做到幂等性"><a href="#消费端如何来做到幂等性" class="headerlink" title="消费端如何来做到幂等性"></a>消费端如何来做到幂等性</h2><p>对每条消息做生成一个唯一性的ID 通过redis的来setnx命令来保证幂等性。</p><h1 id="整合springboot"><a href="#整合springboot" class="headerlink" title="整合springboot"></a>整合springboot</h1><p>创建两个工程，一个生产者provider，一个消费者consumer</p><p>代码结构如下图</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211025180825.png" alt="image-20211025180825245" style="zoom:50%;" /><p>pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--rabbitmq--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9021</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq-provider</span></span><br><span class="line">  <span class="comment">#配置rabbitMq 服务器</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="comment">#虚拟host 可以不设置,使用server默认host</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/tj-vhost</span></span><br></pre></td></tr></table></figure><h2 id="direct模式"><a href="#direct模式" class="headerlink" title="direct模式"></a>direct模式</h2><p>在生产者provider下创建direct模式配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE = <span class="string">&quot;tj-direct-exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">&quot;tj-direct-queue&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY = <span class="string">&quot;tj.direct&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">directExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">directQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效</span></span><br><span class="line">        <span class="comment">// exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line">        <span class="comment">// autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。</span></span><br><span class="line">        <span class="comment">//一般设置一下队列的持久化就好,其余两个就是默认false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue()).to(directExchange()).with(ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类，用于发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProviderApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;  <span class="comment">//使用RabbitTemplate,这提供了接收/发送等等方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDirectMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;messageId&quot;</span>, i);</span><br><span class="line">            map.put(<span class="string">&quot;messageData&quot;</span>, <span class="string">&quot;第 &quot;</span> + i + <span class="string">&quot; 个消息&quot;</span>);</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;tj-direct-exchange&quot;</span>, <span class="string">&quot;tj.direct&quot;</span>, map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消费者consumer下创建监听类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;tj-direct-queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Map testMessage)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DirectListener消费者收到消息  : &quot;</span> + testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211025182545.png" alt="image-20211025182545954" style="zoom:50%;" /><h2 id="topic模式"><a href="#topic模式" class="headerlink" title="topic模式"></a>topic模式</h2><p>在生产者provider下创建topic模式配置类</p><p>配置类中定义一个通配符路由，一个固定值路由</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE = <span class="string">&quot;tj-topic-exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_SINGLE = <span class="string">&quot;tj-topic-queue-single&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_ALL = <span class="string">&quot;tj-topic-queue-all&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY_SINGLE = <span class="string">&quot;tj.topic.single&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY_ALL = <span class="string">&quot;tj.topic.#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TopicExchange <span class="title">topicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueueSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_SINGLE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueueAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_ALL, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingTopicSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueueSingle()).to(topicExchange()).with(ROUTING_KEY_1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingTopicAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueueAll()).to(topicExchange()).with(ROUTING_KEY_ALL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类，用于发送消息</p><p>两个测试类对应两个路由，通配符路由可以接受到两种消息，固定路由只能接受到一种消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTopicSingleMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;messageId&quot;</span>, i);</span><br><span class="line">        map.put(<span class="string">&quot;messageData&quot;</span>, <span class="string">&quot;第 &quot;</span> + i + <span class="string">&quot; 个消息&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;tj-topic-exchange&quot;</span>, <span class="string">&quot;tj.topic.single&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTopicAllMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;messageId&quot;</span>, i);</span><br><span class="line">        map.put(<span class="string">&quot;messageData&quot;</span>, <span class="string">&quot;第 &quot;</span> + i + <span class="string">&quot; 个消息&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;tj-topic-exchange&quot;</span>, <span class="string">&quot;tj.topic.all&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消费者consumer下创建两个监听类，分别监听single路由和all路由</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;tj-topic-queue-single&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Map testMessage)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;TopicListener 消费者收到消息  : &quot;</span> + testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;tj-topic-queue-all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllTopicListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Map testMessage)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;AllTopicListener 消费者收到消息  : &quot;</span> + testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sendTopicSingleMessage测试结果如下</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211025183340.png" alt="image-20211025183340850" style="zoom:50%;" /><p>sendTopicAllMessage测试结果如下</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211025183421.png" alt="image-20211025183421762" style="zoom:50%;" /><h2 id="fanout模式"><a href="#fanout模式" class="headerlink" title="fanout模式"></a>fanout模式</h2><p>在生产者provider下创建fanout模式配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE = <span class="string">&quot;tj-fanout-exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">&quot;tj-fanout-queue-a&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">&quot;tj-fanout-queue-b&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为是扇型交换机, 路由键无需配置,配置也不起作用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类，用于发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFanoutMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">         map.put(<span class="string">&quot;messageId&quot;</span>, i);</span><br><span class="line">         map.put(<span class="string">&quot;messageData&quot;</span>, <span class="string">&quot;第 &quot;</span> + i + <span class="string">&quot; 个消息&quot;</span>);</span><br><span class="line">         rabbitTemplate.convertAndSend(<span class="string">&quot;tj-fanout-exchange&quot;</span>, <span class="keyword">null</span>, map);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在消费者consumer下创建两个监听类，分别监听a，b两个队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;tj-fanout-queue-a&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiverA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Map testMessage)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FanoutReceiverA 消费者收到消息  : &quot;</span> + testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;tj-fanout-queue-b&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiverB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Map testMessage)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FanoutReceiverB 消费者收到消息  : &quot;</span> + testMessage.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211025185654.png" alt="image-20211025185653982" style="zoom:50%;" /><h2 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h2><p>在生产者配置文件中增加消息确认配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9021</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq-provider</span></span><br><span class="line">  <span class="comment">#配置rabbitMq 服务器</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="comment">#虚拟host 可以不设置,使用server默认host</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/tj-vhost</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#确认消息已发送到交换机(Exchange)</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="comment">#确认消息已发送到队列(Queue)</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>配置RabbitTemplate，增加消息确认回调函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">createRabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">        rabbitTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">//设置开启Mandatory,才能触发回调函数,无论消息推送结果怎么样都强制调用回调函数</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ConfirmCallback:     &quot;</span>+<span class="string">&quot;相关数据：&quot;</span>+correlationData);</span><br><span class="line">                System.out.println(<span class="string">&quot;ConfirmCallback:     &quot;</span>+<span class="string">&quot;确认情况：&quot;</span>+ack);</span><br><span class="line">                System.out.println(<span class="string">&quot;ConfirmCallback:     &quot;</span>+<span class="string">&quot;原因：&quot;</span>+cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;消息：&quot;</span>+message);</span><br><span class="line">                System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;回应码：&quot;</span>+replyCode);</span><br><span class="line">                System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;回应信息：&quot;</span>+replyText);</span><br><span class="line">                System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;交换机：&quot;</span>+exchange);</span><br><span class="line">                System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;路由键：&quot;</span>+routingKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息发送情况测试"><a href="#消息发送情况测试" class="headerlink" title="消息发送情况测试"></a>消息发送情况测试</h3><p>上面写了两个回调函数，一个叫 ConfirmCallback ，一个叫 RetrunCallback；</p><p>那么以上这两种回调函数都是在什么情况会触发呢？</p><p>先从总体的情况分析，推送消息存在三种情况：</p><ul><li>消息推送到server，但是在server里找不到交换机</li><li>消息推送到server，找到交换机了，但是没找到队列</li><li>消息推送成功</li></ul><p><strong>消息推送到server，但是在server里找不到交换机</strong></p><p>写个测试类，把消息推送到名为‘non-existent-exchange’的交换机上（这个交换机是没有创建没有配置的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNoExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">          Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">          map.put(<span class="string">&quot;messageId&quot;</span>, i);</span><br><span class="line">          map.put(<span class="string">&quot;messageData&quot;</span>, <span class="string">&quot;第 &quot;</span> + i + <span class="string">&quot; 个消息&quot;</span>);</span><br><span class="line">          rabbitTemplate.convertAndSend(<span class="string">&quot;non-existent-exchange&quot;</span>, <span class="string">&quot;tj.routing&quot;</span>, map);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211025192001.png" alt="image-20211025192001191" style="zoom:50%;" /><p> 结论： 这种情况触发的是 ConfirmCallback 回调函数。</p><p><strong>消息推送到server，找到交换机了，但是没找到队列</strong> </p><p>这种情况就是需要新增一个交换机，但是不给这个交换机绑定队列</p><p>简单地在DirectRabitConfig里面新增一个直连交换机，名叫‘lonelyDirectExchange’，但没给它做任何绑定配置操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="function">DirectExchange <span class="title">lonelyDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;lonelyDirectExchange&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>写个测试类，把消息推送到名为‘lonelyDirectExchange’的交换机上（这个交换机是没有任何队列配置的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLonelyDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">         Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">         map.put(<span class="string">&quot;messageId&quot;</span>, i);</span><br><span class="line">         map.put(<span class="string">&quot;messageData&quot;</span>, <span class="string">&quot;第 &quot;</span> + i + <span class="string">&quot; 个消息&quot;</span>);</span><br><span class="line">         rabbitTemplate.convertAndSend(<span class="string">&quot;lonelyDirectExchange&quot;</span>, <span class="string">&quot;tj.routing&quot;</span>, map);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211025192421.png" alt="image-20211025192421548" style="zoom:50%;" /><p>可以看到两个函数都被调用了</p><p>这种情况下，消息是推送成功到服务器了的，所以ConfirmCallback对消息确认情况是true；<br>而在RetrunCallback回调函数的打印参数里面可以看到，消息是推送到了交换机成功了，但是在路由分发给队列的时候，找不到队列，所以报了错误 NO_ROUTE 。<br>结论：这种情况触发的是 ConfirmCallback和RetrunCallback两个回调函数。</p><p><strong>消息推送成功</strong></p><p>那么测试下，按照正常调用之前消息推送的接口就行，就调用下 /sendFanoutMessage接口，可以看到控制台输出：</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211025192725.png" alt="image-20211025192724994" style="zoom:50%;" /><p>结论： 这种情况触发的是 ConfirmCallback 回调函数。</p><h3 id="消息确认测试"><a href="#消息确认测试" class="headerlink" title="消息确认测试"></a>消息确认测试</h3><p>消费者接收到消息的消息确认机制，和生产者的消息确认机制不同，因为消息接收本来就是在监听消息，符合条件的消息就会消费下来。<br>所以，消息接收的确认机制主要存在三种模式：</p><ul><li><p>①自动确认， 这也是默认的消息确认情况。  AcknowledgeMode.NONE<br>RabbitMQ成功将消息发出（即将消息成功写入TCP Socket）中立即认为本次投递已经被正确处理，不管消费者端是否成功处理本次投递。所以这种情况如果消费端消费逻辑抛出异常，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息。一般这种情况我们都是使用try catch捕捉异常后，打印日志用于追踪数据，这样找出对应数据再做后续处理。</p></li><li><p>② 根据情况确认， 这个不做介绍</p></li><li><p>③ 手动确认 ， 这个比较关键，也是我们配置接收消息确认机制时，多数选择的模式。<br>消费者收到消息后，手动调用basic.ack/basic.nack/basic.reject后，RabbitMQ收到这些消息后，才认为本次投递成功。<br>basic.ack用于肯定确认<br>basic.nack用于否定确认（注意：这是AMQP 0-9-1的RabbitMQ扩展）<br>basic.reject用于否定确认，但与basic.nack相比有一个限制:一次只能拒绝单条消息 </p><p>消费者端以上的3个方法都表示消息已经被正确投递，但是basic.ack表示消息已经被正确处理。<br>而basic.nack,basic.reject表示没有被正确处理：</p></li></ul><p><strong>着重讲下reject，因为有时候一些场景是需要重新入列的。</strong></p><p>channel.basicReject(deliveryTag, true);  拒绝消费当前消息，如果第二参数传入true，就是将数据重新丢回队列里，那么下次还会消费这消息。设置false，就是告诉服务器，我已经知道这条消息数据了，因为一些原因拒绝它，而且服务器也把这个消息丢掉就行。 下次不想再消费这条消息了。</p><p><strong><em>使用拒绝后重新入列这个确认模式要谨慎，因为一般都是出现异常的时候，catch异常再拒绝入列，选择是否重入列。</em></strong></p><p><strong><em>但是如果使用不当会导致一些每次都被你重入列的消息一直消费-入列-消费-入列这样循环，会导致消息积压。</em></strong></p><p>简单讲讲 nack，这个也是相当于设置不消费某条消息。</p><p>channel.basicNack(deliveryTag, false, true);<br>第一个参数依然是当前消息到的数据的唯一id;<br>第二个参数是指是否针对多条消息；如果是true，也就是说一次性针对当前通道的消息的tagID小于当前这条消息的，都拒绝确认。<br>第三个参数是指是否重新入列，也就是指不确认的消息是否重新丢回到队列里面去。</p><p><strong>同样使用不确认后重新入列这个确认模式要谨慎，因为这里也可能因为考虑不周出现消息一直被重新丢回去的情况，导致积压。</strong></p><p>在消费者下创建监听配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CachingConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息接收处理类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAckReceiver myAckReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">simpleMessageListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">        container.setConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">        container.setMaxConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">        container.setAcknowledgeMode(AcknowledgeMode.MANUAL); <span class="comment">// RabbitMQ默认是自动确认，这里改为手动确认消息</span></span><br><span class="line">        <span class="comment">//设置一个队列</span></span><br><span class="line">        container.setQueueNames(<span class="string">&quot;TestDirectQueue&quot;</span>);</span><br><span class="line">        <span class="comment">//如果同时设置多个如下： 前提是队列都是必须已经创建存在的</span></span><br><span class="line">        <span class="comment">//  container.setQueueNames(&quot;TestDirectQueue&quot;,&quot;TestDirectQueue2&quot;,&quot;TestDirectQueue3&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//另一种设置队列的方法,如果使用这种情况,那么要设置多个,就使用addQueues</span></span><br><span class="line">        <span class="comment">//container.setQueues(new Queue(&quot;TestDirectQueue&quot;,true));</span></span><br><span class="line">        <span class="comment">//container.addQueues(new Queue(&quot;TestDirectQueue2&quot;,true));</span></span><br><span class="line">        <span class="comment">//container.addQueues(new Queue(&quot;TestDirectQueue3&quot;,true));</span></span><br><span class="line">        container.setMessageListener(myAckReceiver);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手动确认模式需要实现 ChannelAwareMessageListener</p><p>创建对应的手动确认消息监听类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAckReceiver</span> <span class="keyword">implements</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String msg = message.toString();</span><br><span class="line">            System.out.println(<span class="string">&quot;  MyAckReceiver  msg:&quot;</span> + msg);</span><br><span class="line">            System.out.println(<span class="string">&quot;消费的主题消息来自：&quot;</span> + message.getMessageProperties().getConsumerQueue());</span><br><span class="line">            channel.basicAck(deliveryTag, <span class="keyword">true</span>); <span class="comment">//第二个参数，手动确认可以被批处理，当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的所有消息</span></span><br><span class="line"><span class="comment">//channel.basicReject(deliveryTag, true);//第二个参数，true会重新放回队列，所以需要自己根据业务逻辑判断什么时候使用拒绝</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            channel.basicReject(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211026103608.png" alt="image-20211026103608584" style="zoom:50%;" /><h1 id="TTL和死信队列"><a href="#TTL和死信队列" class="headerlink" title="TTL和死信队列"></a>TTL和死信队列</h1><p><strong>什么是TTL</strong></p><ul><li><p>time to live 消息存活时间</p></li><li><p>如果消息在存活时间内未被消费，则会被清除</p></li><li><p>RabbitMQ支持两种ttl设置</p></li><li><ul><li>单独消息进行配置ttl</li><li>整个队列进行配置ttl（居多）</li></ul></li></ul><p><strong>什么是rabbitmq的死信队列</strong></p><ul><li>没有被及时消费的消息存放的队列</li></ul><p><strong>什么是rabbitmq的死信交换机</strong></p><ul><li>Dead Letter Exchange（死信交换机，缩写：DLX）当消息成为死信后，会被重新发送到另⼀个交换机，这个交换机就是DLX死信交换机。</li></ul><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211026104839" alt="图片"></p><p><strong>消息有哪几种情况成为死信</strong> </p><ul><li>消费者拒收消息（basic.reject/ basic.nack） ，并且没有重新入队 requeue=false</li><li>消息在队列中未被消费，且超过队列或者消息本身的过期时间TTL(time-to-live)</li><li>队列的消息长度达到极限</li><li>结果：消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列</li></ul><h2 id="管控台消息TTL测试"><a href="#管控台消息TTL测试" class="headerlink" title="管控台消息TTL测试"></a><strong>管控台消息TTL测试</strong></h2><p>队列过期时间使用参数，对整个队列消息统⼀过期</p><ul><li>x-message-ttl</li><li>单位ms(毫秒)</li></ul><p>消息过期时间使用参数（如果队列头部消息未过期，队列中级消息已经过期，消息还在队列里面）</p><ul><li>expiration</li><li>)</li></ul><p>两者都配置的话，时间短的先触发</p><p><strong>新建死信交换机</strong>(和普通没区别)</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211026105048" alt="图片"></p><p><strong>新建死信队列</strong>(和普通没区别)</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211026105107" alt="图片"></p><p><strong>死信交换机和队列绑定</strong></p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211026105122" alt="图片"></p><p><strong>新建普通队列，设置过期时间、指定死信交换机</strong> </p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211026105320" alt="图片"></p><p>测试：直接web控制台往product_qeueu发送消息即可，会看到消息先是在product_qeueu队列停留10秒（因为没有消费者消费），然后该消息从product_qeueu移入到dead_queue。</p><h2 id="延迟队列和应用场景"><a href="#延迟队列和应用场景" class="headerlink" title="延迟队列和应用场景"></a><strong>延迟队列和应用场景</strong></h2><h3 id="什么是延迟队列"><a href="#什么是延迟队列" class="headerlink" title="什么是延迟队列"></a>什么是延迟队列</h3><p>⼀种带有延迟功能的消息队列， Producer 将消息发送到消息队列服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某⼀个时间投递到Consumer进行消费，该消息即定时消息。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>通过消息触发⼀些定时任务，比如在某⼀固定时间点向用户发送提醒消息</li><li>用户登录之后5分钟给用户做分类推送、用户多少天未登录给用户做召回推送；</li><li>消息生产和消费有时间窗⼝要求：比如在天猫电商交易中超时未支付关闭订单的场景，在订单创建时会发送⼀条延时消息。这条消息将会在30分钟以后投递给消费者，消费者收到此消息后需要判断对应的订单是否已完成支付。如支付未完成，则关闭订单。如已完成支付则忽略</li></ul><h2 id="使用TTL和死信队列实现延迟队列"><a href="#使用TTL和死信队列实现延迟队列" class="headerlink" title="使用TTL和死信队列实现延迟队列"></a>使用TTL和死信队列实现延迟队列</h2><p>在privider创建死信相关配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE = <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入死信队列的路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_ROUTING_KEY = <span class="string">&quot;dead_routing_key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">deadExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(DEAD_EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DEAD_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定死信交换机和死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Binding(DEAD_QUEUE, Binding.DestinationType.QUEUE,</span><br><span class="line">                DEAD_EXCHANGE, DEAD_QUEUE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通队列，绑定的个死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE = <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通的topic交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//路由key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_ROUTIING_KEY = <span class="string">&quot;normal_routing_key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建普通交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">normalExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(NORMAL_EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建普通队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">normalQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//消息过期后，进入到死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, deadExchange());</span><br><span class="line">        <span class="comment">//消息过期后，进入到死信交换机的路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_ROUTING_KEY);</span><br><span class="line">        <span class="comment">//过期时间，单位毫秒</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(NORMAL_QUEUE).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">normalBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Binding(NORMAL_QUEUE, Binding.DestinationType.QUEUE,</span><br><span class="line">                NORMAL_EXCHANGE, NORMAL_ROUTIING_KEY, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDeadMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">         map.put(<span class="string">&quot;messageId&quot;</span>, <span class="number">0</span>);</span><br><span class="line">         map.put(<span class="string">&quot;messageData&quot;</span>, <span class="string">&quot;这是死信消息&quot;</span>);</span><br><span class="line">         rabbitTemplate.convertAndSend(<span class="string">&quot;dead_exchange&quot;</span>, <span class="string">&quot;dead_routing_key&quot;</span>, map);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在consumer创建监听类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;lock_merchant_dead_queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MerchantMQListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageHandler</span><span class="params">(String body, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> msgTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        System.out.println(<span class="string">&quot;msgTag=&quot;</span>+msgTag);</span><br><span class="line">        System.out.println(<span class="string">&quot;body=&quot;</span>+body);</span><br><span class="line">        <span class="comment">//做复杂业务逻辑  TODO</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//告诉broker，消息已经被确认</span></span><br><span class="line">        channel.basicAck(msgTag,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用延迟插件实现延迟队列"><a href="#使用延迟插件实现延迟队列" class="headerlink" title="使用延迟插件实现延迟队列"></a>使用延迟插件实现延迟队列</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><ul><li>去RabbitMQ的官网下载插件，插件地址：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></li><li>直接搜索<code>rabbitmq_delayed_message_exchange</code>即可找到我们需要下载的插件，下载和RabbitMQ配套的版本，不要弄错；</li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211028134236.png" alt="image-20211028134236367" style="zoom:50%;" /><ul><li><p>将插件文件复制到RabbitMQ安装目录的<code>plugins</code>目录下；</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211028134334.png" alt="image-20211028134334406" style="zoom:50%;" /></li><li><p>进入RabbitMQ安装目录的<code>sbin</code>目录下，使用如下命令启用延迟插件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure></li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211028134409.png" alt="image-20211028134409830" style="zoom:50%;" /><ul><li>启用插件成功后重新启动RabbitMQ服务即可。</li></ul><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><p>创建消费者</p><p>监听类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TulingMsgReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费延时消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;delay.queue&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerDelayMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        Order order = objectMapper.readValue(message.getBody(),Order.class);</span><br><span class="line">        log.info(<span class="string">&quot;在&#123;&#125;,签收:&#123;&#125;&quot;</span>,sdf.format(<span class="keyword">new</span> Date()),order);</span><br><span class="line"></span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者配置，签收模式设置为手动，防止二次消费</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8899</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># rabbitmq的连接地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># rabbitmq的连接端口号</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/tj-vhost</span> <span class="comment"># rabbitmq的虚拟host</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span> <span class="comment"># rabbitmq的用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span> <span class="comment"># rabbitmq的密码</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#如果对异步消息需要回调必须设置为true</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启发送失败退回</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">     <span class="attr">simple:</span></span><br><span class="line">      <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p>创建生产者</p><p>生产者配置，用于连接rabbitmq</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8899</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># rabbitmq的连接地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># rabbitmq的连接端口号</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/tj-vhost</span> <span class="comment"># rabbitmq的虚拟host</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span> <span class="comment"># rabbitmq的用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span> <span class="comment"># rabbitmq的密码</span></span><br></pre></td></tr></table></figure><p>rabbitmq配置类，注入操作类，设置回调函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">createRabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">        rabbitTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">//设置开启Mandatory,才能触发回调函数,无论消息推送结果怎么样都强制调用回调函数</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ConfirmCallback:     &quot;</span>+<span class="string">&quot;相关数据：&quot;</span>+correlationData);</span><br><span class="line">            System.out.println(<span class="string">&quot;ConfirmCallback:     &quot;</span>+<span class="string">&quot;确认情况：&quot;</span>+ack);</span><br><span class="line">            System.out.println(<span class="string">&quot;ConfirmCallback:     &quot;</span>+<span class="string">&quot;原因：&quot;</span>+cause);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;消息：&quot;</span>+message);</span><br><span class="line">            System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;回应码：&quot;</span>+replyCode);</span><br><span class="line">            System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;回应信息：&quot;</span>+replyText);</span><br><span class="line">            System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;交换机：&quot;</span>+exchange);</span><br><span class="line">            System.out.println(<span class="string">&quot;ReturnCallback:     &quot;</span>+<span class="string">&quot;路由键：&quot;</span>+routingKey);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(<span class="string">&quot;delay.exchange&quot;</span>, <span class="string">&quot;x-delayed-message&quot;</span>,<span class="keyword">true</span>, <span class="keyword">false</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;delay.queue&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayQueue()).to(delayExchange()).with(<span class="string">&quot;delay.key&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类发送消息，延时五秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSenderDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Order order = <span class="keyword">new</span> Order();</span><br><span class="line">order.setOrderNo(UUID.randomUUID().toString());</span><br><span class="line">order.setUserName(<span class="string">&quot;smlz&quot;</span>);</span><br><span class="line">order.setPayMoney(<span class="number">10000.00</span>);</span><br><span class="line">order.setCreateDt(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建correlationData 用于做可靠性投递得,ID:必须为全局唯一的 根据业务规则</span></span><br><span class="line">CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">String jsonStr = JSONUtil.toJsonStr(order);</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;delay.exchange&quot;</span>, <span class="string">&quot;delay.key&quot;</span>, jsonStr, message -&gt; &#123;</span><br><span class="line">message.getMessageProperties().setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">5000</span>);<span class="comment">//设置延迟时间</span></span><br><span class="line"><span class="keyword">return</span> message;</span><br><span class="line">&#125;, correlationData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果，可以看到五秒后签收消息</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211029133737.png" alt="image-20211029133737579" style="zoom:50%;" /><p>a</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;消息幂等性&quot;&gt;&lt;a href=&quot;#消息幂等性&quot; class=&quot;headerlink&quot; title=&quot;消息幂等性&quot;&gt;&lt;/a&gt;消息幂等性&lt;/h1&gt;&lt;p&gt;对接口发起的一次调用和多次调用，结果都是一致的。&lt;/p&gt;
&lt;p&gt;某些接口具有天然的幂等性: 比如长查询接口，不管是查</summary>
      
    
    
    
    
    <category term="rabbitmq" scheme="https://tj-ever.github.io/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq 环境搭建及基本使用</title>
    <link href="https://tj-ever.github.io/2021/10/22/Rabbitmq%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://tj-ever.github.io/2021/10/22/Rabbitmq%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-10-21T16:00:00.000Z</published>
    <updated>2021-10-28T03:51:22.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MQ全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022122632.png" alt="image-20211022122632062" style="zoom:50%;" /><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a><strong>应用解耦</strong></h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022122706.png" alt="image-20211022122706534" style="zoom:50%;" /><p>系统的耦合性越高，容错性就越低，可维护性就越低。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022122737.png" alt="image-20211022122737085" style="zoom:50%;" /><p>使用 MQ 使得应用间解耦，提升容错性和可维护性。</p><h3 id="异步提速"><a href="#异步提速" class="headerlink" title="异步提速"></a><strong>异步提速</strong></h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022122810.png" alt="image-20211022122810063" style="zoom:50%;" /><p>一个下单操作耗时：20 + 300 + 300 + 300 = 920ms</p><p>用户点击完下单按钮后，需要等待920ms才能得到下单响应，太慢</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022122842.png" alt="image-20211022122842541" style="zoom:50%;" /><p>用户点击完下单按钮后，只需等待25ms就能得到下单响应 (20 + 5 = 25ms)。</p><p>提升用户体验和系统吞吐量（单位时间内处理请求的数目）。</p><h3 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a><strong>削峰填谷</strong></h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022122913.png" alt="image-20211022122913450" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022122929.png" alt="image-20211022122929482" style="zoom:50%;" /><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022122947.png" alt="image-20211022122947663"></p><p>使用了 MQ 之后，限制消费消息的速度为1000，这样一来，高峰期产生的数据势必会被积压在 MQ 中，高峰就被“削”掉了，但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000，直到消费完积压的消息，这就叫做“填谷”。</p><p>使用MQ后，可以提高系统稳定性。</p><h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022123104.png" alt="image-20211022123104631" style="zoom:50%;" /><h3 id="系统可用性降低"><a href="#系统可用性降低" class="headerlink" title="系统可用性降低"></a><strong>系统可用性降低</strong></h3><p>系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？</p><h3 id="系统复杂度提高"><a href="#系统复杂度提高" class="headerlink" title="系统复杂度提高"></a><strong>系统复杂度提高</strong></h3><p>MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息不被丢失等情况？</p><h2 id="常见的MQ产品"><a href="#常见的MQ产品" class="headerlink" title="常见的MQ产品"></a>常见的MQ产品</h2><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022123149.png" alt="image-20211022123149453"></p><h1 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a><strong>RabbitMQ</strong>简介</h1><p>AMQP，即 Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022123247.png" alt="image-20211022123247076" style="zoom:50%;" /><p>2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p><p>RabbitMQ 基础架构如下图：</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022123317.png" alt="image-20211022123317463"></p><p>RabbitMQ 中的相关概念：</p><ul><li><p>Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker</p></li><li><p>Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p></li><li><p>Connection：publisher／consumer 和 broker 之间的 TCP 连接</p></li><li><p>Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</p></li><li><p>Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p></li><li><p>Queue：消息最终被送到这里等待 consumer 取走</p></li><li><p>Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p></li></ul><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><ul><li>更新软件包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure><ul><li>安装依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc glibc-devel make ncurses-devel openssl-devel xmlto perl wget gtk2-devel binutils-devel</span><br></pre></td></tr></table></figure><ul><li>安装Erlang</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;erlang.org&#x2F;download&#x2F;otp_src_22.0.tar.gz</span><br><span class="line">tar -zxvf otp_src_22.0.tar.gz</span><br><span class="line">mv otp_src_22.0 &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;otp_src_22.0&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建即将安装的目录</span><br><span class="line">mkdir ..&#x2F;erlang</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置安装路径</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;erlang</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;安装</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看一下是否安装成功</span><br><span class="line">ll &#x2F;usr&#x2F;local&#x2F;erlang&#x2F;bin</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加环境变量</span><br><span class="line">echo &#39;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;erlang&#x2F;bin&#39; &gt;&gt; &#x2F;etc&#x2F;profile</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试</span><br><span class="line">erl</span><br><span class="line">&#x2F;&#x2F;退出</span><br><span class="line">halt().</span><br></pre></td></tr></table></figure><ul><li>安装RabbitMQ</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;releases&#x2F;download&#x2F;v3.7.15&#x2F;rabbitmq-server-generic-unix-3.7.15.tar.xz</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;安装解压工具</span><br><span class="line">yum install -y xz</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解压</span><br><span class="line">&#x2F;bin&#x2F;xz -d rabbitmq-server-generic-unix-3.7.15.tar.xz</span><br><span class="line">tar -xvf rabbitmq-server-generic-unix-3.7.15.tar</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建目录</span><br><span class="line">mv rabbitmq_server-3.7.15&#x2F; &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;rabbitmq_server-3.7.15  rabbitmq</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置环境变量</span><br><span class="line">echo &#39;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;rabbitmq&#x2F;sbin&#39; &gt;&gt; &#x2F;etc&#x2F;profile</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建配置目录</span><br><span class="line">mkdir &#x2F;etc&#x2F;rabbitmq</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动</span><br><span class="line">rabbitmq-server -detached</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;停止</span><br><span class="line">rabbitmqctl stop</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;状态</span><br><span class="line">rabbitmqctl status</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>延时插件安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;rabbitmq-delayed-message-exchange&#x2F;releases&#x2F;download&#x2F;v3.8.0&#x2F;rabbitmq_delayed_message_exchange-3.8.0.ez</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;拷贝至插件目录</span><br><span class="line">cp rabbitmq_delayed_message_exchange-3.8.0.ez &#x2F;usr&#x2F;local&#x2F;rabbitmq&#x2F;plugins</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动延时插件</span><br><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20201009123210.png" alt="image-20201009123131060"></p><ul><li>访问web控制台</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><ul><li>修改配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;rabbitmq&#x2F;ebin&#x2F;rabbit.app</span><br></pre></td></tr></table></figure><p>将<code>         &#123;loopback_users, [&lt;&lt;&quot;guest&quot;&gt;&gt;]&#125;</code>修改为<code>         &#123;loopback_users, [guest]&#125;</code>，否则只能使用localhost访问</p><ul><li>创建用户</li></ul><p>为RabbitMQ Web管理控制台创建管理用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin StrongPassword</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line">rabbitmqctl set_permissions -p &#x2F; admin “.*” “.*” “.*”</span><br></pre></td></tr></table></figure><ul><li>使用guest登陆</li></ul><p>访问<code>IP:15672</code>，用户名/密码 guest</p><ul><li>界面说明</li></ul><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20201008151054.png" alt="image-20201008032906408"></p><blockquote><p>connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况</p><p>channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。</p><p>Exchanges：交换机，用来实现消息的路由</p><p>Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。</p></blockquote><ul><li>端口</li></ul><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20201008151113.png" alt="image-20201008033020947"></p><ul><li>添加用户</li></ul><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20201008151134.png" alt="image-20201008034147662"></p><blockquote><p>上面的Tags选项是指定用户的角色，可选的有以下几个：</p><ul><li>超级管理员(administrator)</li></ul><p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p><ul><li>监控者(monitoring)</li></ul><p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p><ul><li>策略制定者(policymaker)</li></ul><p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p><ul><li>普通管理者(management)</li></ul><p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p><ul><li>其他</li></ul><p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p></blockquote><ul><li>创建虚拟主机</li></ul><blockquote><p>为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。</p></blockquote><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20201008151150.png" alt="image-20201008034432876"></p><ul><li>设置虚拟主机用户和权限</li></ul><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20201008151204.png" alt="image-20201008034538538"></p><h1 id="示例demo（未整合Spring，用channel操作）"><a href="#示例demo（未整合Spring，用channel操作）" class="headerlink" title="示例demo（未整合Spring，用channel操作）"></a>示例demo（未整合Spring，用channel操作）</h1><p>RabbitMQ 提供了 6 种工作模式：简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing 路由模式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ；）。</p><p>官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022122510.png" alt="image-20211022122510352"></p><h2 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h2><p>普通的maven工程，此处略过</p><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建连接工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/tj-vhost&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = connectionFactory.newConnection();</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建常量类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConstant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_HELLOWORLD = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_SMS = <span class="string">&quot;sms&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_WEATHER = <span class="string">&quot;weather&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_WEATHER_ROUTING = <span class="string">&quot;weather-routing&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_BAIDU = <span class="string">&quot;baidu&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_SINA = <span class="string">&quot;sina&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_WEATHER_TOPIC = <span class="string">&quot;weather-topic&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成后需要在页面手动新建vhost</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022133736.png" alt="image-20211022133736478" style="zoom:50%;" /><h2 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022153319.png" alt="image-20211022153319664" style="zoom:50%;" /><p>在上图的模型中，有以下概念：</p><p>lP：生产者，也就是要发送消息的程序</p><p>lC：消费者：消息的接收者，会一直等待消息到来</p><p>lqueue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息</p><p>创建消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取TCP长连接</span></span><br><span class="line">        Connection conn = RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">        <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">        <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">        <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">        <span class="comment">//其他额外的参数, null</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_HELLOWORLD, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从MQ服务器中获取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个消息消费者</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名</span></span><br><span class="line">        <span class="comment">//第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法</span></span><br><span class="line">        <span class="comment">//第三个参数要传入DefaultConsumer的实现类</span></span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_HELLOWORLD, <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">                String message = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者接收到的消息：&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;消息的TagId：&quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">                <span class="comment">//false只确认签收当前的消息，设置为true的时候则代表签收该消费者所有未签收的消息</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取TCP长连接</span></span><br><span class="line">        Connection conn = RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">        <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">        <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">        <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">        <span class="comment">//其他额外的参数, null</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_HELLOWORLD,<span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        String message = <span class="string">&quot;测试推送消息&quot;</span>;</span><br><span class="line">        <span class="comment">//四个参数</span></span><br><span class="line">        <span class="comment">//exchange 交换机，暂时用不到，在后面进行发布订阅时才会用到</span></span><br><span class="line">        <span class="comment">//队列名称</span></span><br><span class="line">        <span class="comment">//额外的设置属性</span></span><br><span class="line">        <span class="comment">//最后一个参数是要传递的消息字节数组</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, RabbitConstant.QUEUE_HELLOWORLD, <span class="keyword">null</span>,message.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">        conn.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;===发送成功===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作队列模式"><a href="#工作队列模式" class="headerlink" title="工作队列模式"></a>工作队列模式</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022153350.png" alt="image-20211022153350933" style="zoom:50%;" /><p><strong>Work Queues：</strong>与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。</p><p><strong>应用场景</strong>：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022153536.png" alt="image-20211022153536341" style="zoom:50%;" /><p>创建订单类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSystem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SMS, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            String sms = <span class="string">&quot;乘客&quot;</span> + i + <span class="string">&quot;, 您的车票已预订成功&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, RabbitConstant.QUEUE_SMS, <span class="keyword">null</span>, sms.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送数据成功&quot;</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建三个消费者，不同地方只修改sout输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSSender1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SMS, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_SMS , <span class="keyword">false</span> , <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String jsonSMS = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;SMSSender1-短信发送成功:&quot;</span> + jsonSMS);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag() , <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会发现，消息被平均分发到三个消费队列中</p><img src="/Users/tianjie/Library/Application Support/typora-user-images/image-20211022131638942.png" alt="image-20211022131638942" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022131657.png" alt="image-20211022131657706" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022131718.png" alt="image-20211022131718124" style="zoom:50%;" /><p>再来看一下加上channel.basicQos(1);的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSSender1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SMS, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不写basicQos（1），则自动MQ会将所有请求平均发送给所有消费者</span></span><br><span class="line">        <span class="comment">//basicQos,MQ不再对消费者一次发送多个请求，而是消费者处理完一个消息后（确认后），在从队列中获取一个新的</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);<span class="comment">//处理完一个取一个</span></span><br><span class="line"></span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_SMS, <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String jsonSMS = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;SMSSender1-短信发送成功:&quot;</span> + jsonSMS);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处模拟服务器性能好坏，将服务器1休眠10毫秒，服务器2休眠100毫秒，服务器3休眠500毫秒</p><p>可以看到，由于服务器1处理任务耗时最短，所以消费的消息是最多的，同理，服务器3只消费了3条消息</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022132423.png" alt="image-20211022132423458" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022132444.png" alt="image-20211022132444365" style="zoom:50%;" /><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022153620.png" alt="image-20211022153620370" style="zoom:50%;" /><p>在订阅模型中，多了一个 Exchange 角色，而且过程略有变化：</p><ul><li><p>P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</p></li><li><p>C：消费者，消息的接收者，会一直等待消息到来</p></li><li><p>Queue：消息队列，接收消息、缓存消息</p></li><li><p>Exchange：交换机（X）。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：</p><ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li></ul><p><strong>Exchange</strong>（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022153748.png" alt="image-20211022153748860" style="zoom:50%;" /><p>新建一个交换机，选择发布订阅模式</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022134556.png" alt="image-20211022134556257" style="zoom:50%;" /><p>创建天气发布类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">// 等待输入文字，按回车键结束</span></span><br><span class="line">        String input = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//第一个参数交换机名字   其他参数和之前的一样</span></span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER,<span class="string">&quot;&quot;</span> , <span class="keyword">null</span> , input.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建百度订阅类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Baidu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取TCP长连接</span></span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取虚拟连接</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列信息</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_BAIDU, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//queueBind用于将队列与交换机绑定</span></span><br><span class="line">        <span class="comment">//参数1：队列名 参数2：交互机名  参数三：路由key（暂时用不到)</span></span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_BAIDU, RabbitConstant.EXCHANGE_WEATHER, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_BAIDU , <span class="keyword">false</span> , <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;百度天气收到气象信息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag() , <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新浪订阅类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sina</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取TCP长连接</span></span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取虚拟连接</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列信息</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SINA, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//queueBind用于将队列与交换机绑定</span></span><br><span class="line">        <span class="comment">//参数1：队列名 参数2：交互机名  参数三：路由key（暂时用不到)</span></span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_SINA, RabbitConstant.EXCHANGE_WEATHER, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_SINA , <span class="keyword">false</span> , <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新浪天气收到气象信息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag() , <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发布类的控制台输入消息，按回车键发送，可在其他两个订阅类收到消息</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022152542.png" alt="image-20211022152542498" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022152702.png" alt="image-20211022152702054" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211022152714.png" alt="image-20211022152714475" style="zoom:50%;" /><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><p>模式说明：</p><ul><li><p>队列与交换机的绑定，不能是任意绑定了，而是要指定一个 RoutingKey（路由key）</p></li><li><p>消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey</p></li><li><p>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的Routingkey 与消息的 Routing key 完全一致，才会接收到消息</p></li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024133333.png" alt="image-20211024133332974" style="zoom:50%;" /><p>图解：</p><ul><li><p>P：生产者，向 Exchange 发送消息，发送消息时，会指定一个routing key</p></li><li><p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给与 routing key 完全匹配的队列</p></li><li><p>C1：消费者，其所在队列指定了需要 routing key 为 error 的消息</p></li><li><p>C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息</p></li></ul><p>新建一个交换机，选择路由模式</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024115013.png" alt="image-20211024115013815" style="zoom:50%;" /><p>创建天气发布类，对同一个交换机绑定了四个路由，测试新浪和百度是否根据对应的路由收消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;百度--路由key&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;百度消息-天气不错&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;百度--路由key-1&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;百度消息-空气不错-1&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;新浪--路由key&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;新浪消息-天气不错&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;新浪--路由key-1&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;新浪消息-空气不错-1&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建百度类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Baidu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_BAIDU, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//queueBind用于将队列与交换机绑定</span></span><br><span class="line">        <span class="comment">//参数1：队列名 参数2：交互机名  参数三：路由key</span></span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_BAIDU, RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;百度--路由key&quot;</span>);</span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_BAIDU, RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;百度--路由key-1&quot;</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_BAIDU, <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;百度收到信息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新浪类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sina</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取TCP长连接</span></span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取虚拟连接</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列信息</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SINA, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定队列与交换机以及routing key之间的关系</span></span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_SINA, RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;新浪--路由key&quot;</span>);</span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_SINA, RabbitConstant.EXCHANGE_WEATHER_ROUTING, <span class="string">&quot;新浪--路由key-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_SINA, <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新浪收到信息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果，百度和新浪收到了各自对应的路由消息</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024120008.png" alt="image-20211024120008407" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024120021.png" alt="image-20211024120021327" style="zoom:50%;" /><h2 id="通配符模式"><a href="#通配符模式" class="headerlink" title="通配符模式"></a>通配符模式</h2><p>模式说明：</p><ul><li><p>Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型Exchange 可以让队列在绑定 Routing key 的时候使用<strong>通配符</strong></p></li><li><p>Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert</p></li><li><p>通配符规则：# 匹配一个或多个词，* 匹配不多不少恰好1个词，例如：item.# 能够匹配 item.insert.abc 或者 item.insert，item.* 只能匹配 item.insert</p></li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024133830.png" alt="image-20211024133830416" style="zoom:50%;" /><p>图解：</p><ul><li><p>红色 Queue：绑定的是 usa.# ，因此凡是以 usa. 开头的 routing key 都会被匹配到</p></li><li><p>黄色 Queue：绑定的是 #.news ，因此凡是以 .news 结尾的 routing key 都会被匹配</p></li></ul><p>新建一个交换机，类型选择通配符模式</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024122904.png" alt="image-20211024122904866" style="zoom:50%;" /><p>创建天气发布类，此处修改了交换机和路由格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;百度.路由key&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;百度消息-天气不错&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;百度.路由key.1&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;百度消息-空气不错-1&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;新浪.路由key&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;新浪消息-天气不错&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;新浪.路由key.1&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;新浪消息-空气不错-1&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建百度类，此处将路由修改为“百度.#”，#可以匹配多个词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Baidu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_BAIDU, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//queueBind用于将队列与交换机绑定</span></span><br><span class="line">        <span class="comment">//参数1：队列名 参数2：交互机名  参数三：路由key</span></span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_BAIDU, RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;百度.#&quot;</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_BAIDU, <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;百度收到信息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建百度类，此处将路由修改为“新浪.*”，✳️只能匹配一个词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sina</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取TCP长连接</span></span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取虚拟连接</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列信息</span></span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SINA, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定队列与交换机以及routing key之间的关系</span></span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_SINA, RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;新浪.*&quot;</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_SINA, <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新浪收到信息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果，百度类接收到了两个消息，因为使用的是#通配符，可以匹配多个路由。新浪类只收到了一个消息，因为使用的是*通配符，只能匹配一个</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024130907.png" alt="image-20211024130907804" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024130921.png" alt="image-20211024130921777" style="zoom:50%;" /><h2 id="工作模式总结"><a href="#工作模式总结" class="headerlink" title="工作模式总结"></a>工作模式总结</h2><ul><li><p>简单模式 HelloWorld</p><p> 一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）。</p></li><li><p>工作队列模式 Work Queue</p><p>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）。</p></li><li><p>发布订阅模式 Publish/subscribe</p><p>需要设置类型为 fanout 的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。</p></li><li><p>路由模式 Routing</p><p>需要设置类型为 direct 的交换机，交换机和队列进行绑定，并且指定 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。</p></li><li><p>通配符模式 Topic</p><p>需要设置类型为 topic 的交换机，交换机和队列进行绑定，并且指定通配符方式的 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。</p></li></ul><h2 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024145614.png" alt="image-20211024145613956" style="zoom: 33%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024145719.png" alt="image-20211024145719597" style="zoom:33%;" /><p>创建天气发布类，<strong>注意publish第三个参数需要指定为true，否则消息收不到将被直接删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//开启confirm监听模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//第二个参数代表接收的数据是否为批量接收，一般我们用不到。</span></span><br><span class="line">                System.out.println(<span class="string">&quot;消息已被Broker接收,Tag:&quot;</span> + l);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息已被Broker拒收,Tag:&quot;</span> + l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> ReturnCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Return r)</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">                System.err.println(<span class="string">&quot;Return编码：&quot;</span> + r.getReplyCode() + <span class="string">&quot;-Return描述:&quot;</span> + r.getReplyText());</span><br><span class="line">                System.err.println(<span class="string">&quot;交换机:&quot;</span> + r.getExchange() + <span class="string">&quot;-路由key:&quot;</span> + r.getRoutingKey());</span><br><span class="line">                System.err.println(<span class="string">&quot;Return主题：&quot;</span> + <span class="keyword">new</span> String(r.getBody()));</span><br><span class="line">                System.err.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Routing key 第二个参数相当于数据筛选的条件</span></span><br><span class="line">        <span class="comment">//第三个参数为：mandatory true代表如果消息无法正常投递则return回生产者，如果false，则直接将消息放弃。</span></span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;百度.路由key&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="string">&quot;百度消息-天气不错&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;百度.路由key.1&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="string">&quot;百度消息-空气不错-1&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;新浪.路由key&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="string">&quot;新浪消息-天气不错&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;新浪.路由key.1&quot;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="string">&quot;新浪消息-空气不错-1&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果关闭则无法进行监听，因此此处不需要关闭</span></span><br><span class="line">        <span class="comment">/*channel.close();</span></span><br><span class="line"><span class="comment">        connection.close();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建百度订阅类，不使用通配符只指定一个路由</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Baidu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_BAIDU, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//queueBind用于将队列与交换机绑定</span></span><br><span class="line">        <span class="comment">//参数1：队列名 参数2：交互机名  参数三：路由key</span></span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_BAIDU, RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;百度.路由key&quot;</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_BAIDU , <span class="keyword">false</span> , <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;百度收到信息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag() , <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新浪订阅类，不使用通配符只指定一个路由</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sina</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = RabbitUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(RabbitConstant.QUEUE_SINA, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(RabbitConstant.QUEUE_SINA, RabbitConstant.EXCHANGE_WEATHER_TOPIC, <span class="string">&quot;新浪.路由key&quot;</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        channel.basicConsume(RabbitConstant.QUEUE_SINA, <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新浪收到信息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在天气发布类中共发布了四个消息，其中百度类和新浪类各接收到一个，还剩两个由于没有路由导致消息不可达，会被addReturnListener监听到</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024220926.png" alt="image-20211024220926015" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024220938.png" alt="image-20211024220938273" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211024220947.png" alt="image-20211024220946974" style="zoom:50%;" /><h1 id="Spring整合rabbitmq（用rabbitTemplate操作）"><a href="#Spring整合rabbitmq（用rabbitTemplate操作）" class="headerlink" title="Spring整合rabbitmq（用rabbitTemplate操作）"></a>Spring整合rabbitmq（用rabbitTemplate操作）</h1><p>创建配置类，需要创建连接工厂，启动类，交换机，队列，绑定以及简单的消费监听（需要传入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建连接工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory cachingConnectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">        cachingConnectionFactory.setAddresses(<span class="string">&quot;192.168.159.8:5672&quot;</span>);</span><br><span class="line">        cachingConnectionFactory.setVirtualHost(<span class="string">&quot;tuling&quot;</span>);</span><br><span class="line">        cachingConnectionFactory.setUsername(<span class="string">&quot;smlz&quot;</span>);</span><br><span class="line">        cachingConnectionFactory.setPassword(<span class="string">&quot;smlz&quot;</span>);</span><br><span class="line">        cachingConnectionFactory.setConnectionTimeout(<span class="number">10000</span>);</span><br><span class="line">        cachingConnectionFactory.setCloseTimeout(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> cachingConnectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitAdmin <span class="title">rabbitAdmin</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RabbitAdmin rabbitAdmin = <span class="keyword">new</span> RabbitAdmin(connectionFactory);</span><br><span class="line">        <span class="comment">//spring容器启动加载该类</span></span><br><span class="line">        rabbitAdmin.setAutoStartup(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> rabbitAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=====================================申明三个交换机====================================================================</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TopicExchange topicExchange = <span class="keyword">new</span> TopicExchange(<span class="string">&quot;tuling.topic.exchange&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> topicExchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DirectExchange directExchange = <span class="keyword">new</span> DirectExchange(<span class="string">&quot;tuling.direct.exchange&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> directExchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FanoutExchange fanoutExchange = <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;tuling.faout.exchange&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> fanoutExchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================================申明队列===========================================================</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">testTopicQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;testTopicQueue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">testTopicQueue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;testTopicQueue2&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">testDirectQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;testDirectQueue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">testFaoutQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;testfaoutQueue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;orderQueue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//========================================申明绑定==============================================================</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBingding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(testTopicQueue()).to(topicExchange()).with(<span class="string">&quot;topic.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBingding2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(testTopicQueue2()).to(topicExchange()).with(<span class="string">&quot;topic.key.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(testDirectQueue()).to(directExchange()).with(<span class="string">&quot;direct.key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">orderQueueBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(orderQueue()).to(directExchange()).with(<span class="string">&quot;rabbitmq.order&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(testFaoutQueue()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//========================================申明操作模板==============================================================</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">        rabbitTemplate.setReceiveTimeout(<span class="number">50000</span>);</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单的消息监听容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">simpleMessageListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer simpleMessageListenerContainer = <span class="keyword">new</span> SimpleMessageListenerContainer(connectionFactory());</span><br><span class="line">        <span class="comment">//监听我们的队列</span></span><br><span class="line">        simpleMessageListenerContainer.setQueues(testTopicQueue(), testDirectQueue(), testTopicQueue2(), orderQueue());</span><br><span class="line">        <span class="comment">//消费者的数量</span></span><br><span class="line">        simpleMessageListenerContainer.setConcurrentConsumers(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//最大消费者数量</span></span><br><span class="line">        simpleMessageListenerContainer.setMaxConcurrentConsumers(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//签收模式</span></span><br><span class="line">        simpleMessageListenerContainer.setAcknowledgeMode(AcknowledgeMode.AUTO);</span><br><span class="line">        <span class="comment">//设置拒绝重回队列</span></span><br><span class="line">        simpleMessageListenerContainer.setDefaultRequeueRejected(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置使用默认的监听方法（默认监听的方法名是 &#x27;handleMessage&#x27;）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        MessageListenerAdapter messageListenerAdapter = new MessageListenerAdapter(new TulingMsgDelegate());</span></span><br><span class="line"><span class="comment">//        simpleMessageListenerContainer.setMessageListener(messageListenerAdapter);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指定消费方法（需要指定方法名）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        MessageListenerAdapter messageListenerAdapter = new MessageListenerAdapter(new TulingMsgDelegate());</span></span><br><span class="line"><span class="comment">//        messageListenerAdapter.setDefaultListenerMethod(&quot;consumerMsg&quot;);</span></span><br><span class="line"><span class="comment">//        simpleMessageListenerContainer.setMessageListener(messageListenerAdapter);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不同的队列使用不同的消费方法（同样还是amqp提供的方法，通过指定队列名称和方法名称）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        MessageListenerAdapter messageListenerAdapter = new MessageListenerAdapter(new TulingMsgDelegate());</span></span><br><span class="line"><span class="comment">//        Map&lt;String, String&gt; queueMaps = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        queueMaps.put(&quot;testTopicQueue&quot;, &quot;consumerTopicQueue&quot;);</span></span><br><span class="line"><span class="comment">//        queueMaps.put(&quot;testTopicQueue2&quot;, &quot;consumerTopicQueue2&quot;);</span></span><br><span class="line"><span class="comment">//        messageListenerAdapter.setQueueOrTagToMethodName(queueMaps);</span></span><br><span class="line"><span class="comment">//        simpleMessageListenerContainer.setMessageListener(messageListenerAdapter);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理Json的（使用ampq提供的转换器）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        MessageListenerAdapter messageListenerAdapter = new MessageListenerAdapter(new TulingMsgDelegate());</span></span><br><span class="line"><span class="comment">//        messageListenerAdapter.setDefaultListenerMethod(&quot;consumerJsonMessage&quot;);</span></span><br><span class="line"><span class="comment">//        // ampq包下的转换器</span></span><br><span class="line"><span class="comment">//        Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();</span></span><br><span class="line"><span class="comment">//        messageListenerAdapter.setMessageConverter(jackson2JsonMessageConverter);</span></span><br><span class="line"><span class="comment">//        simpleMessageListenerContainer.setMessageListener(messageListenerAdapter);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理java对象（使用ampq提供的转换器）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MessageListenerAdapter messageListenerAdapter = <span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> TulingMsgDelegate());</span><br><span class="line">        messageListenerAdapter.setDefaultListenerMethod(<span class="string">&quot;consumerJavaObjMessage&quot;</span>);</span><br><span class="line">        Jackson2JsonMessageConverter jackson2JsonMessageConverter = <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">        DefaultJackson2JavaTypeMapper javaTypeMapper = <span class="keyword">new</span> DefaultJackson2JavaTypeMapper();</span><br><span class="line">        javaTypeMapper.setTrustedPackages(<span class="string">&quot;com.tuling.entity&quot;</span>);</span><br><span class="line">        <span class="comment">//设置java转json的</span></span><br><span class="line">        jackson2JsonMessageConverter.setJavaTypeMapper(javaTypeMapper);</span><br><span class="line">        messageListenerAdapter.setMessageConverter(jackson2JsonMessageConverter);</span><br><span class="line">        simpleMessageListenerContainer.setMessageListener(messageListenerAdapter);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> simpleMessageListenerContainer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建消费代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TulingMsgDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(String msgBody)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TulingMsgDelegate。。。。。。handleMessage&quot;</span> + msgBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TulingMsgDelegate。。。。。。consumerMsg&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerTopicQueue</span><span class="params">(String msgBody)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TulingMsgDelegate。。。。。。consumerTopicQueue&quot;</span> + msgBody);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerTopicQueue2</span><span class="params">(String msgBody)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TulingMsgDelegate。。。。。。consumerTopicQueue2&quot;</span> + msgBody);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理json</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerJsonMessage</span><span class="params">(Map jsonMap)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TulingMsgDelegate ============================处理json&quot;</span> + jsonMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理order得</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerJavaObjMessage</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TulingMsgDelegate ============================处理java对象&quot;</span> + order.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tuling;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.tuling.entity.*;</span><br><span class="line"><span class="keyword">import</span> com.tuling.entity.Address;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TulingvipRabbitmqSpringwithrabbitmqApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="comment">//该类封装了对 RabbitMQ 的管理操作</span></span><br><span class="line"><span class="keyword">private</span> RabbitAdmin rabbitAdmin;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//声明一个交换机</span></span><br><span class="line">TopicExchange topicExchange = <span class="keyword">new</span> TopicExchange(<span class="string">&quot;rabbitadmin.topic.exchange&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">rabbitAdmin.declareExchange(topicExchange);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明一个队列</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;rabbitadmin.topic.queue&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">rabbitAdmin.declareQueue(queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//申明一个绑定</span></span><br><span class="line">Binding binding = <span class="keyword">new</span> Binding(<span class="string">&quot;rabbitadmin.topic.queue&quot;</span>,Binding.DestinationType.QUEUE,</span><br><span class="line"><span class="string">&quot;rabbitadmin.topic.exchange&quot;</span>,<span class="string">&quot;rabbitadmin.#&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">rabbitAdmin.declareBinding(binding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DirectExchange directExchange = <span class="keyword">new</span> DirectExchange(<span class="string">&quot;rabbitadmin.direct.exchange&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">rabbitAdmin.declareExchange(directExchange);</span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;rabbitadmin.direct.queue&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">rabbitAdmin.declareQueue(queue);</span><br><span class="line">rabbitAdmin.declareBinding(BindingBuilder.bind(queue).to(directExchange).with(<span class="string">&quot;rabbitadmin.key.#&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="comment">//Spring AMQP 提供了 RabbitTemplate 来简化 RabbitMQ 发送和接收消息操作</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRabbitmqTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">&quot;company&quot;</span>,<span class="string">&quot;tuling&quot;</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;smlz&quot;</span>);</span><br><span class="line"></span><br><span class="line">String msgBody = <span class="string">&quot;hello tuling&quot;</span>;</span><br><span class="line">Message message = <span class="keyword">new</span> Message(msgBody.getBytes(),messageProperties);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要message对象发送</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;tuling.direct.exchange&quot;</span>,<span class="string">&quot;direct.key&quot;</span>,<span class="string">&quot;smlz&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleMessageListenerContainerTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;tuling.topic.exchange&quot;</span>,<span class="string">&quot;topic.xixi&quot;</span>,<span class="string">&quot;你好 图灵&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageListenerAdaperQueueOrTagToMethodName</span><span class="params">()</span></span>&#123;</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;tuling.topic.exchange&quot;</span>,<span class="string">&quot;topic.xixi&quot;</span>,<span class="string">&quot;你好 图灵&quot;</span>);</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;tuling.topic.exchange&quot;</span>,<span class="string">&quot;topic.key.xixi&quot;</span>,<span class="string">&quot;你好 smlz&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendJson</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">Order order = <span class="keyword">new</span> Order();</span><br><span class="line">order.setOrderNo(UUID.randomUUID().toString());</span><br><span class="line">order.setCreateDt(<span class="keyword">new</span> Date());</span><br><span class="line">order.setPayMoney(<span class="number">10000.00</span>);</span><br><span class="line">order.setUserName(<span class="string">&quot;smlz&quot;</span>);</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String orderJson = objectMapper.writeValueAsString(order);</span><br><span class="line"></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">Message orderMsg = <span class="keyword">new</span> Message(orderJson.getBytes(),messageProperties);</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;tuling.direct.exchange&quot;</span>,<span class="string">&quot;rabbitmq.order&quot;</span>,orderMsg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendJavaObj</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">Order order = <span class="keyword">new</span> Order();</span><br><span class="line">order.setOrderNo(UUID.randomUUID().toString());</span><br><span class="line">order.setCreateDt(<span class="keyword">new</span> Date());</span><br><span class="line">order.setPayMoney(<span class="number">10000.00</span>);</span><br><span class="line">order.setUserName(<span class="string">&quot;smlz&quot;</span>);</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String orderJson = objectMapper.writeValueAsString(order);</span><br><span class="line"></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">messageProperties.getHeaders().put(<span class="string">&quot;__TypeId__&quot;</span>,<span class="string">&quot;com.tuling.entity.Order&quot;</span>);</span><br><span class="line">Message orderMsg = <span class="keyword">new</span> Message(orderJson.getBytes(),messageProperties);</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;tuling.direct.exchange&quot;</span>,<span class="string">&quot;rabbitmq.order&quot;</span>,orderMsg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h1><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><ul><li>添加pom依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>添加配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host&#x3D;192.168.8.233</span><br><span class="line">spring.rabbitmq.port&#x3D;5672</span><br><span class="line">spring.rabbitmq.virtual-host&#x3D;virtualHost</span><br><span class="line">spring.rabbitmq.username&#x3D;admin</span><br><span class="line">spring.rabbitmq.password&#x3D;admin</span><br><span class="line"></span><br><span class="line">#开启消息确认模式</span><br><span class="line">spring.rabbitmq.publisher-confirms&#x3D;true</span><br><span class="line">#开启消息可达监听</span><br><span class="line">spring.rabbitmq.publisher-returns&#x3D;true</span><br><span class="line">#开启不可达消息删除</span><br><span class="line">spring.rabbitmq.template.mandatory&#x3D;true</span><br><span class="line">#设置连接超时</span><br><span class="line">spring.rabbitmq.connection-timeout&#x3D;10000  </span><br></pre></td></tr></table></figure><h2 id="producer生产者"><a href="#producer生产者" class="headerlink" title="producer生产者"></a>producer生产者</h2><ul><li>配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//direct交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">testBootDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DirectExchange directExchange = <span class="keyword">new</span> DirectExchange(<span class="string">&quot;springboot.direct.exchange&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> directExchange;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//延迟交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(<span class="string">&quot;delayExchange&quot;</span>, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">testBootQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;testBootQueue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试延迟队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">testBootDelayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;testBootDelayQueue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//绑定路由（此处可换成topic交换机）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">testBootBinder1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(testBootQueue()).to(testBootDirectExchange()).with(<span class="string">&quot;springboot.key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//绑定路由（此处可换成topic交换机）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">testBootBinder2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(testBootQueue()).to(testBootDirectExchange()).with(<span class="string">&quot;springboot.key2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//绑定路由（此处可换成topic交换机）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">testBootBinder3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(testBootQueue()).to(testBootDirectExchange()).with(<span class="string">&quot;springboot.key3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//绑定路由（此处可换成topic交换机）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">testBootBinder4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(testBootQueue()).to(testBootDirectExchange()).with(<span class="string">&quot;springboot.key4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//绑定延迟路由</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(testBootDelayQueue()).to(delayExchange()).with(<span class="string">&quot;springboot.delay.key&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息发送组件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMsgSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//map参数</span></span><br><span class="line">        Map&lt;String, Object&gt; msgProp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        msgProp.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        msgProp.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        <span class="comment">//实体对象</span></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderNo(UUID.randomUUID().toString());</span><br><span class="line">        order.setUserName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        order.setPayMoney(<span class="number">10000.00</span>);</span><br><span class="line">        order.setCreateDt(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        MessageHeaders messageHeaders = <span class="keyword">new</span> MessageHeaders(msgProp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建消息对象</span></span><br><span class="line">        Message message = MessageBuilder.createMessage(msgProp, messageHeaders);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建correlationData 用于做可靠性投递得,ID:必须为全局唯一的 根据业务规则</span></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        <span class="comment">//开启确认模式</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> TestConfirmCallBack());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启消息可达监听</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">new</span> TestRetrunCallBack());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试发送构建message对象</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;springboot.direct.exchange&quot;</span>, <span class="string">&quot;springboot.key1&quot;</span>, message, <span class="keyword">new</span> CorrelationData(<span class="string">&quot;key1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试消息 不可达监控</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;springboot.direct.exchange&quot;</span>, <span class="string">&quot;error.key&quot;</span>, message, <span class="keyword">new</span> CorrelationData(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试发送实体对象</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;springboot.direct.exchange&quot;</span>, <span class="string">&quot;springboot.key2&quot;</span>, order, <span class="keyword">new</span> CorrelationData(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试发送core下的message对象</span></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String orderJson = objectMapper.writeValueAsString(order);</span><br><span class="line">        org.springframework.amqp.core.MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">        org.springframework.amqp.core.Message ampqMessage = <span class="keyword">new</span> org.springframework.amqp.core.Message(orderJson.getBytes(), messageProperties);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;springboot.direct.exchange&quot;</span>, <span class="string">&quot;springboot.key3&quot;</span>, ampqMessage, <span class="keyword">new</span> CorrelationData(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试发送Messaging包下的message对象</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        MessageHeaders messageHeaders1 = <span class="keyword">new</span> MessageHeaders(map);</span><br><span class="line">        String orderJson1 = objectMapper.writeValueAsString(order);</span><br><span class="line">        Message message1 = MessageBuilder.createMessage(orderJson1, messageHeaders1);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;springboot.direct.exchange&quot;</span>, <span class="string">&quot;springboot.key4&quot;</span>, message1, <span class="keyword">new</span> CorrelationData(<span class="string">&quot;key4&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//实体对象</span></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderNo(UUID.randomUUID().toString());</span><br><span class="line">        order.setUserName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        order.setPayMoney(<span class="number">10000.00</span>);</span><br><span class="line">        order.setCreateDt(<span class="keyword">new</span> Date());</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//构建correlationData 用于做可靠性投递得,ID:必须为全局唯一的 根据业务规则</span></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//开启确认模式</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> TestConfirmCallBack());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启消息可达监听</span></span><br><span class="line">         rabbitTemplate.setReturnCallback(<span class="keyword">new</span> TestRetrunCallBack());</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">    <span class="comment">//先发送一条消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;delayExchange&quot;</span>, <span class="string">&quot;springboot.delay.key&quot;</span>, order, correlationData);</span><br><span class="line"><span class="comment">//十秒后再发送一条消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;delayExchange&quot;</span>, <span class="string">&quot;springboot.delay.key&quot;</span>, order, <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> org.springframework.amqp.core.<span class="function">Message <span class="title">postProcessMessage</span><span class="params">(org.springframework.amqp.core.Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">                message.getMessageProperties().setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">10000</span>);<span class="comment">//设置延迟时间</span></span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息确认回调</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfirmCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;confirm收到了，ack为:&#123;&#125; ,correlationData为:&#123;&#125;,cause为:&#123;&#125;&quot;</span>, ack, correlationData, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息不可达回调</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRetrunCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;RetrunCall收到了，replyCode:&#123;&#125; ,correlationId:&#123;&#125;,replyText:&#123;&#125;,exchange:&#123;&#125;,routingKey:&#123;&#125;&quot;</span>, replyCode, message.getMessageProperties().getCorrelationId(), replyText, exchange, routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试生产者发送消息</li></ul><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20201012132918.png" alt="image-20201012132918314"></p><h2 id="consumer消费者"><a href="#consumer消费者" class="headerlink" title="consumer消费者"></a>consumer消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TulingMsgReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试普通消息接收</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;testBootQueue&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消费消息:&#123;&#125;&quot;</span>, message.getPayload());</span><br><span class="line">        <span class="comment">//手工签收</span></span><br><span class="line">        Long deliveryTag = (Long) message.getHeaders().get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">        log.info(<span class="string">&quot;接受deliveryTag:&#123;&#125;&quot;</span>, deliveryTag);</span><br><span class="line">        channel.basicAck(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试延迟消息接收</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;testBootDelayQueue&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerDelayMsg</span><span class="params">(org.springframework.amqp.core.Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        Order order = objectMapper.readValue(message.getBody(), Order.class);</span><br><span class="line">        log.info(<span class="string">&quot;在&#123;&#125;,签收:&#123;&#125;&quot;</span>, sdf.format(<span class="keyword">new</span> Date()), order);</span><br><span class="line">        log.info(<span class="string">&quot;接受时间和订单生成时间相差&#123;&#125;秒&quot;</span>, DateUtil.formatBetween(order.getCreateDt(),<span class="keyword">new</span> Date()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试延迟消息</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20201012145722.png" alt="image-20201012145722544"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;MQ全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。&lt;/p&gt;
&lt;img sr</summary>
      
    
    
    
    
    <category term="rabbitmq" scheme="https://tj-ever.github.io/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 源码构建 阅读</title>
    <link href="https://tj-ever.github.io/2021/10/21/zookeeper%20leader/"/>
    <id>https://tj-ever.github.io/2021/10/21/zookeeper%20leader/</id>
    <published>2021-10-20T16:00:00.000Z</published>
    <updated>2021-10-27T04:31:47.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码构建"><a href="#源码构建" class="headerlink" title="源码构建"></a>源码构建</h1><h2 id="拉取源码"><a href="#拉取源码" class="headerlink" title="拉取源码"></a>拉取源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;zookeeper&#x2F;tree&#x2F;branch-3.5.8</span><br></pre></td></tr></table></figure><p>用idea导入后，使用maven下载所有模块依赖，然后在下面这个包下创建Info类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.zookeeper.version;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MAJOR = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> MINOR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> MICRO = <span class="number">0</span>;</span><br><span class="line">    String QUALIFIER = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> REVISION = -<span class="number">1</span>;</span><br><span class="line">    String REVISION_HASH = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    String BUILD_DATE = <span class="string">&quot;2021‐10‐21&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在根目录执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install ‐DskipTests</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021153239.png" alt="image-20211021153239111"></p><p>此时会报错，如下</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021161356.png" alt="image-20211021161356020"></p><p>需要修改pom文件</p><p>注释162行</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021161423.png" alt="image-20211021161423649"></p><p>修改222，和223行改为固定值</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021161454.png" alt="image-20211021161454257"></p><p>最后编译成功</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021161713.png" alt="image-20211021161712994"></p><h2 id="寻找入口"><a href="#寻找入口" class="headerlink" title="寻找入口"></a>寻找入口</h2><p>开源项目找入口类一般都是从启动脚本去找，可以从bin目录下的zkServer.sh或zkServer.cmd里找到启动主类运行即可</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021151313.png" alt="image-20211021151313199" style="zoom:50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.zookeeper.server.quorum.QuorumPeerMain</span><br></pre></td></tr></table></figure><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>将conf文件夹里的zoo_sample.cfg文件复制一份改名为zoo.cfg，将zoo.cfg文件位置配置到启动参数里</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021151923.png" alt="image-20211021151923746"></p><p>启动之前需要先将zookeeper-server项目里pom.xml文件里依赖的包(除了jline)的scope为provided这一行全部注释掉</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021152139.png" alt="image-20211021152139028"></p><p>将conf文件夹里的log4j.properties文件复制一份到zookeeper-server项目的 \target\classes 目录下，这样项目启动时才会打印日志</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021152347.png" alt="image-20211021152347421"></p><p>启动成功</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021162012.png" alt="image-20211021162012174"></p><h2 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h2><p>从源码里运行客户端(org.apache.zookeeper.ZooKeeperMain)，注意需要加入启动参数</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021162034.png" alt="image-20211021162034406"></p><p>启动成功</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021162049.png" alt="image-20211021162049419"></p><h2 id="伪集群启动"><a href="#伪集群启动" class="headerlink" title="伪集群启动"></a>伪集群启动</h2><p>复制3个zoo.cfg文件，修改对应集群配置，并在data目录里分别建各自的myid文件填入机器id，并创建三个不同配置的启动节点</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021164556.png" alt="image-20211021164556075"></p><p>Zoo1.cfg (另外两个配置文件只需修改clientPort为2182，2183，dataDir为./zk2/data，./zk3/data)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir&#x3D;.&#x2F;zk1&#x2F;data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.1&#x3D;localhost:2287:3387</span><br><span class="line">server.2&#x3D;localhost:2288:3388</span><br><span class="line">server.3&#x3D;localhost:2289:3389</span><br></pre></td></tr></table></figure><p>分别运行每个节点，启动成功</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021171230.png" alt="image-20211021171230844"></p><h1 id="选举leader流程"><a href="#选举leader流程" class="headerlink" title="选举leader流程"></a>选举leader流程</h1><p>启动或者宕机会流程选举</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021171628.png" alt="image-20211021171628636"></p><h1 id="leader选举多层队列架构"><a href="#leader选举多层队列架构" class="headerlink" title="leader选举多层队列架构"></a>leader选举多层队列架构</h1><p>整个zookeeper选举底层可以分为选举应用层和消息传输层，应用层有自己的队列统一接收和发送选票，传输层也设计了自己的队列，但是按发送的机器分了队列，避免给每台机器发送消息时相互影响，比如某台机器如果出问题发送不成功则不会影响对正常机器的消息发送。</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021171938.png" alt="image-20211021171938329"></p><h1 id="Leader选举源码流程图"><a href="#Leader选举源码流程图" class="headerlink" title="Leader选举源码流程图"></a>Leader选举源码流程图</h1><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211021172348.jpg" alt="Leader选举源码剖析"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;源码构建&quot;&gt;&lt;a href=&quot;#源码构建&quot; class=&quot;headerlink&quot; title=&quot;源码构建&quot;&gt;&lt;/a&gt;源码构建&lt;/h1&gt;&lt;h2 id=&quot;拉取源码&quot;&gt;&lt;a href=&quot;#拉取源码&quot; class=&quot;headerlink&quot; title=&quot;拉取源码&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="Zookeeper" scheme="https://tj-ever.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 客户端使用及集群</title>
    <link href="https://tj-ever.github.io/2021/10/07/Zookeeper%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%9B%86%E7%BE%A4/"/>
    <id>https://tj-ever.github.io/2021/10/07/Zookeeper%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%9B%86%E7%BE%A4/</id>
    <published>2021-10-06T16:00:00.000Z</published>
    <updated>2021-10-21T06:24:06.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper-Java-客户端"><a href="#Zookeeper-Java-客户端" class="headerlink" title="Zookeeper Java 客户端"></a>Zookeeper Java 客户端</h1><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>zookeeper 官方的客户端没有和服务端代码分离，为同一个jar 文件，所以直接引入 zookeeper的maven即可， 这里版本需要保持与服务端版本一致，不然会有兼容性的问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建客户端实例"><a href="#创建客户端实例" class="headerlink" title="创建客户端实例"></a>创建客户端实例</h3><p>为了便于测试，直接在初始化方法中创建zookeeper实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperClientTest</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_ADDRESS=<span class="string">&quot;192.168.109.200:2181&quot;</span>; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_NODE=<span class="string">&quot;/zk‐node&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    zooKeeper=<span class="keyword">new</span> ZooKeeper(ZK_ADDRESS, SESSION_TIMEOUT, event ‐&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.getState()== Watcher.Event.KeeperState.SyncConnected &amp;&amp; event.getType() == Watcher.Event.EventType.None)&#123;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        log.info(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">    log.info(<span class="string">&quot;连接中....&quot;</span>);</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211007011326.png" alt="image-20211007011326867"></p><table><thead><tr><th>参数名称</th><th>含义</th></tr></thead><tbody><tr><td>connectString</td><td>ZooKeeper服务器列表，由英文逗号分开的host:port字符串组成， 每一个都代表一台ZooKeeper机器，<code>host1:port1,host2:port2,host3:port3</code><br />另外，也可以在connectString中设 置客户端连接上ZooKeeper 后的根目录，方法是在host:port字符串之后添加上这个根目录，例如,host1:port1,host2:port2,host3:port3/zk-base，这样就指定了该客户端连接上ZooKeeper服务器之后，所有对ZooKeeper 的操作，都会基于这个根目录。<br />例如，客户端对/sub-node 的操作，最终创建 /zk-node/sub-node, 这个目录也叫Chroot，即客户端隔离命名空间。</td></tr><tr><td>sessionTimeout</td><td>会话的超时时间，是一个以“毫秒”为单位的整型值。在ZooKeeper中有会话的概念，在一个会话周期内，ZooKeeper客户端和服务器之间会通过心跳检测机制来维持会话的有效性，一旦在sessionTimeout时间内没有进行有效的心跳检测，会话就会失效。</td></tr><tr><td>watcher</td><td>ZooKeeper允许客户端在构造方法中传入一个接口 <code>watcher (org.apache. zookeeper. Watcher)</code>的实现类对象来作为默认的 Watcher事件通知处理器。当然，该参数可以设置为null 以表明不需要设置默认的 Watcher处理器。</td></tr><tr><td>canBeReadOnly</td><td>这是一个boolean类型的参数，用于标识当前会话是否支持“read-only(只读)”模式。<br />默认情况下，在ZooKeeper集群中，一个机器如果和集群中过半及以上机器失去了网络连接，那么这个机器将不再处理客户端请求(包括读写请求)。<br />但是在某些使用场景下，当ZooKeeper服务器发生此类故障的时候，还是希望ZooKeeper服务器能够提供读服务(当然写服务肯定无法提供)—— 这就是 ZooKeeper的“read-only”模式。</td></tr><tr><td>sessionId和 ses sionPasswd</td><td>分别代表会话ID和会话秘钥。这两个参数能够唯一确定一个会话，同时客户端使用这两个参数可以实现客户端会话复用，从而达到恢复会话的效果。具体使用方法是，第一次连接上ZooKeeper服务器时，通过调用ZooKeeper对象实例的以下两个接口，即可获得当前会话的ID和秘钥: <br /><code>long getSessionId();byte[]getSessionPasswd( );</code><br /> 获取到这两个参数值之后，就可以在下次创建ZooKeeper对象实例的时候传入构造方法了</td></tr></tbody></table><h3 id="同步创建节点"><a href="#同步创建节点" class="headerlink" title="同步创建节点"></a>同步创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTest</span><span class="params">()</span><span class="keyword">throws</span> KeeperException,InterruptedException</span>&#123;</span><br><span class="line">String path = zooKeeper.create(ZK_NODE, <span class="string">&quot;data&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ CL_UNSAFE,CreateMode.PERSISTENT);</span><br><span class="line">log.info(<span class="string">&quot;created path: &#123;&#125;&quot;</span>,path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步创建节点"><a href="#异步创建节点" class="headerlink" title="异步创建节点"></a>异步创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAsycTest</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"> zooKeeper.create(ZK_NODE, <span class="string">&quot;data&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT,</span><br><span class="line">   (rc, path, ctx, name) ‐&gt; log.info(<span class="string">&quot;rc &#123;&#125;,path &#123;&#125;,ctx &#123;&#125;,name &#123;&#125;&quot;</span>,rc,path,ctx,name),<span class="string">&quot;context&quot;</span>);</span><br><span class="line">  TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改节点数据"><a href="#修改节点数据" class="headerlink" title="修改节点数据"></a>修改节点数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTest</span><span class="params">()</span>throwsKeeperException,InterruptedException</span>&#123;</span><br><span class="line">   Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line"> <span class="keyword">byte</span>[] data = zooKeeper.getData(ZK_NODE, <span class="keyword">false</span>, stat);</span><br><span class="line"> log.info(<span class="string">&quot;修改前: &#123;&#125;&quot;</span>,<span class="keyword">new</span> String(data));</span><br><span class="line"> zooKeeper.setData(ZK_NODE, <span class="string">&quot;changed!&quot;</span>.getBytes(), stat.getVersion());</span><br><span class="line"> <span class="keyword">byte</span>[] dataAfter = zooKeeper.getData(ZK_NODE, <span class="keyword">false</span>, stat);</span><br><span class="line"> log.info(<span class="string">&quot;修改后: &#123;&#125;&quot;</span>,<span class="keyword">new</span> String(dataAfter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h1><p>Curator 是一套由netflix 公司开源的，Java 语言编程的 ZooKeeper 客户端框架，Curator项目是现在ZooKeeper 客户端中使用最多，对ZooKeeper 版本支持最好的第三方客户端，并推荐使用，Curator 把我们平时常用的很多 ZooKeeper 服务开发功能做了封装，例如 Leader 选举、 分布式计数器、分布式锁。这就减少了技术人员在使用 ZooKeeper 时的大部分底层细节开发工作。</p><p>在会话重新连接、Watch 反复注册、多种异常处理等使用场景中，用原生的 ZooKeeper 处理比较复杂。而在使用 Curator 时，由于其对这些功能都做了高度的封装，使用起来更加简单，不但减少了开发时间，而且增强了程序的可靠性。</p><h2 id="Curator-实战"><a href="#Curator-实战" class="headerlink" title="Curator 实战"></a>Curator 实战</h2><p>这里以 Maven 工程为例，首先要引入Curator 框架相关的开发包，这里为了方便测试引入 了junit ，lombok，由于Zookeeper本身以来了 log4j 日志框架，所以这里可以创建对应的 log4j配置文件后直接使用。 如下面的代码所示，我们通过将 Curator 相关的引用包配置到 Maven 工程的 pom 文件中，将 Curaotr 框架引用到工程项目里，在配置文件中分别引用了两 个 Curator 相关的包</p><p>第一个是 curator-framework 包，该包是对 ZooKeeper 底层 API 的一些封装。</p><p>另一个是 curator-recipes 包，该包封装了一些 ZooKeeper 服务的高级特性，如: Cache 事件监听、选举、分布式锁、分布式 Barrier。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator‐recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="会话创建"><a href="#会话创建" class="headerlink" title="会话创建"></a>会话创建</h3><p>要进行客户端服务器交互，第一步就要创建会话 </p><p>Curator 提供了多种方式创建会话</p><p><strong>静态工厂方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重试策略</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>,<span class="number">3</span>)</span><br><span class="line">CuratorFramework client = CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy);</span><br><span class="line">client.start();</span><br></pre></td></tr></table></figure><p><strong>fluent 风格</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>,<span class="number">3</span>);</span><br><span class="line">CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">.connectString(<span class="string">&quot;192.168.128.129:2181&quot;</span>)</span><br><span class="line">.sessionTimeoutMs(<span class="number">5000</span>) <span class="comment">// 会话超时时间</span></span><br><span class="line">.connectionTimeoutMs(<span class="number">5000</span>) <span class="comment">// 连接超时时间</span></span><br><span class="line">.retryPolicy(retryPolicy)</span><br><span class="line">.namespace(<span class="string">&quot;base&quot;</span>) <span class="comment">// 包含隔离名称</span></span><br><span class="line">.build();</span><br><span class="line">client.start();</span><br></pre></td></tr></table></figure><p>这段代码的编码风格采用了流式方式，最核心的类是 CuratorFramework 类，该类的作用是定 义一个 ZooKeeper 客户端对象，并在之后的上下文中使用。在定义 CuratorFramework 对象实例的时候，使用了 CuratorFrameworkFactory 工厂方法，并指定了 connectionString 服务器地址列表、retryPolicy 重试策略 、sessionTimeoutMs 会话超时时间、 connectionTimeoutMs 会话创建超时时间。</p><ul><li><p>connectionString:服务器地址列表</p><p>如果是多个地址，那么每个服务器地址列表用逗号分隔， 如 host1:port1,host2:port2,host3;port3 。</p></li><li><p>retryPolicy:重试策略</p><p>当客户端异常退出或者与服务端失去连接的时候，可以通过设置客户端重新连接 ZooKeeper 服务端。而 Curator 提供了 一次重试、多次重试等不同种类的实现方式。</p><p>在 Curator 内部，可以通过判断服务器返回的 keeperException 的状态代码来判断是否进行重试处理，如果返回的是 OK 表示一切操作都没有问题，而 SYSTEMERROR 表示系统或服务端错误。</p></li></ul><table><thead><tr><th>策略名称</th><th>描述</th></tr></thead><tbody><tr><td>ExponentialBackoffRetry</td><td>重试一组次数，重试之间的睡眠时间增加</td></tr><tr><td>RetryNTimes</td><td>重试最大次数</td></tr><tr><td>RetryOneTime</td><td>只重试一次</td></tr><tr><td>RetryUntilElapsed</td><td>在给定的时间结束之前重试</td></tr></tbody></table><ul><li><p>超时时间:Curator </p><p>客户端创建过程中，有两个超时时间的设置。一个是 sessionTimeoutMs 会话超时时间，用来设置该条会话在 ZooKeeper 服务端的失效时间。另一个是 connectionTimeoutMs 客户端创建会话的超时时间，用来限制客户端发起一个会话连接到接收 ZooKeeper 服务端应答的时间。sessionTimeoutMs 作用在服务端，而 connectionTimeoutMs 作用在客户端。</p></li></ul><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>创建节点的方式如下面的代码所示，回顾我们之前课程中讲到的内容，描述一个节点要包括节点的类型，即临时节点还是持久节点、节点的数据信息、节点是否是有序节点等属性和性质。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreate</span><span class="params">()</span> throwsException</span>&#123;</span><br><span class="line">String path = curatorFramework.create().forPath(<span class="string">&quot;/curator‐node&quot;</span>);</span><br><span class="line"><span class="comment">// curatorFramework.create().withMode(CreateMode.PERSISTENT).forPath(&quot;/curatr‐node&quot;,&quot;some‐data&quot;.getBytes())</span></span><br><span class="line">log.info(<span class="string">&quot;curator create node :&#123;&#125; successfully.&quot;</span>,path); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Curator 中，可以使用 create 函数创建数据节点，并通过 withMode 函数指定节点类型 (持久化节点，临时节点，顺序节点，临时顺序节点，持久化顺序节点等)，默认是持久化节点，之后调用 forPath 函数来指定节点的路径和数据信息。</p><h3 id="一次性创建带层级结构的节点"><a href="#一次性创建带层级结构的节点" class="headerlink" title="一次性创建带层级结构的节点"></a>一次性创建带层级结构的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateWithParent</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">String pathWithParent=<span class="string">&quot;/node‐parent/sub‐node‐1&quot;</span>;</span><br><span class="line">String path = curatorFramework.create().creatingParentsIfNeeded().forPath(pathWithParent);</span><br><span class="line">log.info(<span class="string">&quot;curator create node :&#123;&#125; successfully.&quot;</span>,path); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetData</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="string">&quot;/curator‐node&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;get data from node :&#123;&#125; successfully.&quot;</span>,<span class="keyword">new</span> String(bytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><p>我们通过客户端实例的 setData() 方法更新 ZooKeeper 服务上的数据节点，在setData 方法的后边，通过 forPath 函数来指定更新的数据节点路径以及要更新的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSetData</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"> curatorFramework.setData().forPath(<span class="string">&quot;/curator‐node&quot;</span>,<span class="string">&quot;changed!&quot;</span>.getBytes());</span><br><span class="line"> <span class="keyword">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="string">&quot;/curator‐node&quot;</span>);</span><br><span class="line"> log.info(<span class="string">&quot;get data from node /curator‐node :&#123;&#125; successfully.&quot;</span>,<span class="keyword">new</span> String(bytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">String pathWithParent=<span class="string">&quot;/node‐parent&quot;</span>;</span><br><span class="line">curatorFramework.delete().guaranteed().deletingChildrenIfNeeded().forPath(pathWithParent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>guaranteed:该函数的功能如字面意思一样，主要起到一个保障删除成功的作用，底层工作方式是:只要该客户端的会话有效，就会在后台持续发起删除请求，直到该数据节点在 ZooKeeper 服务端被删除。</p><p>deletingChildrenIfNeeded:指定了该函数后，系统在删除该数据节点的时候会以递归的方式直接删除其子节点，以及子节点的子节点。</p><h3 id="异步接口"><a href="#异步接口" class="headerlink" title="异步接口"></a>异步接口</h3><p>Curator 引入了BackgroundCallback 接口，用来处理服务器端返回来的信息，这个处理过程是在异步线程中调用，默认在 EventThread 中调用，也可以自定义线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackgroundCallback</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上接口，主要参数为 client 客户端，和服务端事件 event inBackground 异步处理默认在EventThread中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">curatorFramework.getData().inBackground((item1, item2) ‐&gt; &#123;</span><br><span class="line">  log.info(<span class="string">&quot; background: &#123;&#125;&quot;</span>, item2);</span><br><span class="line">&#125;).forPath(ZK_NODE);</span><br><span class="line">  TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定线程池"><a href="#指定线程池" class="headerlink" title="指定线程池"></a>指定线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">curatorFramework.getData().inBackground((item1, item2) ‐&gt; &#123;</span><br><span class="line">log.info(<span class="string">&quot; background: &#123;&#125;&quot;</span>, item2);</span><br><span class="line">&#125;,executorService).forPath(ZK_NODE);</span><br><span class="line"></span><br><span class="line">TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Curator-监听器"><a href="#Curator-监听器" class="headerlink" title="Curator 监听器"></a>Curator 监听器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CuratorListener</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对 background 通知和错误通知。使用此监听器之后，调用inBackground 方法会异步获得监听</p><h3 id="Curator-Caches"><a href="#Curator-Caches" class="headerlink" title="Curator Caches"></a>Curator Caches</h3><p><strong>Curator 引入了 Cache 来实现对 Zookeeper 服务端事件监听</strong>，Cache 事件监听可以理解为一个本地缓存视图与远程 Zookeeper 视图的对比过程。Cache 提供了反复注册的功能。Cache 分为两类注册类型:节点监听和子节点监听。</p><h4 id="node-cache"><a href="#node-cache" class="headerlink" title="node cache"></a>node cache</h4><p>NodeCache 对某一个节点进行监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NodeCache</span><span class="params">(CuratorFrameworkclient, String path)</span></span></span><br></pre></td></tr></table></figure><p>可以通过注册监听器来实现，对当前节点数据变化的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(NodeCacheListenerlistener)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeCacheTest</span> <span class="keyword">extends</span> <span class="title">AbstractCuratorTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NODE_CACHE=<span class="string">&quot;/node‐cache&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNodeCacheTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    createIfNeed(NODE_CACHE);</span><br><span class="line">    NodeCache nodeCache = <span class="keyword">new</span> NodeCache(curatorFramework, NODE_CACHE);</span><br><span class="line">    nodeCache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;&#123;&#125; path nodeChanged: &quot;</span>,NODE_CACHE);</span><br><span class="line">      printNodeData();</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">nodeCache.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNodeData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = curatorFramework.getData().forPath(NODE_CACHE);</span><br><span class="line">log.info(<span class="string">&quot;data: &#123;&#125;&quot;</span>,<span class="keyword">new</span> String(bytes));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="path-cache"><a href="#path-cache" class="headerlink" title="path cache"></a>path cache</h4><p>PathChildrenCache 会对子节点进行监听，但是不会对二级子节点进行监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFrameworkclient, String path, <span class="keyword">boolean</span> cacheData)</span></span></span><br></pre></td></tr></table></figure><p>可以通过注册监听器来实现，对当前节点的子节点数据变化的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(PathChildrenCacheListener listener)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathCacheTest</span> <span class="keyword">extends</span> <span class="title">AbstractCuratorTest</span></span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH=<span class="string">&quot;/path‐cache&quot;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPathCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">createIfNeed(PATH);</span><br><span class="line">  PathChildrenCache pathChildrenCache = <span class="keyword">new</span></span><br><span class="line">PathChildrenCache(curatorFramework, PATH, <span class="keyword">true</span>);</span><br><span class="line">pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;event: &#123;&#125;&quot;</span>,event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果设置为true则在首次启动时就会缓存节点内容到Cache中</span></span><br><span class="line">pathChildrenCache.start(<span class="keyword">true</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tree-cache"><a href="#tree-cache" class="headerlink" title="tree cache"></a>tree cache</h4><p>TreeCache 使用一个内部类TreeNode来维护这个一个树结构。并将这个树结构与ZK节点进行映射。所以TreeCache 可以监听当前节点下所有节点的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeCache</span><span class="params">(CuratorFrameworkclient, String path, <span class="keyword">boolean</span> cacheData)</span></span></span><br></pre></td></tr></table></figure><p>可以通过注册监听器来实现，对当前节点的子节点，及递归子节点数据变化的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(TreeCacheListener listener)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeCacheTest</span> <span class="keyword">extends</span> <span class="title">AbstractCuratorTest</span></span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TREE_CACHE=<span class="string">&quot;/tree‐path&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTreeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">createIfNeed(TREE_CACHE);</span><br><span class="line"> TreeCache treeCache = <span class="keyword">new</span> TreeCache(curatorFramework, TREE_CACHE);</span><br><span class="line">  treeCache.getListenable().addListener(<span class="keyword">new</span> TreeCacheListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, TreeCacheEvent event)</span> throw Exception </span>&#123;</span><br><span class="line"> log.info(<span class="string">&quot; tree cache: &#123;&#125;&quot;</span>,event);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> treeCache.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Zookeeper-集群模式"><a href="#Zookeeper-集群模式" class="headerlink" title="Zookeeper 集群模式"></a>Zookeeper 集群模式</h1><p>Zookeeper 集群模式一共有三种类型的角色</p><ul><li>Leader: 处理所有的事务请求(写请求)，可以处理读请求，集群中只能有一个Leader </li><li>Follower:只能处理读请求，同时作为 Leader的候选节点，即如果Leader宕机，Follower节点 要参与到新的Leader选举中，有可能成为新的Leader节点。 </li><li>Observer:只能处理读请求。不能参与选举</li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211008102338.png" alt="image-20211008102338293" style="zoom:50%;" /><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>本例搭建的是伪集群模式，即一台机器上启动四个zookeeper实例组成集群，真正的集群模式无非就是实例IP地址不同，搭建方法没有区别</p><ol><li><p>配置JAVA环境，检验环境:保证是jdk7 及以上即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐version</span><br></pre></td></tr></table></figure></li><li><p>下载并解压zookeeper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;zookeeper&#x2F;zookeeper‐3.5.8&#x2F;apache‐zookeeper‐3.5.8‐bin.tar.gz</span><br><span class="line">tar ‐zxvf apache‐zookeeper‐3.5.8‐bin.tar.gz </span><br><span class="line">cd apache‐zookeeper‐3.5.8‐bin</span><br></pre></td></tr></table></figure></li><li><p>重命名 zoo_sample.cfg文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp conf&#x2F;zoo_sample.cfg conf&#x2F;zoo‐1.cfg</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件zoo-1.cfg，原配置文件里有的，修改成下面的值，没有的则加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#vim conf&#x2F;zoo‐1.cfg</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;data&#x2F;zookeeper‐1</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line">server.1&#x3D;127.0.0.1:2001:3001:participant&#x2F;&#x2F; participant 可以不用写，默认就是participant</span><br><span class="line">server.2&#x3D;127.0.0.1:2002:3002:participant</span><br><span class="line">server.3&#x3D;127.0.0.1:2003:3003:participant</span><br><span class="line">server.4&#x3D;127.0.0.1:2004:3004:observer</span><br></pre></td></tr></table></figure><p>配置说明</p><blockquote><p>tickTime:用于配置Zookeeper中最小时间单位的长度，很多运行时的时间间隔都是使用tickTime的倍数来表示的。</p><p>initLimit:该参数用于配置Leader服务器等待Follower启动，并完成数据同步的时间。Follower服务器再启动过程中，会与Leader建立连接并完成数据的同步，从而确定自己对外提供服务的起始状态。Leader服务器允许Follower再initLimit 时间内完成这个工作。</p><p>syncLimit:Leader 与Follower心跳检测的最大延时时间</p><p>dataDir:顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将 写数据的日志文件也保存在这个目录里。</p><p>clientPort:这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</p><p>server.A=B:C:D:E 其中 A 是一个数字，表示这个是第几号服务器;B 是这个服务器的 ip 地址;C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口;D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。如果需要通过添加不参与集群选举以及事务请求的过半机制的 Observer节点，可以在E的位置，添加observer标识。</p></blockquote></li><li><p>再从zoo-1.cfg复制三个配置文件zoo-2.cfg，zoo-3.cfg和zoo-4.cfg，只需修改 dataDir和clientPort不同即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cp conf&#x2F;zoo1.cfg conf&#x2F;zoo2.cfg</span><br><span class="line">cp conf&#x2F;zoo1.cfg conf&#x2F;zoo3.cfg</span><br><span class="line">cp conf&#x2F;zoo1.cfg conf&#x2F;zoo4.cfg</span><br><span class="line"></span><br><span class="line">vim conf&#x2F;zoo2.cfg</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;data&#x2F;zookeeper2</span><br><span class="line">clientPort&#x3D;2182</span><br><span class="line"></span><br><span class="line">vim conf&#x2F;zoo3.cfg</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;data&#x2F;zookeeper3 </span><br><span class="line">clientPort&#x3D;2183</span><br><span class="line"></span><br><span class="line">vim conf&#x2F;zoo4.cfg</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;data&#x2F;zookeeper4 </span><br><span class="line">clientPort&#x3D;2184</span><br></pre></td></tr></table></figure></li><li><p>标识Server ID</p><p>创建四个文件夹/usr/local/data/zookeeper-1，/usr/local/data/zookeeper- 2，/usr/local/data/zookeeper-3，/usr/local/data/zookeeper-4，在每个目录中创建文件 myid 文件，写入当前实例的server id，即1，2，3，4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;data&#x2F;zookeeper‐1</span><br><span class="line">vim myid</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;data&#x2F;zookeeper‐2</span><br><span class="line">vim myid</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;data&#x2F;zookeeper‐3</span><br><span class="line">vim myid</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">cd&#x2F;usr&#x2F;local&#x2F;data&#x2F;zookeeper‐4</span><br><span class="line">vim myid</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li><li><p>启动三个zookeeper实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;zkServer.sh start conf&#x2F;zoo1.cfg </span><br><span class="line">bin&#x2F;zkServer.sh start conf&#x2F;zoo2.cfg </span><br><span class="line">bin&#x2F;zkServer.sh start conf&#x2F;zoo3.cfg</span><br></pre></td></tr></table></figure></li><li><p>检测集群状态，也可以直接用命令 zkServer.sh status conf/zoo1.cfg 进行每台服务的状态查询</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211008103403.png" alt="image-20211008103403713" style="zoom:50%;" /></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;zkCli.sh ‐server ip1:port1,ip2:port2,ip3:port3</span><br></pre></td></tr></table></figure><p>可以通过查看/zookeeper/config 节点数据来查看集群配置</p><h2 id="集群动态配置"><a href="#集群动态配置" class="headerlink" title="集群动态配置"></a>集群动态配置</h2><p>Zookeeper 3.5.0 以前，Zookeeper集群角色要发生改变的话，只能通过停掉所有的 Zookeeper服务，修改集群配置，重启服务来完成，这样集群服务将有一段不可用的状态，为了应对高可用需求，Zookeeper 3.5.0 提供了支持动态扩容/缩容的 新特性。但是通过客户端API 可以变更服务端集群状态是件很危险的事情，所以在zookeeper 3.5.3 版本要用动态配置，需要 开启超级管理员身份验证模式 ACLs。如果是在一个安全的环境也可以通过配置 系统参数 - Dzookeeper.skipACL=yes 来避免配置维护acl 权限配置。</p><ol><li><p>先配置一个超级管理员(如果不配管理员，也可以设置系统参数 - Dzookeeper.skipACL=yes)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在zookeeper启动脚本中添加 超级管理员授权模式:</span><br><span class="line"></span><br><span class="line">echo ‐n gj:123 | openssl dgst ‐binary ‐sha1 | openssl base64</span><br><span class="line">&#x2F;&#x2F;RRCKWv2U2e99M6UmsFaJiQ2xStw&#x3D;</span><br><span class="line"></span><br><span class="line">‐Dzookeeper.DigestAuthenticationProvider.superDigest&#x3D;gj:RRCKWv2U2e99M6UmsFaJiQ2xStw&#x3D;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211008103950.png" alt="image-20211008103950049"></p></li></ol><p>配置动态文件</p><p>修改配置 zoo1.cfg<br><strong>注意这里去除了端口号，添加了 reconfigEnabled : 设置为true 开启动态配置</strong><br>dynamicConfigFile : 指定动态配置文件的路径</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211008104141.png" alt="image-20211008104141046" style="zoom:50%;" /><p>创建文件 zoo_replicated1.cfg.dynamic</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">动态配置文件,加入集群信息 </span><br><span class="line">server.A&#x3D;B.C.D.E;F</span><br><span class="line">A: 服务的唯一标识</span><br><span class="line">B: 服务对应的IP地址</span><br><span class="line">C: 集群通信端口</span><br><span class="line">D: 集群选举端口</span><br><span class="line">E: 角色，默认是 participant,即参与过半机制的角色，选举，事务请求过半提交</span><br><span class="line">还有一个是 observer, 观察者，不参与选举以及过半机制。之后是一个分号，一定是分号</span><br><span class="line">F:服务IP:端口</span><br><span class="line"></span><br><span class="line">server.1&#x3D;192.168.109.200:2001:3001:participant;192.168.109.200:2181</span><br><span class="line">server.2&#x3D;192.168.109.200:2002:3002:participant;192.168.109.200:2182</span><br><span class="line">server.3&#x3D;192.168.109.200:2003:3003:participant;192.168.109.200:2183</span><br></pre></td></tr></table></figure><p>依次配置其他服务 zoo2.cfg ,zoo3.cfg注意数据文件的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">依次启动所有服务</span><br><span class="line">.&#x2F;bin&#x2F;zkServer.sh start conf&#x2F;zoo1.cfg </span><br><span class="line"></span><br><span class="line">查看集群状态</span><br><span class="line">.&#x2F;bin&#x2F;zkServer.sh status conf&#x2F;zoo1.cfg</span><br></pre></td></tr></table></figure><p>连上任意一台服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查看集群配置</span><br><span class="line">config &#x2F;&#x2F; 将会把动态配置打印出来 </span><br><span class="line">也可以直接查看目录 </span><br><span class="line">&#x2F;zookeeper&#x2F;config 该节点存储了集群信息</span><br><span class="line"></span><br><span class="line">如果要修改集群状态，需要授权登录</span><br><span class="line">addauth digest gj:123</span><br><span class="line">reconfig ‐remove 3 &#x2F;&#x2F; 移除serverId为 3 的机器</span><br><span class="line">&#x2F;&#x2F; 把对应的机器加进来</span><br><span class="line">reconfig ‐add server.3&#x3D;192.168.109.200:2003:3003:participant;192.168.109.200:2183</span><br></pre></td></tr></table></figure><p>如果要变更/或者添加新的服务需要将服务加到配置文件 zoo_replicated1.cfg.dynamic 中，启动服务然后通过reconfig 命令进行添加或者变更服务角色，但是需要保证服务列表中 participant 角色能够形成集群(过半机制)</p><p>客户端可以通过监听 /zookeeper/confg 节点，来感知集群的变化，从而实现集群的动态变更. </p><p>Zookeeper 类提供了对应的API 用来更新服务列表 : updateServerList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.getType() == Event.EventType.None &amp;&amp; event.getState() == Event.KeeperState.SyncConnected)&#123;</span><br><span class="line">   countDownLatch.countDown();</span><br><span class="line">   log.info(<span class="string">&quot; 连接建立&quot;</span>);</span><br><span class="line"><span class="comment">// start to watch config</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot; 开始监听:&#123;&#125;&quot;</span>,ZooDefs.CONFIG_NODE);</span><br><span class="line">        zookeeper.getConfig(<span class="keyword">true</span>,<span class="keyword">null</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( event.getPath() !=<span class="keyword">null</span> &amp;&amp; event.getPath().equals(ZooDefs.CONFIG_NONE))&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] config = zookeeper.getConfig(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">        String clientConfigStr = ConfigUtils.getClientConfigStr(<span class="keyword">new</span> String(config))</span><br><span class="line">        log.info(<span class="string">&quot; 配置发生变更: &#123;&#125;&quot;</span>,clientConfigStr);</span><br><span class="line">        zookeeper.updateServerList(clientConfigStr.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Curator 也自带了动态配置的监听，不需要额外的配置和代码实现监听更新;</p><h1 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h1><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211008105605.png" alt="image-20211008105605333" style="zoom:50%;" /><p>如上实现方式在并发问题比较严重的情况下，性能会下降的比较厉害，主要原因是，所有的连接都在对同一个节点进行监听，当服务器检测到删除事件时，要通知所有的连接，所有的连接同时收到事件，再次并发竞争，这就是羊群效应。</p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211008105717.png" alt="image-20211008105716941" style="zoom:50%;" /><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>创建表，并且插入一条库存数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`order`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`order`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`pid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`product`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`product`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`product_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`stock`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`version`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`product`</span> <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;苹果手机&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><p>不加分布式锁代码，注释掉CuratorFramework相关代码</p><p>加分布式锁代码，打开注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/stock/deduct/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reduceStock</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        InterProcessMutex lock = new InterProcessMutex(curatorFramework, &quot;/product_&quot; + id);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            lock.acquire();</span></span><br><span class="line">            orderService.reduceStock(id);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"><span class="comment">//        finally &#123;</span></span><br><span class="line"><span class="comment">//            lock.release();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok:&quot;</span> + port;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// service</span></span><br><span class="line"> <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">reduceStock</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.    获取库存</span></span><br><span class="line">        Product product = productMapper.getProduct(id);</span><br><span class="line">        <span class="comment">// 模拟耗时业务处理</span></span><br><span class="line">        sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (product.getStock() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;out of stock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.    减库存</span></span><br><span class="line">        <span class="keyword">int</span> i = productMapper.deductStock(id);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            Order order = <span class="keyword">new</span> Order();</span><br><span class="line">            order.setUserId(UUID.randomUUID().toString());</span><br><span class="line">            order.setPid(id);</span><br><span class="line">            orderMapper.insert(order);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;deduct stock fail, retry.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不加锁，请求有可能全部成功，库存出现负数的情况</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211011164040.png" alt="image-20211011164040259" style="zoom:50%;" /><p>加锁，只有五个请求成功（因为只有五个库存），操作完库存为0 </p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211011163929.png" alt="image-20211011163929092" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Zookeeper-Java-客户端&quot;&gt;&lt;a href=&quot;#Zookeeper-Java-客户端&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper Java 客户端&quot;&gt;&lt;/a&gt;Zookeeper Java 客户端&lt;/h1&gt;&lt;h2 id=&quot;项</summary>
      
    
    
    
    
    <category term="Zookeeper" scheme="https://tj-ever.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 特性及节点数据</title>
    <link href="https://tj-ever.github.io/2021/10/06/Zookeeper%20%E7%89%B9%E6%80%A7%E5%8F%8A%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE/"/>
    <id>https://tj-ever.github.io/2021/10/06/Zookeeper%20%E7%89%B9%E6%80%A7%E5%8F%8A%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE/</id>
    <published>2021-10-05T16:00:00.000Z</published>
    <updated>2021-10-05T14:31:53.914Z</updated>
    
    <content type="html"><![CDATA[<p>在了解Zookeeper之前，需要对分布式相关知识有一定了解，什么是分布式系统?</p><p>通常情况 下，单个物理节点很容易达到性能，计算或者容量的瓶颈，所以这个时候就需要多个物理节点来 共同完成某项任务，一个分布式系统的本质是分布在不同网络或计算机上的程序组件，彼此通过信息传递来协同工作的系统，而Zookeeper正是一个分布式应用协调框架，在分布式系统架构中有广泛的应用场景。</p><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><p>官方文档上这么解释zookeeper，它是一个分布式协调框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如:统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005185424.png" alt="image-20211005185424206" style="zoom:50%;" /><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>上面的解释有点抽象，我们暂时可以理解为 Zookeeper 是一个用于存储少量数据的基于内存的数据库</p><p>主要有如下两个核心的概念:<strong>文件系统数据结构+监听通知机制</strong>。</p><h2 id="文件系统数据结构"><a href="#文件系统数据结构" class="headerlink" title="文件系统数据结构"></a>文件系统数据结构</h2><p>Zookeeper维护一个类似文件系统的数据结构</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005190141.png" alt="image-20211005190141368" style="zoom:50%;" /><p>每个子目录项都被称作为 znode(目录节点)，和文件系统类似，我们能够自由的增加、删除 znode，在一个znode下增加、删除子znode。<br>有四种类型的znode:</p><ul><li><p>PERSISTENT­ 持久化目录节点 </p><p>客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，将永远存在</p></li><li><p>PERSISTENT_SEQUENTIAL­ 持久化顺序编号目录节点 </p><p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p></li><li><p>EPHEMERAL­ 临时目录节点 </p><p>客户端与zookeeper断开连接后，该节点被删除</p></li><li><p>EPHEMERAL_SEQUENTIAL­ 临时顺序编号目录节点 </p><p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p></li><li><p>Container 节点(3.5.3 版本新增，如果Container节点下面没有子节点，则Container节点在未来会被Zookeeper自动清除,定时任务默认60s 检查一次)</p></li><li><p>TTL 节点( 默认禁用，只能通过系统配置 zookeeper.extendedTypesEnabled=true 开启，不稳定)</p></li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005190328.png" alt="image-20211005190328454" style="zoom:50%;" /><h2 id="监听通知机制"><a href="#监听通知机制" class="headerlink" title="监听通知机制"></a>监听通知机制</h2><p>客户端注册监听它关心的任意节点，或者目录节点及递归子目录节点</p><ul><li>如果注册的是对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通知</li><li>如果注册的是对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对应的客户端将被通知</li><li>如果注册的是对某个目录的递归子节点进行监听，则当这个目录下面的任意子节点有目录结构的变化(有子节点被创建，或被删除)或者根节点有数据变化时，对应的客户端将被通知。</li></ul><p><strong>注意</strong>：所有的通知都是一次性的，及无论是对节点还是对目录进行的监听，一旦触发，对应的监听即被移除。递归子节点，监听是对所有子节点的，所以，每个子节点下面的事件同样只会被触发一次。</p><h1 id="经典的应用场景"><a href="#经典的应用场景" class="headerlink" title="经典的应用场景"></a>经典的应用场景</h1><ul><li>分布式配置中心</li><li>分布式注册中心 </li><li>分布式锁</li><li>分布式队列</li><li>集群选举</li><li>分布式屏障 </li><li>发布/订阅</li></ul><h1 id="Zookeeper-实战"><a href="#Zookeeper-实战" class="headerlink" title="Zookeeper 实战"></a>Zookeeper 实战</h1><h2 id="zookeeper安装"><a href="#zookeeper安装" class="headerlink" title="zookeeper安装"></a>zookeeper安装</h2><ol><li><p>配置JAVA环境，检验环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐version</span><br></pre></td></tr></table></figure></li><li><p>下载解压 zookeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper‐3.5.8/apache‐zookeep r‐3.5.8‐bin.tar.gz</span><br><span class="line">tar ‐zxvf apache‐zookeeper‐3.5.8‐bin.tar.gz</span><br><span class="line">cd apache‐zookeeper‐3.5.8‐bin</span><br></pre></td></tr></table></figure></li><li><p>重命名配置文件 zoo_sample.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></li><li><p>启动zookeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以通过 bin/zkServer.sh 来查看都支持哪些参数</span> </span><br><span class="line">bin/zkServer.sh start conf/zoo.cfg</span><br></pre></td></tr></table></figure></li><li><p>检测是否启动成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo stat | nc 192.168.109.200 </span><br><span class="line">// 前提是配置文件中中将 stat 四字命令设置了白名单</span><br><span class="line">4lw.commands.whitelist=stat</span><br></pre></td></tr></table></figure></li><li><p>连接服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkCli.sh ‐server ip:port</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用命令行操作zookeeper"><a href="#使用命令行操作zookeeper" class="headerlink" title="使用命令行操作zookeeper"></a>使用命令行操作zookeeper</h2><p>输入命令 help 查看zookeeper所支持的所有命令</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005193730.png" alt="image-20211005193730685"></p><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><p>操作根据上方的help命令</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005195037.png" alt="image-20211005195037146" style="zoom:50%;" /><p><strong>stat</strong></p><ul><li>cZxid:创建znode的事务ID(Zxid的值)。 </li><li>mZxid:最后修改znode的事务ID。 </li><li>pZxid:最后添加或删除子节点的事务ID(子节点列表发生变化才会发生改变)。 </li><li>ctime:znode创建时间。</li><li>mtime:znode最近修改时间。</li><li>dataVersion:znode的当前数据版本。 </li><li>cversion:znode的子节点结果集版本(一个节点的子节点增加、删除都会影响这个版本)。</li><li>aclVersion:表示对此znode的acl版本。 </li><li>ephemeralOwner:znode是临时znode时，表示znode所有者的 session ID。 如果znode不是临时znode，则该字段设置为零。 </li><li>dataLength:znode数据字段的长度。</li><li>numChildren:znode的子znode的数量。</li></ul><h3 id="乐观锁修改"><a href="#乐观锁修改" class="headerlink" title="乐观锁修改"></a>乐观锁修改</h3><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005204429.png" alt="image-20211005204324454"></p><p>其他类型节点操作类似，此处不再赘述</p><h2 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h2><h3 id="针对节点的监听"><a href="#针对节点的监听" class="headerlink" title="针对节点的监听"></a>针对节点的监听</h3><p>一定事件触发，对应的注册立刻被移除，所以事件监听是一次性的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册监听的同时获取数据</span><br><span class="line">get ‐w &#x2F;path</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对节点进行监听，且获取元数据信息</span><br><span class="line">stat ‐w &#x2F;path</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005204908.png" alt="image-20211005204908897" style="zoom:50%;" /><p>针对目录的监听，如下图，目录的变化，会触发事件，且一旦触发，对应的监听也会被移除，后<br>续对节点的创建没有触发监听事件</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005205146.png" alt="image-20211005205146959" style="zoom:50%;" /><h3 id="针对递归子目录的监听"><a href="#针对递归子目录的监听" class="headerlink" title="针对递归子目录的监听"></a>针对递归子目录的监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls ‐R ‐w &#x2F;path : ‐R 区分大小写，一定用大写</span><br></pre></td></tr></table></figure><p>如下对/test 节点进行递归监听，但是每个目录下的目录监听也是一次性的</p><p>如第一次在/test 目录下创建节点时，触发监听事件，第二次则没有</p><p>同样，在/test/sub1下进行节点创建时，触发事件，但是再次创建/test/sub1/sub-2节点时，没有触发事件。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005205943.png" alt="image-20211005205943178" style="zoom:50%;" /><h3 id="Zookeeper事件类型"><a href="#Zookeeper事件类型" class="headerlink" title="Zookeeper事件类型"></a>Zookeeper事件类型</h3><ul><li>None: 连接建立事件</li><li>NodeCreated: 节点创建 </li><li>NodeDeleted: 节点删除 </li><li>NodeDataChanged:节点数据变化 </li><li>NodeChildrenChanged:子节点列表变化 </li><li>DataWatchRemoved:节点监听被移除 </li><li>ChildWatchRemoved:子节点监听被移除</li></ul><h2 id="ACL-权限控制"><a href="#ACL-权限控制" class="headerlink" title="ACL 权限控制"></a>ACL 权限控制</h2><p>Zookeeper 的ACL( Access Control List ) 权限控制，可以控制节点的读写操作，保证数据的安全性。</p><p>Zookeeper ACL 权 限设置分为 3 部分组成，分别是</p><ul><li><p>权限模式(Scheme)</p><p>用来设置 ZooKeeper 服务器进行权限验证的方式。</p><p>ZooKeeper 的权限验证方式大体分为两种类型</p><ul><li><p>范围验证</p><p>ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。比如我们可以让一个 IP 地址为“ip:192.168.0.110”的机器对服务器上的某个数据节点具有写入的权限。或者也可以通过“ip:192.168.0.1/24”给一段 IP 地址的机器赋权。</p></li><li><p>口令验证</p><p>即用户名密码的方式。在 ZooKeeper 中这种验证方式是 Digest 认证，而 Digest 这种认证方式首先在客户端传送“username:password”这种形式的权限表示符后，ZooKeeper 服务端会对密码部分使用 SHA-1 和 BASE64 算法进行加密， 以保证安全性。</p></li><li><p>Super权限模式</p><p>Super可以认为是一种特殊的 Digest 认证。具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。</p></li></ul></li><li><p>授权对象(ID)</p><p>授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，</p><p>如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段;而如果使用 Digest 或 Super 方式，则对应于一个用户名。</p><p>如果是 World 模式，是授权系统中所有的用户。</p></li><li><p>权限信息 (Permission)。</p><p>权限就是指我们可以在数据节点上执行的操作种类，在 ZooKeeper 中已经定义好的权限有 5 种:</p><ul><li><p>数据节点(c: create)创建权限</p><p>授予权限的对象可以在数据节点下创建子节点;</p></li><li><p>数据节点(w: wirte)更新权限</p><p>授予权限的对象可以更新该数据节点</p></li><li><p>数据节点(r: read)读取权限</p><p>授予权限的对象可以读取该节点的内容以及子节点的列表信息</p></li><li><p>数据节点(d: delete)删除权限</p><p>授予权限的对象可以删除该数据节点的子节点</p></li><li><p>数据节点(a: admin)管理者权限</p><p>授予权限的对象可以对该数据节点体进行 ACL 权限设置</p></li></ul></li></ul><p><strong>命令</strong>:</p><p>getAcl:获取某个节点的acl权限信息</p><p>setAcl:设置某个节点的acl权限信息</p><p>addauth: 输入认证授权信息，相当于注册用户信息，注册时输入明文密码，zk将以密文的形式存储</p><p>可以通过系统参数zookeeper.skipACL=yes进行配置，默认是no,可以配置为true, 则配置过的 ACL将不再进行权限检测</p><h3 id="生成授权ID"><a href="#生成授权ID" class="headerlink" title="生成授权ID"></a>生成授权ID</h3><h4 id="代码生成ID"><a href="#代码生成ID" class="headerlink" title="代码生成ID"></a>代码生成ID</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSuperDigest</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException</span>&#123;</span><br><span class="line">String sId = DigestAuthenticationProvider.generateDigest(<span class="string">&quot;gj:test&quot;</span>);</span><br><span class="line">System.out.println(sId);<span class="comment">// gj:X/NSthOB0fD/OT6iilJ55WJVado=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="xshell-中生成"><a href="#xshell-中生成" class="headerlink" title="xshell 中生成"></a>xshell 中生成</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo ‐n &lt;user&gt;:&lt;password&gt; | openssl dgst ‐binary ‐sha1 | openssl base64</span><br></pre></td></tr></table></figure><h3 id="设置ACL"><a href="#设置ACL" class="headerlink" title="设置ACL"></a>设置ACL</h3><h4 id="节点创建的同时设置ACL"><a href="#节点创建的同时设置ACL" class="headerlink" title="节点创建的同时设置ACL"></a>节点创建的同时设置ACL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create [-s] [-e] [-c] path [data] [acl]</span><br><span class="line">create &#x2F;zk‐node data digest:gj:X&#x2F;NSthOB0fD&#x2F;OT6iilJ55WJVado&#x3D;:cdrwa </span><br></pre></td></tr></table></figure><h4 id="setAcl-设置"><a href="#setAcl-设置" class="headerlink" title="setAcl 设置"></a>setAcl 设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl &#x2F;zk‐node digest:gj:X&#x2F;NSthOB0fD&#x2F;OT6iilJ55WJVado&#x3D;:cdrwa</span><br></pre></td></tr></table></figure><p>添加授权信息后，不能直接访问，直接访问将报如下异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get &#x2F;zk‐node</span><br><span class="line">&#x2F;&#x2F; 异常信息:</span><br><span class="line">org.apache.zookeeper.KeeperException$NoAuthException:KeeperErrorCode&#x3D;NoAuth for &#x2F;zk‐node</span><br></pre></td></tr></table></figure><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>访问前需要添加授权信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addauth digest gj:test</span><br><span class="line">get &#x2F;zk‐node</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出</span><br><span class="line">datatest</span><br></pre></td></tr></table></figure><h4 id="auth-明文授权"><a href="#auth-明文授权" class="headerlink" title="auth 明文授权"></a>auth 明文授权</h4><p>使用之前需要先  <code>addauth digest username:password</code> 注册用户信息，后续可以直接用明文授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addauth digest u100:p100</span><br><span class="line">create &#x2F;node‐1 node1data auth:u100:p100:cdwra</span><br><span class="line">&#x2F;&#x2F; 这是u100用户授权信息会被zk保存，可以认为当前的授权用户为u100 </span><br><span class="line">get &#x2F;node‐1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出</span><br><span class="line">node1data</span><br></pre></td></tr></table></figure><h4 id="IP授权模式"><a href="#IP授权模式" class="headerlink" title="IP授权模式"></a>IP授权模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setAcl &#x2F;node-ip ip:192.168.0.102:cdrwa</span><br><span class="line">create &#x2F;node-ip ip:192.168.0.102:cdrwa</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 多个指定IP可以通过逗号分隔</span><br><span class="line">setAcl &#x2F;node-ip ip:IP1:rw,ip:IP2:a</span><br></pre></td></tr></table></figure><h4 id="Super-超级管理员模式"><a href="#Super-超级管理员模式" class="headerlink" title="Super 超级管理员模式"></a>Super 超级管理员模式</h4><p>这是一种特殊的Digest模式， 在Super模式下超级管理员用户可以对Zookeeper上的节点进行任何的操作。<br>需要在启动了上通过JVM 系统参数开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DigestAuthenticationProvider中定义</span><br><span class="line">‐Dzookeeper.DigestAuthenticationProvider.superDigest&#x3D;super: &lt;base64encoded(SHA1(password))</span><br></pre></td></tr></table></figure><h1 id="内存数据和持久化"><a href="#内存数据和持久化" class="headerlink" title="内存数据和持久化"></a>内存数据和持久化</h1><p>Zookeeper数据的组织形式为一个类似文件系统的数据结构，而这些数据都是存储在内存中的， 所以我们可以认为，Zookeeper是一个基于内存的小型数据库</p><h2 id="内存中的数据"><a href="#内存中的数据" class="headerlink" title="内存中的数据"></a>内存中的数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, DataNode&gt; nodes = <span class="keyword">new</span> ConcurrentHashMap&lt;String, DataNode&gt;();</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> WatchManager dataWatches = <span class="keyword">new</span> WatchManager();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> WatchManager childWatches = <span class="keyword">new</span> WatchManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataNode 是Zookeeper存储节点数据的最小单位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataNodeimplementsRecord</span></span>&#123; </span><br><span class="line">  <span class="keyword">byte</span> data[];</span><br><span class="line">Long acl;</span><br><span class="line">  <span class="keyword">public</span> StatPersisted stat;</span><br><span class="line"> <span class="keyword">private</span> Set&lt;String&gt; children = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h1><p>针对每一次客户端的事务操作，Zookeeper都会将他们记录到事务日志中，Zookeeper也会将数据变更应用到内存数据库中。</p><p>我们可以在zookeeper的主配置文件zoo.cfg 中配置内存中的数据持久化目录，也就是事务日志的存储路径 dataLogDir. </p><p>如果没有配置dataLogDir(非必填)，事务日志将存储到dataDir (必填项)目录</p><p>zookeeper提供了格式化工具可以进行数据查看事务日志数据 <code>org.apache.zookeeper.server.LogFormatter</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐classpath .:slf4j‐api‐1.7.25.jar:zookeeper‐3.5.8.jar:zookeeper‐jute‐3.5.8.jar org.apache.zookeeper.server.LogFormatter &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache‐zookeeper‐3.5.8‐bin&#x2F;data&#x2F;version‐2&#x2F;log.1</span><br></pre></td></tr></table></figure><p>如下是我本地的日志文件格式化效果</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005221921.png" alt="image-20211005221921580"></p><p>从左到右分别记录了操作时间，客户端会话ID，CXID,ZXID,操作类型，节点路径，节点数据(用 #+ascii 码表示)，节点版本。</p><p>Zookeeper进行事务日志文件操作的时候会频繁进行磁盘IO操作，事务日志的不断追加写操作会触发底层磁盘IO为文件开辟新的磁盘块，即磁盘Seek。为了提升磁盘IO的效率， Zookeeper在创建事务日志文件的时候就进行文件空间的预分配，即在创建文件的时候，就向操 作系统申请一块大一点的磁盘块。这个预分配的磁盘大小可以通过系统参数 zookeeper.preAllocSize 进行配置。</p><p>事务日志文件名为: log.&lt;当时最大事务ID&gt;，因为为日志文件时顺序写入的，所以这个最大事务 ID也将是整个事务日志文件中，最小的事务ID，日志满了即进行下一次事务日志文件的创建</p><h1 id="数据快照"><a href="#数据快照" class="headerlink" title="数据快照"></a>数据快照</h1><p>数据快照用于记录Zookeeper服务器上某一时刻的全量数据，并将其写入到指定的磁盘文件中。 可以通过配置snapCount配置每间隔事务请求个数，生成快照，数据存储在dataDir 指定的目录中。</p><p>可以通过如下方式进行查看快照数据，为了避免集群中所有机器在同一时间进行快照，实际的快照生成时机为事务数达到 </p><p><code>[snapCount/2 + 随机数(随机数范围为1 ~ snapCount/2 )]</code> 个数时开始快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐classpath .:slf4j‐api‐1.7.25.jar:zookeeper‐3.5.8.jar:zookeeper‐jute‐3.5.8.jar org.apache.zookeeper.server.SnapshotFormatter &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache‐zookeeper‐3.5.8‐bin&#x2F;data‐dir&#x2F;version‐2&#x2F;snapshot.0</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005222657.png" alt="image-20211005222657313" style="zoom:50%;" /><p>快照事务日志文件名为: snapshot.&lt;当时最大事务ID&gt;，日志满了即进行下一次事务日志文件的创建</p><p>有了事务日志，为啥还要快照数据？<br>快照数据主要时为了快速恢复， 事务日志文件是每次事务请求都会进行追加的操作，而快照是达到某种设定条件下的内存全量数据。所以通常快照数据是反应当时内存数据的状态。事务日志是更全面的数据，所以恢复数据的时候，可以先恢复快照数据，再通过增量恢复事务日志中的数据即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在了解Zookeeper之前，需要对分布式相关知识有一定了解，什么是分布式系统?&lt;/p&gt;
&lt;p&gt;通常情况 下，单个物理节点很容易达到性能，计算或者容量的瓶颈，所以这个时候就需要多个物理节点来 共同完成某项任务，一个分布式系统的本质是分布在不同网络或计算机上的程序组件，彼此通</summary>
      
    
    
    
    
    <category term="Zookeeper" scheme="https://tj-ever.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>MySQL MVCC及BufferPool机制</title>
    <link href="https://tj-ever.github.io/2021/10/05/MySQL%20MVCC%E5%8F%8ABufferPool%E6%9C%BA%E5%88%B6/"/>
    <id>https://tj-ever.github.io/2021/10/05/MySQL%20MVCC%E5%8F%8ABufferPool%E6%9C%BA%E5%88%B6/</id>
    <published>2021-10-04T16:00:00.000Z</published>
    <updated>2021-10-05T03:10:47.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVCC多版本并发控制机制"><a href="#MVCC多版本并发控制机制" class="headerlink" title="MVCC多版本并发控制机制"></a>MVCC多版本并发控制机制</h1><p>Mysql在可重复读隔离级别下，同样的sql查询语句在一个事务里多次执行查询结果相同，就算其它事务对数据有修改也不会影响当前事务sql语句的查询结果。 </p><p>这个隔离性就是靠<code>MVCC(Multi-Version Concurrency Control)</code>机制来保证的，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥，而在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实现的。</p><p>Mysql在读已提交和可重复读隔离级别下都实现了MVCC机制。</p><h1 id="undo日志版本链与read-view机制"><a href="#undo日志版本链与read-view机制" class="headerlink" title="undo日志版本链与read view机制"></a>undo日志版本链与read view机制</h1><p>undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005110050.png" alt="image-20211005110050358" style="zoom:50%;" /><p>在<strong>可重复读隔离级别</strong>，当事务开启，执行任何查询sql时会生成当前事务的一致性视图read-view，该视图在事务结束之前都不会变化(<strong>如果是读已提交隔离级别在每次执行查询sql时都会重新生成</strong>).</p><p>这个视图由执行查询时所有未提交事务id数组(数组里最小的id为min_id)和已创建的最大事务id(max_id)组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p><p>版本链比对规则:</p><ol><li>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的; </li><li>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若 row 的 trx_id 就是当前自己的事务是可见的);</li><li>如果 row 的 trx_id 落在黄色部分(min_id &lt;=trx_id&lt;= max_id)，那就包括两种情况<ol><li>若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自己的事务是可见的)</li><li>若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol></li></ol><p>对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的 trx_id，同时在该条记录的头信息(record header)里的(deleted_flag)标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数据。</p><p><strong>注意</strong>：begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作InnoDB表的语句， 事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。</p><p><strong>总结</strong>： MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。</p><h1 id="Innodb引擎SQL执行的BufferPool缓存机制"><a href="#Innodb引擎SQL执行的BufferPool缓存机制" class="headerlink" title="Innodb引擎SQL执行的BufferPool缓存机制"></a>Innodb引擎SQL执行的BufferPool缓存机制</h1><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211005110936.png" alt="image-20211005110808120"></p><p><strong>为什么Mysql不能直接更新磁盘上的数据而且设置这么一套复杂的机制来执行SQL了?</strong> </p><p>因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据性能可能相当差。</p><p>因为磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。 Mysql这套机制看起来复杂，但它可以保证每个更新请求都是更新内存BufferPool，然后顺序写日志文件，同时还能保证各种异常情况下的数据一致性。</p><p>更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是非常高的，要远高于随机读写磁盘文件。 正是通过这套机制，才能让MySQL数据库在较高配置的机器上每秒可以抗下几干的读写请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVCC多版本并发控制机制&quot;&gt;&lt;a href=&quot;#MVCC多版本并发控制机制&quot; class=&quot;headerlink&quot; title=&quot;MVCC多版本并发控制机制&quot;&gt;&lt;/a&gt;MVCC多版本并发控制机制&lt;/h1&gt;&lt;p&gt;Mysql在可重复读隔离级别下，同样的sql查询语句</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://tj-ever.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 事务及锁机制</title>
    <link href="https://tj-ever.github.io/2021/10/04/MySQL%20%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://tj-ever.github.io/2021/10/04/MySQL%20%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2021-10-03T16:00:00.000Z</published>
    <updated>2021-10-04T13:57:54.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数据库一般都会并发执行多个事务，多个事务可能会并发的对相同的一批数据进行增删改查操作，可能就会导致脏写、脏读、不可重复读、幻读这些问题。 这些问题的本质都是数据库的多事务并发问题，为了解决多事务并发问题，数据库设计了事务隔离机制、锁机制、MVCC多版本并发控制隔离机制，用一整套机制来解决多事务并发问题。</p><h1 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h1><p>事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。 </p><ul><li><p>原子性(Atomicity) </p><p>事务是一个原子操作单元，其对数据的修改,要么全都执行,要么全都不执行。</p></li><li><p>一致性(Consistent) </p><p>在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性。</p></li><li><p>隔离性(Isolation)</p><p>数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</p></li><li><p>持久性(Durable)</p><p>事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。</p></li></ul><h2 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h2><h3 id="更新丢失-Lost-Update-或脏写"><a href="#更新丢失-Lost-Update-或脏写" class="headerlink" title="更新丢失(Lost Update)或脏写"></a>更新丢失(Lost Update)或脏写</h3><p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。</p><h3 id="脏读-Dirty-Reads"><a href="#脏读-Dirty-Reads" class="headerlink" title="脏读(Dirty Reads)"></a>脏读(Dirty Reads)</h3><p>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。  </p><p>一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</p><h3 id="不可重读-Non-Repeatable-Reads"><a href="#不可重读-Non-Repeatable-Reads" class="headerlink" title="不可重读(Non-Repeatable Reads)"></a>不可重读(Non-Repeatable Reads)</h3><p>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了。这种现象就叫做“不可重复读”。  </p><p>一句话：事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性</p><h3 id="幻读-Phantom-Reads"><a href="#幻读-Phantom-Reads" class="headerlink" title="幻读(Phantom Reads)"></a>幻读(Phantom Reads)</h3><p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p><p>一句话:事务A读取到了事务B提交的新增数据，不符合隔离性</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004171656.png" alt="image-20211004171656811" style="zoom:50%;" /><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。 同时不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常看当前数据库的事务隔离级别</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置事务隔离级别</span></span><br><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">&#x27;REPEATABLE-READ&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别</p><h1 id="锁详解"><a href="#锁详解" class="headerlink" title="锁详解"></a>锁详解</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。 在数据库中，除了传统的计算资源(如CPU、RAM、I/O等)的争用以外，数据也是一种供需要用户共享的资 源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><ul><li><p>从性能上分为<strong>乐观锁(用版本对比来实现) **和 **悲观锁</strong> </p></li><li><p>从对数据库操作的类型分，分为<strong>读锁和写锁(都属于悲观锁)</strong></p><ul><li><p>读锁(共享锁，S锁(Shared))</p><p>针对同一份数据，多个读操作可以同时进行而不会互相影响 </p></li><li><p>写锁(排它锁，X锁(eXclusive))</p><p>当前写操作没有完成前，它会阻断其他写锁和读锁</p></li></ul></li><li><p>从对数据操作的粒度分，分为表锁和行锁</p></li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>每次操作锁住整张表。开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；<br>一般用在整表数据迁移的场景。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建表SQL</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mylock`</span> ( <span class="string">`id`</span> <span class="built_in">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT, <span class="string">`NAME`</span> <span class="built_in">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, PRIMARY <span class="keyword">KEY</span> ( <span class="string">`id`</span> ) ) <span class="keyword">ENGINE</span> = MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"><span class="comment">#插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`mylock`</span> ( <span class="string">`id`</span>, <span class="string">`NAME`</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`mylock`</span> ( <span class="string">`id`</span>, <span class="string">`NAME`</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`mylock`</span> ( <span class="string">`id`</span>, <span class="string">`NAME`</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;c&#x27;</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`mylock`</span> ( <span class="string">`id`</span>, <span class="string">`NAME`</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;d&#x27;</span> );</span><br></pre></td></tr></table></figure><ul><li><p>手动增加表锁</p><p>lock table 表名称 read(write),表名称2 read(write);</p></li><li><p>查看表上加过的锁 </p><p>show open tables;</p></li><li><p>删除表锁 </p><p>unlock tables;</p></li></ul><h4 id="加读锁-MyISAM"><a href="#加读锁-MyISAM" class="headerlink" title="加读锁(MyISAM)"></a>加读锁(MyISAM)</h4><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004192720.png" alt="image-20211004192720009" style="zoom:50%;" /><p>当前session和其他session都可以读该表 </p><p>当前session中插入或者更新锁定的表都会报错，其他session插入或更新则会等待</p><h4 id="加写锁-MyISAM"><a href="#加写锁-MyISAM" class="headerlink" title="加写锁(MyISAM)"></a>加写锁(MyISAM)</h4><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004192852.png" alt="image-20211004192852003" style="zoom:50%;" /><p>当前session对该表的增删改查都没有问题，其他session对该表的所有操作被阻塞</p><h4 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h4><p>对MyISAM表的读操作(加读锁) ，不会阻寒其他进程对同一表的读请求，但会阻赛对同一表的写请求。只有当读锁释放后才会执行其它进程的写操作。<br>对MylSAM表的写操作(加写锁) ，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后才会执行其它进程的读写操作</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>每次操作锁住一行数据。开销大，加锁慢，会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p><p>InnoDB与MYISAM的最大不同有两点:</p><ul><li>InnoDB支持事务(TRANSACTION) </li><li>InnoDB支持行级锁</li></ul><h3 id="行锁演示"><a href="#行锁演示" class="headerlink" title="行锁演示"></a>行锁演示</h3><p>一个session开启事务更新不提交，另一个session更新同一条记录会阻塞，更新不同记录不会阻塞</p><p>总结:</p><ul><li>MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁。在执行update、insert、delete操作会自动给涉及的表加写锁。 </li><li>InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行锁。</li></ul><p><strong>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</strong></p><h1 id="行锁与事务隔离级别案例分析"><a href="#行锁与事务隔离级别案例分析" class="headerlink" title="行锁与事务隔离级别案例分析"></a>行锁与事务隔离级别案例分析</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`account`</span> ( <span class="string">`id`</span> <span class="built_in">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT, <span class="string">`name`</span> <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="string">`balance`</span> <span class="built_in">INT</span> ( <span class="number">11</span> ) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, PRIMARY <span class="keyword">KEY</span> ( <span class="string">`id`</span> ) ) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`account`</span> ( <span class="string">`name`</span>, <span class="string">`balance`</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( <span class="string">&#x27;lilei&#x27;</span>, <span class="string">&#x27;450&#x27;</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`account`</span> ( <span class="string">`name`</span>, <span class="string">`balance`</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( <span class="string">&#x27;hanmei&#x27;</span>, <span class="string">&#x27;16000&#x27;</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span>.<span class="string">`account`</span> ( <span class="string">`name`</span>, <span class="string">`balance`</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( <span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;2400&#x27;</span> );</span><br></pre></td></tr></table></figure><h2 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h2><ol><li><p>(客户端A)打开一个客户端A，并设置当前事务模式为<code>read uncommitted</code>(读未提交)，查询表account的初始值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">&#x27;read-uncommitted&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004200234.png" alt="image-20211004200234824" style="zoom:50%;" /></li><li><p>(客户端B)在客户端A的事务提交之前，打开另一个客户端B，更新表account:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004201606.png" alt="image-20211004201049993" style="zoom:50%;" /></li><li><p>(客户端A)这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004215749.png" alt="image-20211004201324201" style="zoom:50%;" /></li><li><p>(客户端B)一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004202032.png" alt="image-20211004202032019" style="zoom:50%;" /></li><li><p>(客户端A)此时在客户端A查询，会发现实际值已经改变。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004202755.png" alt="image-20211004202755939" style="zoom:50%;" /><p><strong>但是，实际java程序中，此时我们拿到的值并不会实时更新，拿到的值还是回滚之前的值，这是就产生了脏数据。</strong></p><p>但是我们继续在A客户端执行如下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance - <span class="number">50</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">account</span>;</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004202839.png" alt="image-20211004202838964" style="zoom:50%;" /><p>数据没有变成350是因为我们的sql语句是用当前的balance值去操作的，所以操作的是最新的值。</p><p>但如果是用java代码去操作，操作之前拿到的值还是400，并不能感知到其他事务的改变，所以操作后可能会变成350</p><p><strong>要想解决这个问题可以采用读已提交的隔离级别</strong></p></li></ol><h2 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h2><ol><li><p>(客户端A)打开一个客户端A，并设置当前事务模式为<code>read committed</code>(未提交读)，查询表account的所有记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">&#x27;read-committed&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004203640.png" alt="image-20211004203640617" style="zoom:50%;" /></li><li><p>(客户端B)在客户端A的事务提交之前，打开另一个客户端B，更新表account</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004203847.png" alt="image-20211004203847927" style="zoom:50%;" /></li><li><p>(客户端A)这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，<strong>解决了脏读问题</strong></p><p><strong>与读未提交不同，数据还是450</strong></p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004204041.png" alt="image-20211004204041464" style="zoom:50%;" /></li><li><p>(客户端B)客户端B的事务提交</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004205431.png" alt="image-20211004205431931" style="zoom:50%;" /></li><li><p>(客户端A)客户端A执行与上一步相同的查询，<strong>结果与上一步不一致，即产生了不可重复读的问题</strong></p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004205644.png" alt="image-20211004205644110" style="zoom:50%;" /></li></ol><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><ol><li><p>(客户端A)打开一个客户端A，并设置当前事务模式为<code>read committed</code>(未提交读)，查询表account的所有记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">&#x27;repeatable-read&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004210652.png" alt="image-20211004210652468" style="zoom:50%;" /></li><li><p>(客户端B)在客户端A的事务提交之前，打开另一个客户端B，更新表account并提交</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004210755.png" alt="image-20211004210755506" style="zoom:50%;" /></li><li><p>(客户端A)在客户端A查询表account的所有记录，与步骤1查询结果一致，没有出现不可重复读的问题</p><img src="/Users/tianjie/Library/Application Support/typora-user-images/image-20211004211124147.png" alt="image-20211004211124147" style="zoom:50%;" /></li><li><p>(客户端A)在客户端A，接着执行如下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance - <span class="number">50</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>balance没有变成 400-50=350，lilei的balance值用的是步骤2中的350来算的，所以是300，数据的一致性倒是没有被破坏。</p><p><strong>可重复读的隔离级别下使用了MVCC(multi-version concurrency control)机制</strong></p><p><strong>select操作不会更新版本号， 是快照读(历史版本)；</strong></p><p><strong>insert、update和delete会更新版本号，是当前读(当前版本)。</strong></p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004211848.png" alt="image-20211004211848349" style="zoom:50%;" /></li><li><p>(客户端B)重新打开客户端B，插入一条新数据后提交</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004212129.png" alt="image-20211004212129173" style="zoom:50%;" /></li><li><p>(客户端A)在客户端A查询表account的所有记录，没有查出新增数据，所以没有出现幻读</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004212209.png" alt="image-20211004212209342" style="zoom:50%;" /></li><li><p>(客户端A)验证幻读，在客户端A执行如下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance=<span class="number">888</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>能更新成功，再次查询能查到客户端B新增的数据</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004212337.png" alt="image-20211004212337170" style="zoom:50%;" /></li></ol><h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><ol><li><p>(客户端A)打开一个客户端A，并设置当前事务模式为serializable，查询表account的初始值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">&#x27;serializable&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004213028.png" alt="image-20211004213028770" style="zoom:50%;" /></li><li><p>(客户端B)打开一个客户端B，并设置当前事务模式为serializable.</p><p>更新相同的id为1的记录会被阻塞等待，更新id 为2的记录可以成功，说明在串行模式下innodb的查询也会被加上行锁。 </p><p>如果客户端A执行的是一个范围查询，<strong>那么该范围内的所有行，包括每行记录所在的间隙区间范围(就算该行数据还未被插入也会加锁，这种是间隙锁)都会被加锁</strong>。</p><p><strong>此时如果客户端B在该范围内插入数据都会被阻塞，所以就避免了幻读。</strong></p><p>这种隔离级别并发性极低，开发中很少会用到。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004213330.png" alt="image-20211004213330495" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004213414.png" alt="image-20211004213414367" style="zoom:50%;" /></li></ol><h1 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁(Gap Lock)"></a>间隙锁(Gap Lock)</h1><p>间隙锁，锁的就是两个值之间的空隙。Mysql默认级别是repeatable-read，有办法解决幻读问题吗?</p><p>间隙锁 在某些情况下可以解决幻读问题。<br>假设account表里数据如下:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004213522.png" alt="image-20211004213522026" style="zoom:50%;" /><p>那么间隙就有 id 为 (3,10)，(10,20)，(20,正无穷) 这三个区间，<br>在Session_1下面执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">&#x27;zhangsan&#x27;</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">8</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt;<span class="number">18</span>;</span><br></pre></td></tr></table></figure><p><strong>则其他Session没法在这个范围所包含的所有行记录(包括间隙行记录)以及行记录所在的间隙里插入或修改任何数据，即id在 (3,20]区间都无法修改数据，注意最后那个20也是包含在内的。</strong><br><strong>间隙锁是在可重复读隔离级别下才会生效</strong>。</p><h1 id="临键锁-Next-key-Locks"><a href="#临键锁-Next-key-Locks" class="headerlink" title="临键锁(Next-key Locks)"></a>临键锁(Next-key Locks)</h1><p><strong>Next-Key Locks是行锁与间隙锁的组合。</strong></p><p><strong>像上面那个例子里的这个(3,20]的整个区间可以叫做临键锁。</strong></p><h1 id="无索引行锁会升级为表锁"><a href="#无索引行锁会升级为表锁" class="headerlink" title="无索引行锁会升级为表锁"></a><strong>无索引行锁会升级为表锁</strong></h1><p>锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁</p><p>session1 执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = <span class="number">800</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;lilei&#x27;</span>;</span><br></pre></td></tr></table></figure><p>session2 对该表任一行操作都会阻塞住。</p><p><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。</strong></p><p>锁定某一行还可以用<code>lock in share mode(共享锁)</code> 和<code>for update(排它锁)</code></p><p>例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_innodb_lock <span class="keyword">where</span> a = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>; </span><br></pre></td></tr></table></figure><p>这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交</p><p><strong>结论</strong></p><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更 高一下，但是在整体并发处理能力方面要远远优于MYISAM的表级锁定的。当系统并发量高的时候，Innodb 的整体性能和MYISAM相比就会有比较明显的优势了。 但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MYISAM高，甚至可能会更差。</p><h1 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h1><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span><span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>对各个状态量的说明如下:</p><ul><li>Innodb_row_lock_current_waits: 当前正在等待锁定的数量 </li><li>Innodb_row_lock_time: 从系统启动到现在锁定总时间长度 </li><li>Innodb_row_lock_time_avg: 每次等待所花平均时间 </li><li>Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花时间</li><li>Innodb_row_lock_waits:系统启动后到现在总共等待的次数</li></ul><p>对于这5个状态变量，比较重要的主要是:</p><p>Innodb_row_lock_time_avg (等待平均时长)</p><p>Innodb_row_lock_waits (等待总次数) </p><p>Innodb_row_lock_time(等待总时长)</p><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p><h1 id="查看INFORMATION-SCHEMA系统库锁相关数据表"><a href="#查看INFORMATION-SCHEMA系统库锁相关数据表" class="headerlink" title="查看INFORMATION_SCHEMA系统库锁相关数据表"></a>查看INFORMATION_SCHEMA系统库锁相关数据表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看事务</span></span><br><span class="line"><span class="keyword">select</span>*fromINFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line"><span class="comment">#查看锁</span></span><br><span class="line"><span class="keyword">select</span>*fromINFORMATION_SCHEMA.INNODB_LOCKS;</span><br><span class="line"><span class="comment">#查看锁等待</span></span><br><span class="line"><span class="keyword">select</span>*fromINFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">#释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到</span></span><br><span class="line"><span class="keyword">kill</span> trx_mysql_thread_id</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看锁等待详细信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>\G;</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">&#x27;repeatable-read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Session_1执行</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">#Session_2执行</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">#Session_1执行</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">#Session_2执行</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">#查看近期死锁日志信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>\G; </span><br></pre></td></tr></table></figure><p>大多数情况mysql可以自动检测死锁并回滚产生死锁的那个事务，但是有些情况mysql没法自动检测死锁</p><h1 id="锁优化建议"><a href="#锁优化建议" class="headerlink" title="锁优化建议"></a>锁优化建议</h1><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁合理设计索引，尽量缩小锁的范围<br>尽可能减少检索条件范围，<strong>避免间隙锁尽量，控制事务大小</strong>，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行尽可能低级别事务隔离</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;数据库一般都会并发执行多个事务，多个事务可能会并发的对相同的一批数据进行增删改查操作，可能就会导致脏写、脏读、不可重复读、幻读这些问题。 这</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://tj-ever.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引优化</title>
    <link href="https://tj-ever.github.io/2021/10/03/MySQL%20%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"/>
    <id>https://tj-ever.github.io/2021/10/03/MySQL%20%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</id>
    <published>2021-10-02T16:00:00.000Z</published>
    <updated>2021-10-04T13:56:19.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="示例表"><a href="#示例表" class="headerlink" title="示例表"></a>示例表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`employees`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">24</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line"><span class="string">`position`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line"><span class="string">`hire_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;入职时间&#x27;</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_name_age_position`</span> (<span class="string">`name`</span>,<span class="string">`age`</span>,<span class="string">`position`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">&#x27;员工记录表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(<span class="keyword">name</span>,age,<span class="keyword">position</span>,hire_time) <span class="keyword">VALUES</span>(<span class="string">&#x27;LiLei&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;manager&#x27;</span>,<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(<span class="keyword">name</span>,age,<span class="keyword">position</span>,hire_time) <span class="keyword">VALUES</span>(<span class="string">&#x27;HanMeimei&#x27;</span>, <span class="number">23</span>,<span class="string">&#x27;dev&#x27;</span>,<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(<span class="keyword">name</span>,age,<span class="keyword">position</span>,hire_time) <span class="keyword">VALUES</span>(<span class="string">&#x27;Lucy&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;dev&#x27;</span>,<span class="keyword">NOW</span>());</span><br><span class="line"></span><br><span class="line">‐‐ 插入一些示例数据</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> insert_emp;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_emp()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">while(i&lt;=100000)do</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employees(<span class="keyword">name</span>,age,<span class="keyword">position</span>) <span class="keyword">values</span>(<span class="keyword">CONCAT</span>(<span class="string">&#x27;zhuge&#x27;</span>,i),i,<span class="string">&#x27;dev&#x27;</span>);</span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> insert_emp();</span><br></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><ol><li><p><strong>联合索引第一个字段用范围不会走索引</strong></p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003203235.png" alt="image-20211003203235547"></p><p>结论:联合索引第一个字段就用范围查找不会走索引，mysql内部可能觉得第一个字段就用范围，结果集应该很大，回表效率不高，还不如就全表扫描</p></li><li><p><strong>强制走索引</strong></p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003203337.png" alt="image-20211003203337931"></p><p>结论:虽然使用了强制走索引让联合索引第一个字段范围查找也走索引，扫描的行rows看上去也少了点，但是最终查找效率不一定比全表扫描高，因为回表效率不高</p><p>做个小实验</p><p>首先关闭查询缓存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> query_cache_size=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> query_cache_type=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>使用mysql自行优化，耗时0.165s</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003204247.png" alt="image-20211003204247321" style="zoom:50%;" /><p>使用强制索引，耗时0.294s</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003204402.png" alt="image-20211003204402646" style="zoom:50%;" /></li></ol><ol start="3"><li><p><strong>覆盖索引优化</strong></p><p>扫描的字段都在覆盖索引上，此时范围查找可能会走索引</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003204615.png" alt="image-20211003204615344" style="zoom:50%;" /></li><li><p><strong>in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描</strong></p><p>复制employees到另一张表，只留三条记录，查询类型将会是全表扫描</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003204718.png" alt="image-20211003204718564" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003204839.png" alt="image-20211003204839949" style="zoom:50%;" /></li><li><p><strong>like KK% 一般情况都会走索引</strong></p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003205827.png" alt="image-20211003205827844" style="zoom:50%;" /></li></ol><p>   这里给大家补充一个概念，索引下推(Index Condition Pushdown，ICP)</p><p>   like KK%其实就是用到了索引下推优化<br>   对于辅助的联合索引(name,age,position)，正常情况按照最左前缀原则，</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;LiLei%&#x27;</span> <span class="keyword">AND</span> age = <span class="number">22</span> <span class="keyword">AND</span> <span class="keyword">position</span> =<span class="string">&#x27;manager&#x27;</span></span><br></pre></td></tr></table></figure><p>   这种情况只会走name字段索引，因为根据name字段过滤完，得到的索引行里的age和 position是无序的，无法很好的利用索引。</p><p>   在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是 ‘LiLei’ 开头的索引，然后拿这些索引对应的主键逐个回表，到主键索引上找出相应的记录，再比对age和position这两个字段的值是否符合。</p><p>   MySQL 5.6引入了索引下推优化，可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可以有效的减少回表次数。使用了索引下推优化后，<strong>上面那个查询在联合索引里匹配到名字是 ‘LiLei’ 开头的索引之后，同时还会在索引里过滤age和position这两个字段，拿着过滤完剩下的索引对应的主键id再回表查整行数据。</strong></p><p>   <strong>索引下推会减少回表次数，对于innodb引擎的表索引下推只能用于二级索引，innodb的主键索引(聚簇索引)树叶子节点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</strong></p><p>   为什么范围查找Mysql没有用索引下推优化?<br>   估计应该是Mysql认为范围查找过滤的结果集过大，like KK% 在绝大多数情况来看，过滤后的结果集比较小，所以这里Mysql选择给 like KK% 用了索引下推优化，当然这也不是绝对的，有时like KK% 也不一定就会走索引下推。</p><h1 id="Mysql索引选择"><a href="#Mysql索引选择" class="headerlink" title="Mysql索引选择"></a>Mysql索引选择</h1><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003211051.png" alt="image-20211003211051676" style="zoom:50%;" /><p>如果用name索引需要遍历name字段联合索引树，然后还需要根据遍历出来的主键值去主键索引树里再去查出最终数据，成本比全表扫描还高，可以用覆盖索引优化，这样只需要遍历name字段的联合索引树就能拿到所有结果，如下:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003211154.png" alt="image-20211003211154826" style="zoom:50%;" /><p>但是，下面这个sql却走了索引</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003211457.png" alt="image-20211003211457813" style="zoom:50%;" /><p>对于上面这两种 name&gt;’a’ 和 name&gt;’zzz’ 的执行结果，mysql最终是否选择走索引或者一张表涉及多个索引，mysql最终如何选择索引，我们可以用<strong>trace工具</strong>来一查究竟。</p><p>开启trace工具会影响mysql性能，所以只能临时分析sql使用，用完之后立即关闭</p><p>此处略过trace工具使用（我踏🐎觉得面试官也不会）</p><h1 id="常见sql深入优化"><a href="#常见sql深入优化" class="headerlink" title="常见sql深入优化"></a>常见sql深入优化</h1><h2 id="Order-by与Group-by优化"><a href="#Order-by与Group-by优化" class="headerlink" title="Order by与Group by优化"></a>Order by与Group by优化</h2><ol><li><p>case1</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003212147.png" alt="image-20211003212147546" style="zoom:50%;" /><p>利用最左前缀法则:中间字段不能断，因此查询用到了name索引，从key_len=74也能看出，age索引列用在排序过程中，因为Extra字段里没有using filesort</p></li><li><p>case2</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003214116.png" alt="image-20211003214011350"></p><p>从explain的执行结果来看:key_len=74，查询使用了name索引，由于用了position进行排序，跳过了 age，出现了Using filesort。</p></li><li><p>case3</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003215700.png" alt="image-20211003215700820"></p><p>查找只用到索引name，age和position用于排序，无Using filesort。</p></li><li><p>case4</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003215755.png" alt="image-20211003215755741"></p><p>和Case 3中explain的执行结果一样，但是出现了Using filesort，因为索引的创建顺序为 name,age,position，但是排序的时候age和position颠倒位置了。</p></li><li><p>case5</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003220032.png" alt="image-20211003220032127"></p><p>与Case 4对比，在Extra中并未出现Using filesort，因为age为常量，在排序中被优化，所以索引未颠倒， 不会出现Using filesort。</p></li><li><p>case6</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003220306.png" alt="image-20211003220306344"></p><p>虽然排序的字段列与索引顺序一样，且order by默认升序，这里position desc变成了降序，导致与索引的排序方式不同，从而产生Using filesort。</p><p><strong>Mysql8以上版本有降序索引可以支持该种查询方式。</strong></p></li><li><p>case7</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004215616.png" alt="image-20211003220546261"></p><p>对于排序来说，多个相等条件也是范围查询</p></li><li><p>case8</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003220906.png" alt="image-20211003220906230"></p><p>这种情况可以用覆盖索引优化</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003221538.png" alt="image-20211003221538426"></p></li></ol><h2 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h2><ul><li>MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。</li><li>order by满足两种情况会使用Using index。<ul><li>order by语句使用索引最左前列。</li><li>使用where子句与order by子句条件列组合满足索引最左前列。</li></ul></li><li> 尽量在索引列上完成排序，遵循索引建立(索引创建的顺序)时的最左前缀法则。</li><li>如果order by的条件不在索引列上，就会产生Using filesort。</li><li>能用覆盖索引尽量用覆盖索引</li><li>group by与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最左前缀法则。对于group by的优化如果不需要排序的可以加上order by null禁止排序。注意，where高于having，能写在where中的限定条件就不要去having限定了。</li></ul><h2 id="Using-filesort文件排序"><a href="#Using-filesort文件排序" class="headerlink" title="Using filesort文件排序"></a>Using filesort文件排序</h2><p>filesort文件排序方式</p><ul><li><p>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可以看到sort_mode信息里显示</p><p><code>&lt; sort_key, additional_fields &gt;</code>或者<code>&lt; sort_key, packed_additional_fields &gt;</code></p></li><li><p>双路排序(又叫回表排序模式)：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段;用trace工具 可以看到sort_mode信息里显示<code>&lt; sort_key, rowid &gt;</code></p></li></ul><p>MySQL 通过比较系统变量 max_length_for_sort_data(默认1024字节) 的大小和需要查询的字段总大小来判断使用哪种排序模式。</p><p>如果字段的总长度小于max_length_for_sort_data ，那么使用 单路排序模式; 如果字段的总长度大于max_length_for_sort_data ，那么使用双路排序模式。</p><h3 id="单路排序过程"><a href="#单路排序过程" class="headerlink" title="单路排序过程"></a><strong>单路排序过程</strong></h3><ol><li><p>从索引name找到第一个满足 name = ‘LiLei’ 条件的主键 id</p></li><li><p>根据主键 id 取出整行，取出所有字段的值，存入 sort_buffer 中</p></li><li><p>从索引name找到下一个满足 name = ‘LiLei’ 条件的主键 id</p></li><li><p>重复步骤 2、3 直到不满足 name = ‘LiLei’</p></li><li><p>对 sort_buffer 中的数据按照字段 position 进行排序</p></li><li><p>返回结果给客户端</p></li></ol><h3 id="双路排序过程"><a href="#双路排序过程" class="headerlink" title="双路排序过程:"></a>双路排序过程:</h3><ol><li>从索引 name 找到第一个满足 name = ‘LiLei’ 的主键id</li><li>根据主键 id 取出整行，把排序字段 position 和主键 id 这两个字段放到 sort buffer 中</li><li>从索引 name 取下一个满足 name = ‘LiLei’ 记录的主键 id</li><li>重复 3、4 直到不满足 name = ‘LiLei’</li><li>对 sort_buffer 中的字段 position 和主键 id 按照字段 position 进行排序</li><li>遍历排序好的 id 和字段 position，按照 id 的值回到原表中取出所有字段的值返回给客户端</li></ol><p>其实对比两个排序模式，<strong>单路排序会把所有需要查询的字段都放到 sort buffer 中</strong>，而<strong>双路排序只会把主键和需要排序的字段放到 sort buffer 中</strong>进行排序，然后再通过主键回到原表查询需要的字段。</p><p>如果 MySQL 排序内存 sort_buffer 配置的比较小并且没有条件继续增加了，可以适当把 max_length_for_sort_data 配置小点，让优化器选择使用双路排序算法，可以在sort_buffer 中一次排序更多的行，只是需要再根据主键回到原表取数据。</p><p>如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器优先选择全字段排序(单路排序)，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。</p><p>所以，MySQL通过 max_length_for_sort_data 这个参数来控制排序，在不同场景使用不同的排序模式， 从而提升排序效率。</p><p>注意，如果全部使用sort_buffer内存排序一般情况下效率会高于磁盘文件排序，但不能因为这个就随便增大sort_buffer(默认1M)，mysql很多参数设置都是做过优化的，不要轻易调整。</p><h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><ol><li><p>代码先行，索引后上<br> 一般等到主体业务功能开发完毕，把涉及到该表相关sql都要拿出来分析之后再建立索引。</p></li><li><p>联合索引尽量覆盖条件</p><p>比如可以设计一个或者两三个联合索引(尽量少建单值索引)，让每一个联合索引都尽量去包含sql语句里的 where、order by、group by的字段，还要确保这些联合索引的字段顺序尽量满足sql查询的最左前缀原则</p></li><li><p>不要在小基数字段上建立索引 </p><p>索引基数是指这个字段在表里总共有多少个不同的值，比如一张表总共100万行记录，其中有个性别字段， 其值不是男就是女，那么该字段的基数就是2。 如果对这种小基数字段建立索引的话，还不如全表扫描了，因为你的索引树里就包含男和女两种值，根本没法进行快速的二分查找，那用索引就没有太大的意义了。 一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，那么才能发挥出B+树快速二分查找的优势来</p></li><li><p>长字符串我们可以采用前缀索引</p><p>尽量对字段类型较小的列设计索引，比如说什么tinyint之类的，因为字段类型较小的话，占用磁盘空间也会比较小，此时你在搜索的时候性能也会比较好一点。 当然，这个所谓的字段类型小一点的列，也不是绝对的，很多时候你就是要针对varchar(255)这种字段建立索引，哪怕多占用一些磁盘空间也是有必要的。 对于这种varchar(255)的大字段可能会比较占用磁盘空间，可以稍微优化下，比如针对这个字段的前20个字符建立索引，类似于 KEY <code>index(name(20),age,position)</code></p><p>此时你在where条件里搜索的时候，如果是根据name字段来搜索，那么此时就会先到索引树里根据name 字段的前20个字符去搜索，定位到之后前20个字符的前缀匹配的部分数据之后，再回到聚簇索引提取出来完整的name字段值进行比对。<br>但是假如你要是order by name，那么此时你的name因为在索引树里仅仅包含了前20个字符，所以这个排序是没法用上索引的， group by也是同理。所以这里大家要对前缀索引有一个了解。</p></li><li><p>where与order by冲突时优先where</p><p>一般这种时候往往都是让where条件去使用索引来快速筛选出来一部分指定的数据，接着再进行排序。 因为大多数情况基于索引进行where筛选往往可以最快速度筛选出你要的少部分数据，然后做排序的成本可能会小很多。</p></li><li><p>基于慢sql查询做优化</p><p>可以根据监控后台的一些慢sql，针对这些慢sql查询做特定的索引优化。 </p><p>关于慢sql查询不清楚的可以参考这篇文章:<a href="https://blog.csdn.net/qq_40884473/article/details/89455740">https://blog.csdn.net/qq_40884473/article/details/89455740</a></p></li></ol><h1 id="索引设计实战"><a href="#索引设计实战" class="headerlink" title="索引设计实战"></a>索引设计实战</h1><p>以社交场景APP来举例，我们一般会去搜索一些好友，这里面就涉及到对用户信息的筛选，这里肯定就是对用户user表搜索了.</p><p>这个表一般来说数据量会比较大，我们先不考虑分库分表的情况，比如，我们一般会筛选地区(省市)，性别，年龄，身高，爱好之类的，有的APP可能用户还有评分，比如用户的受欢迎程度评分，我们可能还会根据评分来排序等等。 </p><p>对于后台程序来说除了过滤用户的各种条件，还需要分页之类的处理，可能会生成类似sql语句执行: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> xx <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> xx=xx <span class="keyword">and</span> xx=xx <span class="keyword">order</span> <span class="keyword">by</span> xx <span class="keyword">limit</span> xx,xx </span><br></pre></td></tr></table></figure><p>对于这种情况如何合理设计索引了，比如用户可能经常会根据省市优先筛选同城的用户，还有根据性别去筛选，那我们是否应该设计一个联合索引 <code>(province,city,sex)</code> 。这些字段好像基数都不大，其实是应该的， 因为这些字段查询太频繁了。</p><p>假设又有用户根据年龄范围去筛选了，比如</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where province=xx and city=xx and age&gt;=xx and age&lt;=xx</span><br></pre></td></tr></table></figure><p>我们尝试着把age字段加入联合索引 <code>(province,city,sex,age)</code>，注意，一般这种范围查找的条件都要放在最后，之前讲过联合索引范围之后条件的是不能用索引的，但是对于当前这种情况依然用不到age 这个索引字段，因为用户没有筛选sex字段，那怎么优化了?</p><p>其实我们可以这么来优化下sql的写法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where province=xx and city=xx and sex in (&#x27;female&#x27;,&#x27;male&#x27;) and age&gt;=xx and age&lt;=xx </span><br></pre></td></tr></table></figure><p>对于爱好之类的字段也可以类似sex字段处理，所以可以把爱好字段也加入索引 <code>(province,city,sex,hobby,age)</code> 假设可能还有一个筛选条件，比如要筛选最近一周登录过的用户，一般大家肯定希望跟活跃用户交友了，这样能尽快收到反馈，对应后台sql可能是这样:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where province=xx and city=xx and sex in (&#x27;female&#x27;,&#x27;male&#x27;) and age&gt;=xx and age&lt;=xx and latest_login_time&gt;= xx</span><br></pre></td></tr></table></figure><p>那我们是否能把 latest_login_time 字段也加入索引了?比如 <code>(province,city,sex,hobby,age,latest_login_time)</code> ，显然是不行的，那怎么来优化这种情况了?</p><p>其实我们可以试着再设计一个字段<code>is_login_in_latest_7_days</code>，用户如果一周内有登录值就为1，否则为0，那么我们就可以把索引设计成 <code>(province,city,sex,hobby,is_login_in_latest_7_days,age)</code> 来满足上面那种场景了</p><p>一般来说，通过这么一个多字段的索引是能够过滤掉绝大部分数据的，就保留小部分数据下来基于磁盘文件进行order by语句的排序，最后基于limit进行分页，那么一般性能还是比较高的。 不过有时可能用户会这么来查询，就查下受欢迎度较高的女性，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where sex = &#x27;female&#x27; order by score limit xx,xx</span><br></pre></td></tr></table></figure><p>那么上面那个索引是很难用上的，不能把太多的字段以及太多的值都用 in 语句拼接 到sql里的，那怎么办了?</p><p>其实我们可以再设计一个辅助的联合索引，比如 (sex,score)，这样就能满足查询要求了。</p><p> 以上就是一些索引设计的思路，核心思想就是，尽量利用一两个复杂的多字段联合索引，抗下80%以上的查询，然后用一两个辅助索引尽量抗下剩余的一些非典型查询，保证这种大数据量表的查询尽 可能多的都能充分利用索引，这样就能保证查询速度和性能.</p><h1 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h1><p>很多时候我们业务系统实现分页功能可能会用如下sql实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。</p><ul><li><p><strong>根据自增且连续的主键排序的分页查询</strong></p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004000504.png" alt="image-20211004000504103" style="zoom:50%;" /><p>该 SQL 表示查询从第 90001开始的五行数据，没添加单独 order by，表示通过主键排序。我们再看表 employees ，因 为主键是自增    并且连续的，所以可以改写成按照主键去查询从第 90001开始的五行数据，如下:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004000424.png" alt="image-20211004000424861" style="zoom:50%;" /><p>显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。</p><p><strong>但是，这条改写的SQL 在很多场景并不实用，因为表中可能某些记录被删后，主键空缺，导致结果不一致</strong></p><p>这种改写得满 足以下两个条件:</p><ol><li>主键自增且连续</li><li>结果是按照主键排序的</li></ol></li></ul><ul><li><p>根据非主键字段排序的分页查询</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004001016.png" alt="image-20211004001016734"></p><p>发现并没有使用 name 字段的索引(key 字段对应的值为 null)，</p><p>具体原因：扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引。</p><p>优化：让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，</p><p>SQL 改写如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees e <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> employees <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">5</span>) ed <span class="keyword">on</span> e.id = ed.id;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004001500.png" alt="image-20211004001500651"></p><p>原 SQL 使用的是 filesort 排序，而优化后的 SQL 使用的是索引排序。</p></li></ul><h1 id="Join关联查询优化"><a href="#Join关联查询优化" class="headerlink" title="Join关联查询优化"></a>Join关联查询优化</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例表:</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">INT</span> ( <span class="number">11</span> ) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">INT</span> ( <span class="number">11</span> ) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> ( <span class="string">`id`</span> ),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_a`</span> ( <span class="string">`a`</span> ) </span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 <span class="keyword">LIKE</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 往t1表插入1万行记录</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line"><span class="keyword">EXISTS</span> insert_t1;</span><br><span class="line"></span><br><span class="line">delimiter;;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_t1 () <span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">i <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> i = <span class="number">1</span>;</span><br><span class="line">WHILE</span><br><span class="line">( i &lt;= 10000 ) DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 ( a, b )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( i, i );</span><br><span class="line"><span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span>;;</span><br><span class="line"></span><br><span class="line">delimiter;</span><br><span class="line"><span class="keyword">CALL</span> insert_t1 ();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 往 t2表插入 100行记录</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line"><span class="keyword">EXISTS</span> insert_t2;</span><br><span class="line"></span><br><span class="line">delimiter;;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_t2 () <span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">i <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> i = <span class="number">1</span>;</span><br><span class="line">WHILE</span><br><span class="line">( i &lt;= 100 ) DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t2 ( a, b )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( i, i );</span><br><span class="line"><span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span>;;</span><br><span class="line"></span><br><span class="line">delimiter;</span><br><span class="line"><span class="keyword">CALL</span> insert_t2 ();</span><br></pre></td></tr></table></figure><p>mysql的表关联常见有两种算法</p><ol><li>Nested-Loop Join 算法</li><li>Block Nested-Loop Join 算法</li></ol><h2 id="嵌套循环连接-Nested-Loop-Join-NLJ"><a href="#嵌套循环连接-Nested-Loop-Join-NLJ" class="headerlink" title="嵌套循环连接 Nested-Loop Join(NLJ)"></a>嵌套循环连接 Nested-Loop Join(NLJ)</h2><p>一次一行循环地从第一张表(称为驱动表)中读取行，在这行数据中取到关联字段，根据关联字段在另一张表(被驱动表)里取出满足条件的行，然后取出两张表的结果合集。</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004003455.png" alt="image-20211004003455650"></p><p>从执行计划中可以看到这些信息:</p><ul><li><p>驱动表是 t2，被驱动表是 t1。先执行的就是驱动表(执行计划结果的id如果一样则按从上到下顺序执行sql);优化器一般会优先选择小表做驱动表。所以使用 inner join 时，排在前面的表并不一定就是驱动表。</p></li><li><p>当使用left join时，左表是驱动表，右表是被驱动表，当使用right join时，右表时驱动表，左表是被驱动表， 当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表。</p></li><li><p>使用了 NLJ算法。一般 join 语句中，如果执行计划 Extra 中未出现 Using join buffer 则表示使用的 join 算法是 NLJ。</p></li></ul><p>上面sql的大致流程如下:</p><ol><li>从表 t2 中读取一行数据(如果t2表有查询过滤条件的，会从过滤结果里取出一行数据); </li><li>从第 1 步的数据中，取出关联字段 a，到表 t1 中查找;</li><li>取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端;</li><li>重复上面 3 步。</li></ol><p>整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100 行)。因此整个过程扫描了 200 行。 如果被驱动表的关联字段没索引，使用NLJ算法性能会比较低，mysql会选择Block Nested-Loop Join 算法。</p><h2 id="基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL"><a href="#基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL" class="headerlink" title="基于块的嵌套循环连接 Block Nested-Loop Join(BNL)"></a>基于块的嵌套循环连接 Block Nested-Loop Join(BNL)</h2><p>把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比。</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211004153011.png" alt="image-20211004153011306"></p><p>Extra 中 的Using join buffer (Block Nested Loop)说明该关联查询使用的是 BNL 算法。</p><p>上面sql的大致流程如下:</p><ol><li>把 t2 的所有数据放入到 join_buffer 中</li><li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比 </li><li>返回满足 join 条件的数据</li></ol><p>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。<br>这个例子里表 t2 才 100 行，要是表 t2 是一个大表，join_buffer 放不下怎么办呢?</p><p>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t2 的所有数据话，策略很简单， 就是分段放。<br>比如 t2 表有1000行记录， join_buffer 一次只能放800行数据，那么执行过程就是先往 join_buffer 里放800行记录，然 后从 t1 表里取数据跟 join_buffer 中数据对比得到部分结果，然后清空 join_buffer ，再放入 t2 表剩余200行记录，再从 t1 表里取数据跟 join_buffer 中数据对比。所以就多扫了一次 t1 表。</p><p><strong>被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join 呢?</strong><br>如果上面第二条sql使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是磁盘扫描。 很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，BNL的内存计算会快得多。 <strong>因此MySQL对于被驱动表的关联字段没索引的关联查询，一般都会使用 BNL 算法。如果有索引一般选择 NLJ 算法，有 索引的情况下 NLJ 算法比 BNL算法性能更高</strong></p><h1 id="关联sql优化"><a href="#关联sql优化" class="headerlink" title="关联sql优化"></a>关联sql优化</h1><ul><li>关联字段加索引，让mysql做join操作时尽量选择NLJ算法</li><li>小表驱动大表，写多表连接sql时如果明确知道哪张表是小表可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间</li></ul><blockquote><p>straight_join功能同join类似，但能让左边的表来驱动右边的表，能改表优化器对于联表查询的执行顺序。<br>比如:select * from t2 straight_join t1 on t2.a = t1.a; 代表指定mysql选 t2 表作为驱动表。</p></blockquote><ul><li><p>straight_join只适用于inner join，并不适用于left join，right join。(因为left join，right join已经代表指 定了表的执行顺序)</p></li><li><p>尽可能让优化器去判断，因为大部分情况下mysql优化器是比人要聪明的。使用straight_join一定要慎重，因为部分情况下人为指定的执行顺序并不一定会比优化引擎要靠谱。</p></li></ul><p><strong>对于小表定义的明确</strong><br>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</p><h1 id="in和exsits优化"><a href="#in和exsits优化" class="headerlink" title="in和exsits优化"></a>in和exsits优化</h1><p>原则:<strong>小表驱动大表</strong>，即小的数据集驱动大的数据集</p><h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p>当B表的数据集小于A表的数据集时，in优于exists</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B)</span><br><span class="line"></span><br><span class="line"><span class="comment">#等价于:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B)&#123;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> A.id = B.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h2><p>当A表的数据集小于B表的数据集时，exists优于in </p><p>将主查询A的数据，放到子查询B中做条件验证，根据验证结果(true或false)来决定主查询的数据是否保留</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id) </span><br><span class="line"></span><br><span class="line"><span class="comment">#等价于:</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">select</span> * <span class="keyword">from</span> A)&#123;</span><br><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#A表与B表的ID字段应建立索引</span></span><br></pre></td></tr></table></figure><ul><li>EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换,官方说法是实际执行时会忽略SELECT清单,因此没有区别</li><li>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比</li><li>EXISTS子查询往往也可以用JOIN来代替，何种最优需要具体问题具体分析</li></ul><h1 id="count-查询优化"><a href="#count-查询优化" class="headerlink" title="count(*)查询优化"></a>count(*)查询优化</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">‐‐ 临时关闭mysql查询缓存，为了查看sql多次执行的真实时间</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> query_cache_size=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> query_cache_type=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> employees;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> employees;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">name</span>) <span class="keyword">from</span> employees;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure><p>注意:以上4条sql只有根据某个字段count不会统计字段为null值的数据行</p><p>四个sql的执行计划一样，说明这四个sql执行效率应该差不多</p><ul><li><p>字段有索引</p><p>count(*<em>)≈count(1 ) &gt; count(字段) &gt; count(主键 id)</em></p><p> 字段有索引，count(字段)统计走二级索引，二级索引存储数据比主键索引少，所以count(字段)&gt;count(主键 id)</p></li><li><p>字段无索引</p><p>count(*)≈count(1) &gt; count(主键 id) &gt; count(字段) </p><p>字段没有索引count(字段)统计走不了索引， count(主键 id)还可以走主键索引，所以count(主键 id) &gt; count(字段)</p><p>count(1)跟count(字段)执行过程类似，不过count(1)不需要取出字段统计，就用常量1做统计，count(字段)还需要取出字段，所以理论上count(1)比count(字段)会快一点。</p><p>count(<em>) 是例外，mysql并不会把全部字段取出来，而是专门做了优化，不取值，按行累加，效率很高，所以不需要用 count(列名)或count(常量)来替代 count(</em>)。 </p><p>为什么对于count(id)，mysql最终选择辅助索引而不是主键聚集索引?因为二级索引相对主键索引存储数据更少，检索性能应该更高，mysql内部做了点优化(应该是在5.7版本才优化)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;示例表&quot;&gt;&lt;a href=&quot;#示例表&quot; class=&quot;headerlink&quot; title=&quot;示例表&quot;&gt;&lt;/a&gt;示例表&lt;/h1&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://tj-ever.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 内部结构 BinLog</title>
    <link href="https://tj-ever.github.io/2021/09/29/MySQL%20%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%20BinLog/"/>
    <id>https://tj-ever.github.io/2021/09/29/MySQL%20%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%20BinLog/</id>
    <published>2021-09-28T16:00:00.000Z</published>
    <updated>2021-10-03T12:15:10.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的内部组件结构"><a href="#MySQL的内部组件结构" class="headerlink" title="MySQL的内部组件结构"></a>MySQL的内部组件结构</h1><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929164002.png" alt="image-20210929164002941" style="zoom:50%;" /><p>MySQL 可以分为 Server 层和存储引擎层两部分。</p><h2 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h2><p>主要包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数 (如日期、时间、数学和加密函数等)，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><h2 id="Store层"><a href="#Store层" class="headerlink" title="Store层"></a>Store层</h2><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。也就是说如果我们在create table时不指定表的存储引擎类型,默认会给你设置存储引擎为InnoDB。</p><h2 id="示例库"><a href="#示例库" class="headerlink" title="示例库"></a>示例库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line"> <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">9</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><p>MySQL是开源的，有非常多种类的客户端:navicat,mysql front,jdbc,SQLyog等。这些客户端要向mysql发起通信都必须先跟Server端建立通信连接，而建立连接的工作就是有连接器完成的。</p><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p><p>连接命令一般是这么写的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]<span class="comment"># mysql ‐h host[数据库地址] ‐u root[用户] ‐p root[密码] ‐P 3306</span></span><br></pre></td></tr></table></figure><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，</p><p>这个时候用的就是你输入的用户名和密码。</p><p>1、如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。 </p><p>2、如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</p><p>这就意味着，<strong>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限</strong>。修改完成后，只有再新建的连接才会使用新的权限设置。用户的权限表在系统表空间的mysql的user表中。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929172255.png" alt="image-20210929172255162" style="zoom:50%;" /><p>修改user密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//创建新用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line">//赋权限,%表示所有host</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;%&#x27;</span>; </span><br><span class="line">//刷新数据库</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span> </span><br><span class="line">//设置用户名密码</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">password</span>=<span class="keyword">password</span>(”<span class="number">123456</span>′′) <span class="keyword">where</span> <span class="keyword">user</span>=’root’;</span><br><span class="line">//查看当前用户的权限</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> root@<span class="string">&quot;%&quot;</span>; </span><br></pre></td></tr></table></figure><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。</p><p>文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929173028.png" alt="image-20210929173028375" style="zoom:50%;" /><p>客户端如果长时间不发送command到Server端，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p><p>查看wait_timeout</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;wait_timeout&quot;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> wait_timeout=<span class="number">28800</span>; 设置全局服务器关闭非交互连接之前等待活动的秒数</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929173639.png" alt="image-20210929173639549" style="zoom:50%;" /><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒: Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>开发当中我们大多数时候用的都是长连接,把连接放在Pool内进行管理，但是长连接有些时候会导致 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉(OOM)，从现象看就是 MySQL 异常重启了。</p><p>怎么解决这类问题呢?</p><p>1、定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 </p><p>2、如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>常用的一些操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>; 显示所有数据库</span><br><span class="line"><span class="keyword">use</span> dbname; 打开数据库:</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>; 显示数据库mysql中所有的表;</span><br><span class="line"><span class="keyword">describe</span> <span class="keyword">user</span>; 显示表mysql数据库中user表的列信息);</span><br></pre></td></tr></table></figure><p>连接建立完成后，就可以执行 select 语句了。</p><p>执行逻辑就会来到第二步:查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p> <strong>大多数情况查询缓存就是个鸡肋，为什么呢?</strong></p><p>查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。<br>因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率<br>会非常低。</p><p>一般建议在静态表(极少更新的表)里使用查询缓存</p><p>比如一个系统配置表、字典表，那这张表上的查询才适合使用查询缓存。好在 MySQL 也提供了这种“按需使用”的方式。你可以将my.cnf参数 query_cache_type 设置成 DEMAND。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">query_cache_type有3个值 0代表关闭查询缓存OFF，1代表开启ON，2(DEMAND)代表当sql语句中有SQL_CACHE关键词时才缓存</span></span><br><span class="line">query_cache_type=2</span><br></pre></td></tr></table></figure><p>这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CACHE</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">ID</span>=<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>查看当前mysql实例是否开启缓存机制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&quot;%query_cache_type%&quot;</span>;</span><br></pre></td></tr></table></figure><p>监控查询缓存的命中率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span><span class="string">&#x27;%Qcache%&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003191721.png" alt="image-20211003191720843" style="zoom:50%;" /><ul><li>Qcache_free_blocks:表示查询缓存中目前还有多少剩余的blocks，如果该值显示较大，则说明查询缓存中的内存碎片 过多了，可能在一定的时间进行整理。</li><li>Qcache_free_memory:查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多 了，还是不够用，DBA可以根据实际情况做出调整。</li><li>Qcache_hits:表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。</li><li>Qcache_inserts: 表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数，次数越多，表示查询缓存应用到的比较少，效果也就不理 想。当然系统刚启动后，查询缓存是空的，这很正常。</li><li>Qcache_lowmem_prunes:该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的调整缓存大小。</li><li>Qcache_not_cached: 表示因为query_cache_type的设置而没有被缓存的查询数量。 Qcache_queries_in_cache:当前缓存中缓存的查询数量。 Qcache_total_blocks:当前缓存的block数量。</li></ul><p><strong>mysql8.0已经移除了查询缓存功能</strong></p><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。 分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是 什么，代表什么。<br>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符 串“ID”识别成“列 ID”。 做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 from 写成了 “rom”。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003194249.png" alt="image-20211003194249190" style="zoom:50%;" /><h2 id="词法分析器原理"><a href="#词法分析器原理" class="headerlink" title="词法分析器原理"></a>词法分析器原理</h2><p>词法分析器分成6个主要步骤完成对sql语句的分析</p><blockquote><p>1、词法分析 </p><p>2、语法分析 </p><p>3、语义分析 </p><p>4、构造执行树 </p><p>5、生成执行计划 </p><p>6、计划的执行</p></blockquote><p>下图是SQL词法分析的过程步骤:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003194554.png" alt="image-20211003194554628" style="zoom:50%;" /><p>SQL语句的分析分为词法分析与语法分析，mysql的词法分析由MySQLLex[MySQL自己实现的]完成，语法分析由Bison生成。</p><p>关于语法树大家如果想要深入研究可以参考这篇wiki文章:<a href="https://en.wikipedia.org/wiki/LR_parser%E3%80%82">https://en.wikipedia.org/wiki/LR_parser。</a></p><p>那么除了Bison 外，Java当中也有开源的词法结构分析工具例如Antlr4，ANTLR从语法生成一个解析器，可以构建和遍历解析树，可以在IDEA 工具当中安装插件:antlr v4 grammar plugin。</p><p>经过bison语法分析之后，会生成一个这样的语法树</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003194749.png" alt="image-20211003194748964" style="zoom:50%;" /><p>至此分析器的工作任务也基本圆满了。</p><h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引;或者在一个语句有多表关联(join)的时候，决定各个表的连接 顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test1 <span class="keyword">join</span> test2 <span class="keyword">using</span>(<span class="keyword">ID</span>) <span class="keyword">where</span> test1.name=yangguo <span class="keyword">and</span> test2.name=xiaolongnv;</span><br></pre></td></tr></table></figure><p>既可以先从表 test1 里面取出 name=yangguo的记录的 ID 值，再根据 ID 值关联到表 test2，再判断 test2 里面 name的 值是否等于 yangguo。</p><p>也可以先从表 test2 里面取出 name=xiaolongnv 的记录的 ID 值，再根据 ID 值关联到 test1，再判断 test1 里面 name 的值是否等于 yangguo。 </p><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h1><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在 工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权 限)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。 </p><p>比如我们这个例子中的表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的:</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 1，如果不是则跳过，如果是则将这行存在结果集中; </li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加 的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p><h2 id="bin-log归档"><a href="#bin-log归档" class="headerlink" title="bin-log归档"></a>bin-log归档</h2><p>SQL执行时，会将sql语句的执行逻辑记录在我们的bin-log当中。</p><p>binlog是Server层实现的二进制日志,他会记录我们的cud操作。Binlog有以下几个特点:</p><ol><li>Binlog在MySQL的Server层实现(引擎共用) </li><li>Binlog为逻辑日志,记录的是一条语句的原始逻辑 </li><li>Binlog不限大小,追加写入,不会覆盖以前的日志</li></ol><p>如果，我们误删了数据库,可以使用binlog进行归档!要使用binlog归档，首先我们得记录binlog，因此需要先开启MySQL的 binlog功能。</p><p><strong>配置my.cnf</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置开启binlog</span></span><br><span class="line"><span class="built_in">log</span>‐bin=/usr/<span class="built_in">local</span>/mysql/data/binlog/mysql‐bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意5.7以及更高版本需要配置本项，(自定义,保证唯一性);</span></span><br><span class="line">server‐id=123454</span><br><span class="line"></span><br><span class="line"><span class="comment">#binlog格式，有3种statement,row,mixed</span></span><br><span class="line">binlog‐format=ROW</span><br><span class="line"></span><br><span class="line"><span class="comment">#表示每1次执行写入就与硬盘同步，会影响性能，为0时表示，事务提交时mysql不做刷盘操作，由系统决定</span></span><br><span class="line">sync‐binlog=1</span><br></pre></td></tr></table></figure><p><strong>binlog命令</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看bin‐log是否开启 </span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="comment"># 会多一个最新的bin‐log日志</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">logs</span>; </span><br><span class="line"><span class="comment"># 查看最后一个bin‐log日志的相关信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>; </span><br><span class="line"><span class="comment"># 清空所有的bin‐log日志</span></span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">master</span>;</span><br></pre></td></tr></table></figure><p><strong>查看binlog内容</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看binlog内容</span></span><br><span class="line">/usr/local/mysql/bin/mysqlbinlog ‐‐no‐defaults /usr/local/mysql/data/binlog/mysql‐bin.000001 </span><br></pre></td></tr></table></figure><p>binlog里的内容不具备可读性，所以需要我们自己去判断恢复的逻辑点位.</p><p>看重点信息，比如begin,commit这种 关键词信息，只要在binlog当中看到了，你就可以理解为begin-commit之间的信息是一个完整的事务逻辑，然后再根据位置 position判断恢复即可。</p><p>binlog内容如下:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20211003200811.png" alt="image-20211003200811298"></p><p><strong>数据归档操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从bin‐log恢复数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复全部数据</span></span><br><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqlbinlog ‐‐no‐defaults /usr/<span class="built_in">local</span>/mysql/data/binlog/mysql‐bin.000001 |mysql ‐uroot ‐p password (数据库名)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复指定位置数据</span></span><br><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqlbinlog ‐‐no‐defaults ‐‐start‐position=<span class="string">&quot;408&quot;</span> ‐‐stop‐position=<span class="string">&quot;731&quot;</span></span><br><span class="line">/usr/<span class="built_in">local</span>/mysql/data/binlog/mysql‐bin.000001 |mysql ‐uroot ‐p password(数据库)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复指定时间段数据</span></span><br><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqlbinlog ‐‐no‐defaults /usr/<span class="built_in">local</span>/mysql/data/binlog/mysql‐bin.000001 ‐‐stop‐date= <span class="string">&quot;2018‐03‐02 12:00:00&quot;</span> ‐‐start‐date= <span class="string">&quot;2019‐03‐02 11:55:00&quot;</span>|mysql ‐uroot ‐p <span class="built_in">test</span>(数据库)</span><br></pre></td></tr></table></figure><p><strong>归档测试准备</strong></p><ol><li><p>定义一个存储过程，写入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> tproc;</span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> tproc(i <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> s <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">declare</span> c <span class="built_in">char</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="keyword">repeat</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">50</span>);</span><br><span class="line">    while s&lt;=i do</span><br><span class="line">        <span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="literal">null</span>,c);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">        <span class="keyword">set</span> s=s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"> <span class="keyword">end</span>$$</span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure></li><li><p>利用binlog归档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mysql/bin/mysqlbinlog ‐‐no‐defaults /usr/local/mysql/data/binlog/mysql‐bin.000001 |mysql ‐uroot ‐p password(数据库名)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL的内部组件结构&quot;&gt;&lt;a href=&quot;#MySQL的内部组件结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL的内部组件结构&quot;&gt;&lt;/a&gt;MySQL的内部组件结构&lt;/h1&gt;&lt;img src=&quot;https://hexo-img-130160</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://tj-ever.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引和Explain执行计划</title>
    <link href="https://tj-ever.github.io/2021/09/23/MySQL%20%E7%B4%A2%E5%BC%95%E5%8F%8AExplain/"/>
    <id>https://tj-ever.github.io/2021/09/23/MySQL%20%E7%B4%A2%E5%BC%95%E5%8F%8AExplain/</id>
    <published>2021-09-22T16:00:00.000Z</published>
    <updated>2021-10-04T14:01:09.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是帮助MySQL高效获取数据的排好序的数据结构</p><p>索引数据结构</p><ul><li><p>二叉树</p></li><li><p>红黑树</p></li><li><p>Hash表</p></li><li><p>B-Tree</p></li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928094512.png" alt="image-20210928094512039" style="zoom:50%;" /><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><ul><li>叶节点具有相同的深度，叶节点的指针为空</li><li>所有索引元素不重复</li><li>节点中的数据索引从左到右递增排列</li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928094606.png" alt="image-20210928094606504" style="zoom:50%;" /><h2 id="B-Tree-B-Tree变种"><a href="#B-Tree-B-Tree变种" class="headerlink" title="B+Tree(B-Tree变种)"></a><strong>B+Tree</strong>(B-Tree变种)</h2><p>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引</p><p>叶子节点包含所有索引字段</p><p>叶子节点用指针连接，提高区间访问的性能</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928094740.png" alt="image-20210928094740721" style="zoom:50%;" /><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a><strong>Hash</strong></h2><p>对索引的key进行一次hash计算就可以定位出数据存储的位置</p><ul><li>很多时候Hash索引要比B+ 树索引更高效</li><li>仅能满足 “=”，“IN”，不支持范围查询</li><li>hash冲突问题</li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928095050.png" alt="image-20210928095050351" style="zoom:50%;" /><h2 id="MyISAM索引"><a href="#MyISAM索引" class="headerlink" title="MyISAM索引"></a>MyISAM索引</h2><p>MyISAM索引文件和数据文件是分离的(非聚集)</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928095216.png" alt="image-20210928095216788" style="zoom:50%;" /><h2 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h2><p>InnoDB索引实现(聚集)</p><p>表数据文件本身就是按B+Tree组织的一个索引结构文件</p><p>聚集索引-叶节点包含了完整的数据记录</p><p>为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？</p><p>为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928095824.png" alt="image-20210928095824938" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928095837.png" alt="image-20210928095837493" style="zoom:50%;" /><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928100015.png" alt="image-20210928100015079" style="zoom:50%;" /><h1 id="Explain执行计划"><a href="#Explain执行计划" class="headerlink" title="Explain执行计划"></a>Explain执行计划</h1><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈</p><p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条SQL<br>注意:如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中</p><h2 id="分析示例"><a href="#分析示例" class="headerlink" title="分析示例"></a>分析示例</h2><p>参考官方文档:<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 演员表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`actor`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`actor`</span> (</span><br><span class="line">   <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`update_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">  ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="comment">-- 如果日期插不进去 可以执行 SET SESSION sql_mode = &#x27;ALLOW_INVALID_DATES&#x27;;  </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`actor`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`update_time`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;2017‐12‐22 15:27:18&#x27;</span>), (<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;2017‐12‐22 15:27:18&#x27;</span>), (<span class="number">3</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;2017‐12‐22 15:27:18&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 电影表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`film`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`film`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_name`</span> (<span class="string">`name`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`film`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;film1&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;film2&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;film3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关联表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`film_actor`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`film_actor`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`film_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`actor_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`remark`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_film_actor_id`</span> (<span class="string">`film_id`</span>,<span class="string">`actor_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`film_actor`</span> (<span class="string">`id`</span>, <span class="string">`film_id`</span>, <span class="string">`actor_id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>actor数据</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928112637.png" alt="image-20210928112637517" style="zoom:50%;" /><p>film数据</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928112700.png" alt="image-20210928112700126" style="zoom:50%;" /><p>film-actor数据</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928112717.png" alt="image-20210928112717739" style="zoom:50%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928113044.png" alt="image-20210928113044526"></p><p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行</p><h2 id="explain-两个变种"><a href="#explain-两个变种" class="headerlink" title="explain 两个变种"></a>explain 两个变种</h2><h3 id="explain-extended"><a href="#explain-extended" class="headerlink" title="explain extended"></a>explain extended</h3><p>会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可</p><p>以得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数(前一个表指 explain 中的id值比当前表id值小的表)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">extended</span> <span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">WARNINGS</span>;</span><br></pre></td></tr></table></figure><p>explain 结果</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928124506.png" alt="image-20210928124506045"></p><p>show warings 结果</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928124548.png" alt="image-20210928124548843"></p><h3 id="explain-partitions"><a href="#explain-partitions" class="headerlink" title="explain partitions"></a>explain partitions</h3><p>相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p><h2 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a>explain中的列</h2><h3 id="id列"><a href="#id列" class="headerlink" title="id列"></a>id列</h3><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。 id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</p><h3 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h3><p>select_type 表示对应行是简单还是复杂的查询。</p><ol><li><p>simple:简单查询。查询不包含子查询和union</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928125237.png" alt="image-20210928125237511" style="zoom:50%;" /></li><li><p>primary:复杂查询中最外层的 select</p></li><li><p>subquery:包含在 select 中的子查询(不在 from 子句中)</p></li><li><p>derived:包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表(derived的英文含义)</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928140157.png" alt="image-20210928140157075" style="zoom:50%;" /></li><li><p>union:在 union 中的第二个和随后的 select</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928141227.png" alt="image-20210928141227042" style="zoom:50%;" /></li></ol><h3 id="table列"><a href="#table列" class="headerlink" title="table列"></a>table列</h3><p>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查 询。<br>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p><h3 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h3><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 </p><p>依次从最优到最差分别为:system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL </p><p><strong>一般来说，得保证查询达到range级别，最好达到ref</strong></p><ul><li><p>NULL</p><p>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。</p><p>例如:在索引列中选取最小值，可 以单独查找索引来完成，不需要在执行时访问表</p></li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928141826.png" alt="image-20210928141826882" style="zoom:50%;" /><ul><li><p>const, system</p><p>mysql能对查询的某部分进行优化并将其转化成一个常量(可以看show warnings 的结果)。</p><p>用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。</p><p>system是 const的特例，表里只有一条元组匹配时为system</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928142018.png" style="zoom:50%;" />“</p></li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928142302.png" alt="image-20210928142302451" style="zoom:50%;" /><ul><li><p>eq_ref</p><p>primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。</p><p>这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p></li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928142612.png" alt="image-20210928142612879" style="zoom:50%;" /><ul><li><p>ref</p><p>相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行</p><ul><li><p>简单 select 查询，name是普通索引(非唯一索引)</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928142728.png" alt="image-20210928142728756" style="zoom:50%;" /></li><li><p>关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928143434.png" alt="image-20210928143434814" style="zoom:50%;" /></li></ul></li><li><p>range</p><p>范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928143700.png" alt="image-20210928143700192" style="zoom:50%;" /></li><li><p>index</p><p>扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928143756.png" alt="image-20210928143756335" style="zoom:50%;" /></li><li><p>ALL</p><p>即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928143828.png" alt="image-20210928143828925" style="zoom:50%;" /></li></ul><h3 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a>possible_keys列</h3><p>这一列显示查询可能使用哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引 对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p><h3 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h3><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。如果没有使用索引，则该列是 NULL。</p><p>如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p><h3 id="key-len列"><a href="#key-len列" class="headerlink" title="key_len列"></a>key_len列</h3><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p><p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列:film_id列来执行索引查找。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210928153746.png" alt="image-20210928153746752" style="zoom:50%;" /><p>key_len计算规则如下:</p><ul><li><p>字符串</p><ul><li><p>char(n) 和 varchar(n)，5.0.3以后版本中，n均代表字符数，而不是字节数，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节 </p></li><li><p>char(n):如果存汉字长度就是 3n 字节</p></li><li><p>varchar(n):如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为 varchar是变长字符串</p></li></ul></li><li><p>数值类型</p><ul><li>tinyint:1字节</li><li>smallint:2字节</li><li>int:4字节</li><li>bigint:8字节  </li></ul></li><li><p>时间类型</p><ul><li>date:3字节</li><li>timestamp:4字节</li><li>datetime:8字节</li></ul></li><li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p></li></ul><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p><h3 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a>ref列</h3><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有:const(常量)，字段名(例:film.id)</p><h3 id="rows列"><a href="#rows列" class="headerlink" title="rows列"></a>rows列</h3><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p><h3 id="extra列"><a href="#extra列" class="headerlink" title="extra列"></a>extra列</h3><p>这一列展示的是额外信息。常见的重要值如下:</p><ul><li><p>Using index:使用覆盖索引</p><p><strong>覆盖索引定义</strong>:mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index;</p><p>覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929111543.png" alt="image-20210929111542983" style="zoom:50%;" /></li><li><p>Using where:使用 where 语句来处理结果，并且查询的列未被索引覆盖</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929133723.png" alt="image-20210929133723260" style="zoom:50%;" /></li><li><p>Using index condition:查询的列不完全被索引覆盖，where条件中是一个前导列的范围;</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929133804.png" alt="image-20210929133804734" style="zoom:50%;" /></li><li><p>Using temporary:mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p><ul><li><p>actor.name没有索引，此时创建了张临时表来distinct</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929133924.png" alt="image-2021092        9133924451" style="zoom:50%;" /></li></ul></li></ul><ul><li><p>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929134042.png" alt="image-20210929134042090" style="zoom:50%;" /></li><li><p>Using filesort:将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p><ul><li><p>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929134238.png" alt="image-20210929134238147" style="zoom:50%;" /></li><li><p>film.name建立了idx_name索引,此时查询时extra是using index</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929134359.png" alt="image-20210929134359907" style="zoom:50%;" /></li></ul></li><li><p>Select tables optimized away:使用某些聚合函数(比如 max、min)来访问存在索引的某个字段</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929134609.png" alt="image-20210929134609629" style="zoom:50%;" /></li></ul><h1 id="索引最佳实践"><a href="#索引最佳实践" class="headerlink" title="索引最佳实践"></a>索引最佳实践</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`employees`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">VARCHAR</span> ( <span class="number">24</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line"><span class="string">`position`</span> <span class="built_in">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line"><span class="string">`hire_time`</span> <span class="built_in">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;入职时间&#x27;</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> ( <span class="string">`id`</span> ),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_name_age_position`</span> ( <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`position`</span> ) <span class="keyword">USING</span> BTREE </span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> AUTO_INCREMENT = <span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8 <span class="keyword">COMMENT</span> = <span class="string">&#x27;员工记录表&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees ( <span class="keyword">NAME</span>, age, <span class="keyword">position</span>, hire_time )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(</span><br><span class="line"><span class="string">&#x27;LiLei&#x27;</span>,</span><br><span class="line"><span class="number">22</span>,</span><br><span class="line"><span class="string">&#x27;manager&#x27;</span>,</span><br><span class="line"><span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees ( <span class="keyword">NAME</span>, age, <span class="keyword">position</span>, hire_time )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(</span><br><span class="line"><span class="string">&#x27;HanMeimei&#x27;</span>,</span><br><span class="line"><span class="number">23</span>,</span><br><span class="line"><span class="string">&#x27;dev&#x27;</span>,</span><br><span class="line"><span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees ( <span class="keyword">NAME</span>, age, <span class="keyword">position</span>, hire_time )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(</span><br><span class="line"><span class="string">&#x27;Lucy&#x27;</span>,</span><br><span class="line"><span class="number">23</span>,</span><br><span class="line"><span class="string">&#x27;dev&#x27;</span>,</span><br><span class="line"><span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure><h2 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929135233.png" alt="image-20210929135233203" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929135302.png" alt="image-20210929135302686" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929135346.png" alt="image-20210929135346079" style="zoom:50%;" /><h2 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h2><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929135723.png" alt="image-20210929135722952" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929135750.png" alt="image-20210929135750389" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929135841.png" alt="image-20210929135841460" style="zoom:50%;" /><h2 id="不在索引列上做任何操作"><a href="#不在索引列上做任何操作" class="headerlink" title="不在索引列上做任何操作"></a>不在索引列上做任何操作</h2><p>计算、函数、(自动or手动)类型转换，会导致索引失效而转向全表扫描</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929141145.png" alt="image-20210929141145463" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929141214.png" alt="image-20210929141214291" style="zoom:50%;" /><ul><li><p>给hire_time增加一个普通索引</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929141832.png" alt="image-20210929141832036" style="zoom:50%;" /></li><li><p>转化为日期范围查询，有可能会走索引</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929142009.png" alt="image-20210929142009926" style="zoom:50%;" /></li><li><p>还原最初索引状态</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929142200.png" alt="image-20210929142200223" style="zoom:50%;" /></li></ul><h2 id="存储引擎不能使用索引中范围条件右边的列"><a href="#存储引擎不能使用索引中范围条件右边的列" class="headerlink" title="存储引擎不能使用索引中范围条件右边的列"></a>存储引擎不能使用索引中范围条件右边的列</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929155323.png" alt="image-20210929155323904" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929155401.png" alt="image-20210929155401263" style="zoom:50%;" /><h2 id="尽量使用覆盖索引"><a href="#尽量使用覆盖索引" class="headerlink" title="尽量使用覆盖索引"></a>尽量使用覆盖索引</h2><p>只访问索引的查询，因为索引列包含查询列，减少 select * 语句</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929155541.png" alt="image-20210929155541093" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929155724.png" alt="image-20210929155724761" style="zoom:50%;" /><h2 id="尽量不使用范围查询"><a href="#尽量不使用范围查询" class="headerlink" title="尽量不使用范围查询"></a>尽量不使用范围查询</h2><p>mysql在使用不等于(!=或者&lt;&gt;)，not in ，not exists 的时候无法使用索引会导致全表扫描；</p><p> &lt; 小于、 &gt; 大于、 &lt;=、&gt;= 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929155920.png" alt="image-20210929155920105" style="zoom:50%;" /><h2 id="尽量不使用空值判断"><a href="#尽量不使用空值判断" class="headerlink" title="尽量不使用空值判断"></a>尽量不使用空值判断</h2><p>is null,is not null 一般情况下也无法使用索引</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929160011.png" alt="image-20210929160011848" style="zoom:50%;" /><h2 id="尽量不使用like通配符开头"><a href="#尽量不使用like通配符开头" class="headerlink" title="尽量不使用like通配符开头"></a>尽量不使用like通配符开头</h2><p>like以通配符开头(‘$abc…’)mysql索引失效会变成全表扫描操作</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929160152.png" alt="image-20210929160152109" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929160328.png" alt="image-20210929160328643" style="zoom:50%;" /><h2 id="解决like’-字符串-’索引不被使用"><a href="#解决like’-字符串-’索引不被使用" class="headerlink" title="解决like’%字符串%’索引不被使用"></a>解决like’%字符串%’索引不被使用</h2><p>a)使用覆盖索引，查询字段必须是建立覆盖索引字段</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929160445.png" alt="image-20210929160445626" style="zoom:50%;" /><p>b)如果不能使用覆盖索引则可能需要借助搜索引擎</p><h2 id="字符串不加单引号索引失效"><a href="#字符串不加单引号索引失效" class="headerlink" title="字符串不加单引号索引失效"></a>字符串不加单引号索引失效</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929161120.png" alt="image-20210929161120410" style="zoom:50%;" /><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929161548.png" alt="image-20210929161548156" style="zoom:50%;" /><h2 id="少用or或in"><a href="#少用or或in" class="headerlink" title="少用or或in"></a>少用or或in</h2><p>用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929161907.png" alt="image-20210929161907486" style="zoom:50%;" /><h2 id="范围查询优化"><a href="#范围查询优化" class="headerlink" title="范围查询优化"></a>范围查询优化</h2><p>给年龄添加单值索引</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929162046.png" alt="image-20210929162046654" style="zoom:50%;" /><p><strong>没走索引原因</strong>:mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引</p><p><strong>优化方法</strong>:可以将大的范围拆分成多个小范围</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929162215.png" alt="image-20210929162214954" style="zoom:50%;" /><p>还原最初索引状态</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929162252.png" alt="image-20210929162252047" style="zoom:50%;" /><h1 id="索引使用总结"><a href="#索引使用总结" class="headerlink" title="索引使用总结"></a>索引使用总结</h1><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210929162324.png" alt="image-20210929162324837"></p><p>**like **查询</p><p><strong>KK%相当于常量</strong></p><p><strong>%KK和%KK% 相当于范围</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;p&gt;索引是帮助MySQL高效获取数据的排好序的数据结构&lt;/p&gt;
&lt;p&gt;索引数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二叉树&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://tj-ever.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JVM Arthas使用及字符串常量池</title>
    <link href="https://tj-ever.github.io/2021/09/16/JVM%20Arthas%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>https://tj-ever.github.io/2021/09/16/JVM%20Arthas%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</id>
    <published>2021-09-15T16:00:00.000Z</published>
    <updated>2021-09-16T07:45:07.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里巴巴Arthas"><a href="#阿里巴巴Arthas" class="headerlink" title="阿里巴巴Arthas"></a>阿里巴巴Arthas</h1><p>Arthas 是 Alibaba 在 2018 年 9 月开源的 Java 诊断工具。支持 JDK6+， 采用命令行交互模式，可以方便的定位和诊断 线上程序运行问题。Arthas 官方文档十分详细，详见:<a href="https://alibaba.github.io/arthas/">https://alibaba.github.io/arthas/</a></p><h2 id="Arthas使用"><a href="#Arthas使用" class="headerlink" title="Arthas使用"></a>Arthas使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">github下载arthas</span></span><br><span class="line">wge thttps://alibaba.github.io/arthas/arthas‐boot.jar 3 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者 Gitee 下载</span></span><br><span class="line">wget https://arthas.gitee.io/arthas‐boot.jar</span><br></pre></td></tr></table></figure><p>用java -jar运行即可，可以识别机器上所有Java进程</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916121241.png" alt="image-20210916121241545"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arthas</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashSet hashSet = <span class="keyword">new</span> HashSet(); <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//模拟CPU过高</span></span><br><span class="line">       cpuHigh();</span><br><span class="line">       <span class="comment">// 模拟线程死锁</span></span><br><span class="line">       deadThread();</span><br><span class="line">       <span class="comment">// 不断的向 hashSet 集合增加数据</span></span><br><span class="line">       addHashSetThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 不断的向 hashSet 集合添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addHashSetThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 初始化常量</span></span><br><span class="line">      <span class="keyword">new</span> Thread(() ‐&gt; &#123;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">            hashSet.add(<span class="string">&quot;count&quot;</span> + count);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            count++;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpuHigh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() ‐&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *死锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deadThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">/** 创建资源 */</span></span><br><span class="line">      Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">      Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line">      <span class="comment">// 创建线程</span></span><br><span class="line">      Thread threadA = <span class="keyword">new</span> Thread(() ‐&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">          System.out.println(Thread.currentThread() + <span class="string">&quot; get ResourceA&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">         Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resourceB&quot;</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">          System.out.println(Thread.currentThread() + <span class="string">&quot; get resourceB&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      Thread threadB = <span class="keyword">new</span> Thread(() ‐&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; get ResourceB&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resourceA&quot;</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; get resourceA&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      threadA.start();</span><br><span class="line">      threadB.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择进程序号1，进入进程信息操作</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916121811.png" alt="image-20210916121811265"></p><h3 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h3><p>输入dashboard可以查看整个进程的运行情况，线程、内存、GC、运行环境信息:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916122033.png" alt="image-20210916122033811"></p><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><p>输入thread可以查看线程详细情况</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916122112.png" alt="image-20210916122112387"></p><p>输入 thread加上线程ID 可以查看线程堆栈</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916122147.png" alt="image-20210916122147757"></p><p>输入 thread -b 可以查看线程死锁</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916122201.png" alt="image-20210916122200993"></p><h3 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h3><p>输入 jad加类的全名 可以反编译，这样可以方便我们查看线上代码是否是正确的版本</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916122236.png" alt="image-20210916122236347" style="zoom:50%;" /><h3 id="ognl"><a href="#ognl" class="headerlink" title="ognl"></a>ognl</h3><p>使用 ognl 命令可以查看线上系统变量的值，甚至可以修改变量的值</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916122307.png" alt="image-20210916122306971" style="zoom:50%;" /><p>更多命令使用可以用help命令查看，或查看文档:<a href="https://alibaba.github.io/arthas/commands.html#arthas">https://alibaba.github.io/arthas/commands.html#arthas</a></p><h1 id="GC日志详解"><a href="#GC日志详解" class="headerlink" title="GC日志详解"></a>GC日志详解</h1><p>对于java应用我们可以通过一些配置把程序运行过程中的gc日志全部打印出来，然后分析gc日志得到关键性指标，分析 GC原因，调优JVM参数。<br>打印GC日志方法，在JVM参数里增加参数，%t 代表时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‐Xloggc:./gc‐%t.log ‐XX:+PrintGCDetails ‐XX:+PrintGCDateStamps ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCCause ‐XX:+UseGCLogFileRotation ‐XX:NumberOfGCLogFiles=10 ‐XX:GCLogFileSize=100M</span><br></pre></td></tr></table></figure><p>Tomcat则直接加在JAVA_OPTS变量里。</p><h2 id="分析GC日志"><a href="#分析GC日志" class="headerlink" title="分析GC日志"></a>分析GC日志</h2><p>运行程序加上对应gc日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐jar ‐Xloggc:./gc‐%t.log ‐XX:+PrintGCDetails ‐XX:+PrintGCDateStamps ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCCause ‐XX:+UseGCLogFileRotation ‐XX:NumberOfGCLogFiles=10 ‐XX:GCLogFileSize=100M microservice‐eureka‐server.jar</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916135527.png" alt="image-20210916135527464"></p><p>我们可以看到图中第一行红框，是项目的配置参数。这里不仅配置了打印GC日志，还有相关的VM内存参数。 第二行红框中的是在这个GC时间点发生GC之后相关GC情况。</p><ol><li>对于2.909: 这是从jvm启动开始计算到这次GC经过的时间，前面还有具体的发生时间日期。</li><li>Full GC(Metadata GC Threshold)指这是一次full gc，括号里是gc的原因， PSYoungGen是年轻代的GC， ParOldGen是老年代的GC，Metaspace是元空间的GC</li><li>6160K-&gt;0K(141824K)，这三个数字分别对应GC之前占用年轻代的大小，GC之后年轻代占用，以及整个年轻代的大 小。</li><li>112K-&gt;6056K(95744K)，这三个数字分别对应GC之前占用老年代的大小，GC之后老年代占用，以及整个老年代的 大小。</li><li>6272K-&gt;6056K(237568K)，这三个数字分别对应GC之前占用堆内存的大小，GC之后堆内存占用，以及整个堆内存 的大小。</li><li>20516K-&gt;20516K(1069056K)，这三个数字分别对应GC之前占用元空间内存的大小，GC之后元空间内存占用，以及整个元空间内存的大小。</li><li>0.0209707是该时间点GC总耗费时间。</li></ol><p>从日志可以发现几次fullgc都是由于元空间不够导致的，所以我们可以将元空间调大点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐jar ‐Xloggc:./gc‐adjust‐%t.log ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:+PrintGCDetails ‐XX:+Print GCDateStamps ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCCause ‐XX:+UseGCLogFileRotation ‐XX:NumberOfGCLogFiles=10 ‐XX:GCLogFileSize=100M microservice‐eureka‐server.jar</span><br></pre></td></tr></table></figure><p>调整完我们再看下gc日志发现已经没有因为元空间不够导致的fullgc了</p><p>对于CMS和G1收集器的日志会有一点不一样，也可以试着打印下对应的gc日志分析下，可以发现gc日志是类似的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTest</span></span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">100</span>]; <span class="comment">//100KB</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ArrayList&lt;HeapTest&gt; heapTests = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    heapTests.add(<span class="keyword">new</span> HeapTest());</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line"> &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cms</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‐Xloggc:d:/gc‐cms‐%t.log ‐Xms50M ‐Xmx50M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:+PrintGCDetails ‐XX:+PrintGCDateStamps ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCCause ‐XX:+UseGCLogFileRotation ‐XX:NumberOfGCLogFiles=10 ‐XX:GCLogFileSize=100M ‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><p>G1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‐Xloggc:d:/gc‐g1‐%t.log ‐Xms50M ‐Xmx50M ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐XX:+PrintGCDetails ‐XX:+PrintGCDateStamps ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCCause ‐XX:+UseGCLogFileRotation ‐XX:NumberOfGCLogFiles=10 ‐XX:GCLogFileSize=100M ‐XX:+UseG1GC</span><br></pre></td></tr></table></figure><p>上面的这些参数，能够帮我们查看分析GC的垃圾收集情况。但是如果GC日志很多很多，成千上万行。就算你一目十行， 看完了，脑子也是一片空白。所以我们可以借助一些功能来帮助我们分析，这里推荐一个gceasy(<a href="https://gceasy.io),可以/">https://gceasy.io)，可以</a> 上传gc文件，然后他会利用可视化的界面来展现GC情况。</p><p>具体下图所示</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916141642.png" alt="image-20210916141641991" style="zoom:50%;" /><p>上图我们可以看到年轻代，老年代，以及永久代的内存分配，和最大使用情况。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916141737.png" alt="image-20210916141737881" style="zoom:50%;" /><p>上图我们可以看到堆内存在GC之前和之后的变化，以及其他信息。 </p><p>这个工具还提供基于机器学习的JVM智能优化建议，当然现在这个功能需要付费</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916141806.png" alt="image-20210916141806163" style="zoom:50%;" /><h1 id="JVM参数汇总查看命令"><a href="#JVM参数汇总查看命令" class="headerlink" title="JVM参数汇总查看命令"></a>JVM参数汇总查看命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial 表示打印出所有参数选项的默认值</span><br><span class="line">java -XX:+PrintFlagsFinal 表示打印出所有参数选项在运行程序时生效的值</span><br></pre></td></tr></table></figure><h1 id="Class常量池与运行时常量池"><a href="#Class常量池与运行时常量池" class="headerlink" title="Class常量池与运行时常量池"></a>Class常量池与运行时常量池</h1><p>Class常量池可以理解为是Class文件中的资源仓库。</p><p>Class文件中除了包含类的版本、字段、方法、接口等描述信息外， 还有一项信息就是常量池(constant pool table)，用于存放编译期生成的各种字面量(Literal)和符号引用(Symbolic References)。</p><p>一个class文件的16进制大体结构如下图:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916142109.png" alt="image-20210916142109455" style="zoom:50%;" /><p>对应的含义如下，细节可以查下oracle官方文档</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916142132.png" alt="image-20210916142132559" style="zoom:50%;" /><p>当然我们一般不会去人工解析这种16进制的字节码文件，我们一般可以通过javap命令生成更可读的JVM字节码指令文件:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916142207.png" alt="image-20210916142207909"></p><p>红框标出的就是class常量池信息，常量池中主要存放两大类常量:字面量和符号引用。</p><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>字面量就是指由字母、数字等构成的字符串或者数值常量 </p><p>字面量只可以右值出现，所谓右值是指等号右边的值，如:int a=1 这里的a为左值，1为右值。在这个例子中1就是字面量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c=<span class="string">&quot;abcdefg&quot;</span>; </span><br><span class="line"><span class="keyword">int</span> d=<span class="string">&quot;abcdefg&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h2><p>符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量:</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>上面的a，b就是字段名称，就是一种符号引用，还有Math类常量池里的 Lcom/tuling/jvm/Math 是类的全限定名， main和compute是方法名称，()是一种UTF8格式的描述符，这些都是符号引用。 这些常量池现在是静态信息，只有到运行时被加载到内存后，这些符号才有对应的内存地址信息，这些常量池一旦被装 入内存就变成运行时常量池，对应的符号引用在程序加载或运行时会被转变为被加载到内存区域的代码的直接引用，也 就是我们说的动态链接了。例如，compute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。</p><h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><h2 id="字符串常量池的设计思想"><a href="#字符串常量池的设计思想" class="headerlink" title="字符串常量池的设计思想"></a>字符串常量池的设计思想</h2><ul><li>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能</li><li>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化<ul><li>为字符串开辟一个字符串常量池，类似于缓存区</li><li>创建字符串常量时，首先查询字符串常量池是否存在该字符串</li><li>存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中</li></ul></li></ul><h3 id="三种字符串操作-Jdk1-7-及以上版本"><a href="#三种字符串操作-Jdk1-7-及以上版本" class="headerlink" title="三种字符串操作(Jdk1.7 及以上版本)"></a>三种字符串操作(Jdk1.7 及以上版本)</h3><ul><li><strong>直接赋值字符串</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;zhuge&quot;</span>; <span class="comment">//s指向常量池中的引用</span></span><br></pre></td></tr></table></figure><p>这种方式创建的字符串对象，只会在常量池中。 </p><p>因为有”zhuge”这个字面量，创建对象s的时候，JVM会先去常量池中通过 equals(key) 方法，判断是否有相同的对象</p><p>如果有，则直接返回该对象在常量池中的引用；</p><p>如果没有，则会在常量池中创建一个新对象，再返回引用。</p><ul><li><strong>new String();</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;zhuge&quot;</span>); <span class="comment">//s1指向内存中的对象引用</span></span><br></pre></td></tr></table></figure><p>这种方式会保证字符串常量池和堆中都有这个对象，没有就创建，最后返回堆内存中的对象引用。 </p><p>步骤大致如下: 因为有”zhuge”这个字面量，所以会先检查字符串常量池中是否存在字符串”zhuge”</p><p>不存在，先在字符串常量池里创建一个字符串对象；再去内存中创建一个字符串对象”zhuge”;</p><p>存在的话，就直接去堆内存中创建一个字符串对象”zhuge”;<br>最后，将内存中的引用返回。</p><ul><li>intern方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1==s2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>String中的intern方法是一个 native 的方法，当调用 intern方法时，如果池已经包含一个等于此String对象的字符串 (用equals(oject)方法确定)，则返回池中的字符串。否则，将intern返回的引用指向当前字符串 s1(jdk1.6版本需要将 s1 复制到字符串常量池里)。</p><h2 id="字符串常量池位置"><a href="#字符串常量池位置" class="headerlink" title="字符串常量池位置"></a>字符串常量池位置</h2><p>Jdk1.6及之前: 有永久代, 运行时常量池在永久代，运行时常量池包含字符串常量池 </p><p>Jdk1.7:有永久代，但已经逐步“去永久代”，字符串常量池从永久代里的运行时常量池分离到堆里 </p><p>Jdk1.8及之后: 无永久代，运行时常量池在元空间，字符串常量池里依然在堆里 </p><p>用一个程序证明下字符串常量池在哪里:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* jdk6:‐Xms6M ‐Xmx6M ‐XX:PermSize=6M ‐XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment">* jdk8:‐Xms6M ‐Xmx6M ‐XX:MetaspaceSize=6M ‐XX:MaxMetaspaceSize=6M</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(inti=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">      String str = String.valueOf(i).intern();</span><br><span class="line">      list.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">jdk7及以上:Exceptioninthread<span class="string">&quot;main&quot;</span>java.lang.OutOfMemoryError:Javaheapspace jdk6:Exceptioninthread<span class="string">&quot;main&quot;</span>java.lang.OutOfMemoryError:PermGenspace</span><br></pre></td></tr></table></figure><h2 id="字符串常量池设计原理"><a href="#字符串常量池设计原理" class="headerlink" title="字符串常量池设计原理"></a>字符串常量池设计原理</h2><p>字符串常量池底层是hotspot的C++实现的，底层类似一个 HashTable， 保存的本质上是字符串对象的引用。</p><p>看一道比较常见的面试题，下面的代码创建了多少个 String 对象?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;he&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;llo&quot;</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line"><span class="comment">// 在 JDK 1.6 下输出是 false，创建了 6 个对象</span></span><br><span class="line"><span class="comment">// 在 JDK 1.7 及以上的版本输出是 true，创建了 5 个对象</span></span><br><span class="line"><span class="comment">// 当然我们这里没有考虑GC，但这些对象确实存在或存在过</span></span><br></pre></td></tr></table></figure><p>为什么输出会有这些变化呢?主要还是字符串池从永久代中脱离、移入堆区的原因， intern() 方法也相应发生了变 化:<br> 1、在 JDK 1.6 中，调用 intern() 首先会在字符串池中寻找 equal() 相等的字符串，假如字符串存在就返回该字符串在字符串池中的引用;假如字符串不存在，虚拟机会重新在永久代上创建一个实例，将 StringTable 的一个表项指向这个新创建的实例。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916150007.png" alt="image-20210916150007646" style="zoom:50%;" /><p>2、在 JDK 1.7 (及以上版本)中，由于字符串池不在永久代了，intern() 做了一些修改，更方便地利用堆中的对象。字符串存在时和 JDK 1.6一样，但是字符串不存在时不再需要重新创建实例，可以直接指向堆上的实例。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916150215.png" alt="image-20210916150215366" style="zoom:50%;" /><p>由上面两个图，也不难理解为什么 JDK 1.6 字符串池溢出会抛出 OutOfMemoryError: PermGen space ，而在 JDK 1.7 及以上版本抛出 OutOfMemoryError: Java heap space 。</p><h2 id="String常量池问题的几个例子"><a href="#String常量池问题的几个例子" class="headerlink" title="String常量池问题的几个例子"></a>String常量池问题的几个例子</h2><ul><li>示例1:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s0 = <span class="string">&quot;zhuge&quot;</span>;</span><br><span class="line">String s1 = <span class="string">&quot;zhuge&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;zhu&quot;</span> + <span class="string">&quot;ge&quot;</span>;</span><br><span class="line">System.out.println(s0 == s1); <span class="comment">//true</span></span><br><span class="line">System.out.println(s0 == s2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>分析:</p><p>因为例子中的 s0和s1中的”zhuge”都是字符串常量，它们在编译期就被确定了，所以s0==s1为true; </p><p>而”zhu”和”ge”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所 以s2也同样在编译期就被优化为一个字符串常量”zhuge”，所以s2也是常量池中” zhuge”的一个引用。所以我们得出 s0==s1==s2;</p><ul><li>示例2:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s0 = <span class="string">&quot;zhuge&quot;</span>;</span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">String s2 = <span class="string">&quot;zhu&quot;</span>+<span class="keyword">new</span> String(<span class="string">&quot;ge&quot;</span>);</span><br><span class="line">System.out.println( s0==s1 ); <span class="comment">// false</span></span><br><span class="line">System.out.println( s0==s2 ); <span class="comment">// false</span></span><br><span class="line">System.out.println( s1==s2 ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>分析:</p><p>用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。<br>s0还是常量池中”zhuge”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”zhuge”的引用，s2因为有后半部分 new String(”ge”)所以也无法在编译期确定，所以也是一个新创建对象”zhuge”的引用;明白了这些也就知道为何得出此结果了。</p><ul><li>示例3:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;a1&quot;</span>;</span><br><span class="line">String b= <span class="string">&quot;a&quot;</span> + <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String a = <span class="string">&quot;atrue&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;true&quot;</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String a = <span class="string">&quot;a3.4&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;a&quot;</span> + <span class="number">3.4</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>分析:JVM对于字符串常量的”+”号连接，将在程序编译期，JVM就将常量字符串的”+”连接优化为连接后的值，拿”a” + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为 true。</p><ul><li>示例4:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a =<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String bb =<span class="string">&quot;b&quot;</span>;</span><br><span class="line">String b =<span class="string">&quot;a&quot;</span>+bb;</span><br><span class="line"></span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>分析:JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的， 即”a” + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为 false。</p><ul><li>示例5:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a =<span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String bb=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;a&quot;</span>+bb;</span><br><span class="line"></span><br><span class="line">System.out.println(a==b);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>分析:和示例4中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的”a” + bb和”a” + “b”效果是一样的。故上面程序的结果为true。</p><ul><li>示例6:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String bb = getBB();</span><br><span class="line">String b = <span class="string">&quot;a&quot;</span> + bb;</span><br><span class="line"></span><br><span class="line">System.out.println(a==b);<span class="comment">//false </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getBB</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析:JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和”a”来动态 连接并分配地址为b，故上面程序的结果为false。</p><h1 id="String是不可变的"><a href="#String是不可变的" class="headerlink" title="String是不可变的"></a>String是不可变的</h1><p>通过上面例子可以得出得知:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>; <span class="comment">//就等价于String s = &quot;abc&quot;; </span></span><br><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String c = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">String s1 = a+b+c;</span><br></pre></td></tr></table></figure><p>s1 这个就不一样了，可以通过观察其JVM指令码发现s1的”+”操作会变成如下操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">temp.append(a).append(b).append(c);</span><br><span class="line">String s = temp.toString();</span><br></pre></td></tr></table></figure><p>一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串常量池:&quot;计算机&quot;和&quot;技术&quot; 堆内存 :str1引用的对象&quot;计算机技术&quot;</span></span><br><span class="line"><span class="comment">//堆内存中还有个StringBuilder的对象，但是会被gc回收，StringBuilder的toString方法会newString()，这个String才是真正返回的对</span></span><br><span class="line">象引用</span><br><span class="line">String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;技术&quot;</span>).toString();<span class="comment">//没有出现&quot;计算机技术&quot;字面量，所以不会在常量池里生成&quot;计算机技术&quot;对象</span></span><br><span class="line"></span><br><span class="line">System.out.println(str2==str2.intern());<span class="comment">//true</span></span><br><span class="line"><span class="comment">//&quot;计算机技术&quot; 在池中没有，但是在heap中存在，则intern时，会直接返回该heap中的引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串常量池:&quot;ja&quot;和&quot;va&quot; 堆内存:str1引用的对象&quot;java&quot;</span></span><br><span class="line"><span class="comment">//堆内存中还有个StringBuilder的对象，但是会被gc回收，StringBuilder的toString方法会newString()，这个String才是真正返回的对象引用</span></span><br><span class="line">String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();<span class="comment">//没有出现&quot;java&quot;字面量，所以不会在常量池里生成&quot;java&quot;对象</span></span><br><span class="line">System.out.println(str1==str1.intern());<span class="comment">//false</span></span><br><span class="line"><span class="comment">//java是关键字，在JVM初始化的相关类里肯定早就放进字符串常量池了</span></span><br><span class="line"></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">System.out.println(s1==s1.intern());<span class="comment">//false</span></span><br><span class="line"><span class="comment">//&quot;test&quot;作为字面量，放入了池中，而new时s1指向的是heap中新生成的string对象，s1.intern()指向的是&quot;test&quot;字面量之前在池中生成的字符串对象</span></span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>).toString();</span><br><span class="line">System.out.println(s2==s2.intern());<span class="comment">//false </span></span><br><span class="line"><span class="comment">//同上</span></span><br></pre></td></tr></table></figure><h1 id="八种基本类型的包装类和对象池"><a href="#八种基本类型的包装类和对象池" class="headerlink" title="八种基本类型的包装类和对象池"></a>八种基本类型的包装类和对象池</h1><p>java中基本类型的包装类的大部分都实现了常量池技术(严格来说应该叫对象池，在堆上)，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外 Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。因为一般这种比较小的数用到的概率相对较大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//5种整形的包装类Byte,Short,Integer,Long,Character的对象，</span></span><br><span class="line">  <span class="comment">//在值小于127时可以使用对象池</span></span><br><span class="line">  Integer i1 = <span class="number">127</span>; <span class="comment">//这种调用底层实际是执行的Integer.valueOf(127)，里面用到了IntegerCache对象池 Integer i2 = 127;</span></span><br><span class="line">  System.out.println(i1 == i2);<span class="comment">//输出true</span></span><br><span class="line">  <span class="comment">//值大于127时，不会从对象池中取对象 Integer i3 = 128;</span></span><br><span class="line">  Integer i4 = <span class="number">128</span>;</span><br><span class="line">  System.out.println(i3 == i4);<span class="comment">//输出false</span></span><br><span class="line">  <span class="comment">//用new关键词新生成对象不会使用对象池 Integer i5 = new Integer(127);</span></span><br><span class="line">  Integer i6 = <span class="keyword">new</span> Integer(<span class="number">127</span>); System.out.println(i5 == i6);<span class="comment">//输出false</span></span><br><span class="line">  <span class="comment">//Boolean类也实现了对象池技术</span></span><br><span class="line">  Boolean bool1 = <span class="keyword">true</span>;</span><br><span class="line">  Boolean bool2 = <span class="keyword">true</span>; System.out.println(bool1 == bool2);<span class="comment">//输出true</span></span><br><span class="line">  <span class="comment">//浮点类型的包装类没有实现对象池技术</span></span><br><span class="line">  Double d1 = <span class="number">1.0</span>;</span><br><span class="line">  Double d2 = <span class="number">1.0</span>;</span><br><span class="line">  System.out.println(d1 == d2);<span class="comment">//输出false &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阿里巴巴Arthas&quot;&gt;&lt;a href=&quot;#阿里巴巴Arthas&quot; class=&quot;headerlink&quot; title=&quot;阿里巴巴Arthas&quot;&gt;&lt;/a&gt;阿里巴巴Arthas&lt;/h1&gt;&lt;p&gt;Arthas 是 Alibaba 在 2018 年 9 月开源的 Java </summary>
      
    
    
    
    
    <category term="JVM Arthas" scheme="https://tj-ever.github.io/tags/JVM-Arthas/"/>
    
  </entry>
  
  <entry>
    <title>JVM 调优相关</title>
    <link href="https://tj-ever.github.io/2021/09/03/JVM%20%E8%B0%83%E4%BC%98%E7%9B%B8%E5%85%B3/"/>
    <id>https://tj-ever.github.io/2021/09/03/JVM%20%E8%B0%83%E4%BC%98%E7%9B%B8%E5%85%B3/</id>
    <published>2021-09-02T16:00:00.000Z</published>
    <updated>2021-09-16T03:45:08.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM自带命令"><a href="#JVM自带命令" class="headerlink" title="JVM自带命令"></a>JVM自带命令</h1><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>此命令可以用来查看内存信息，实例个数以及占用内存大小</p><h3 id="jps查看进程"><a href="#jps查看进程" class="headerlink" title="jps查看进程"></a>jps查看进程</h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903170229.png" alt="image-20210903170229427" style="zoom:50%;" /><p>打开log.txt，文件内容如下:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903170252.png" alt="image-20210903170252085" style="zoom:50%;" /><ul><li>num:序号</li><li>instances:实例数量</li><li>bytes:占用空间大小</li><li>class name:类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]</li></ul><h3 id="堆信息"><a href="#堆信息" class="headerlink" title="堆信息"></a>堆信息</h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903170403.png" alt="image-20210903170403528" style="zoom:50%;" /><h3 id="堆内存dump"><a href="#堆内存dump" class="headerlink" title="堆内存dump"></a>堆内存dump</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap‐dump:format=b,file=eureka.hprof 14660</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903171131.png" alt="image-20210903171131050" style="zoom:50%;" /><p>也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)</p><p><code>-XX:+HeapDumpOnOutOfMemoryError</code><br><code>-XX:HeapDumpPath=./ (路径)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// JVM设置</span></span><br><span class="line">  <span class="comment">// ‐Xms10M ‐Xmx10M ‐XX:+PrintGCDetails ‐XX:+HeapDumpOnOutOfMemoryError ‐XX:HeapDumpPath=D:\jvm.dump</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> User(i++, UUID.randomUUID().toString()));</span><br><span class="line">      <span class="keyword">new</span> User(j‐‐, UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用jvisualvm命令工具导入该dump文件分析</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903173132.png" alt="image-20210903173131995" style="zoom:50%;" /><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ever.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread1 begin&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// todo</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread1 end&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread2 begin&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// todo</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread2 end&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先jps查询进程</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210904073615.png" alt="image-20210904073615688" style="zoom:50%;" /><p>用jstack加进程id查找死锁，见如下示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 21190</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210904073724.png" alt="image-20210904073724368" style="zoom:50%;" /><p>也可以用jvisualvm自动检测死锁</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210904073834.png" alt="image-20210904073834048" style="zoom:50%;" /><h3 id="远程连接jvisualvm"><a href="#远程连接jvisualvm" class="headerlink" title="远程连接jvisualvm"></a>远程连接jvisualvm</h3><ul><li><p>启动普通的jar程序JMX端口配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐Dcom.sun.management.jmxremote.port=8888 ‐Djava.rmi.server.hostname=192.168.0.130 ‐Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span> ‐Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> ‐jar demo.jar</span><br></pre></td></tr></table></figure><p><code>-Dcom.sun.management.jmxremote.port</code> 为远程机器的JMX端口</p><p><code>-Djava.rmi.server.hostname</code> 为远程机器IP</p></li><li><p>tomcat的JMX配置</p><p>在catalina.sh文件里的最后一个JAVA_OPTS的赋值语句下一行增加如下配置行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">&quot;<span class="variable">$JAVA_OPTS</span> ‐Dcom.sun.management.jmxremote.port=8888 ‐Djava.rmi.server.hostname=192.168.0.130 ‐Dcom.sun.ma nagement.jmxremote.ssl=false ‐Dcom.sun.management.jmxremote.authenticate=false&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="jstack找出占用cpu最高的线程堆栈信息"><a href="#jstack找出占用cpu最高的线程堆栈信息" class="headerlink" title="jstack找出占用cpu最高的线程堆栈信息"></a>jstack找出占用cpu最高的线程堆栈信息</h4><p>1.首先使用jps查出进程id</p><p>查出进程id为19663</p><p>2.使用命令top -p <pid> ，显示你的java进程的内存情况，pid是你的java进程号，比如19663</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210904080926.png" alt="image-20210904080926865" style="zoom:50%;" /><p>3，按H，获取每个线程的内存情况</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210904080913.png" alt="image-20210904080913232" style="zoom:50%;" /><p>4，找到内存和cpu占用最高的线程tid，比如19664</p><p>5，用printf ‘%x\n’ pid 转为十六进制得到 0x4cd0，此为线程id的十六进制表示</p><p>6，执行 jstack 19663|grep -A 10 4cd0，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调 、用方法</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906094311.png" alt="image-20210906094310897" style="zoom:50%;" /><p>7，查看对应的堆栈信息找出可能存在问题的代码</p><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>查看正在运行的Java应用程序的扩展参数 </p><h3 id="查看jvm的参数"><a href="#查看jvm的参数" class="headerlink" title="查看jvm的参数"></a>查看jvm的参数</h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906094353.png" alt="image-20210906094353190" style="zoom:50%;" /><h3 id="查看java系统参数"><a href="#查看java系统参数" class="headerlink" title="查看java系统参数"></a>查看java系统参数</h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906095223.png" alt="image-20210906095223051" style="zoom:50%;" /><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。</p><p>命令的格式如下: jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数] </p><p>注意:使用的jdk版本是jdk8</p><h3 id="垃圾回收统计"><a href="#垃圾回收统计" class="headerlink" title="垃圾回收统计"></a>垃圾回收统计</h3><p>jstat -gc pid 最常用，可以评估程序内存使用及GC压力整体情况</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906095821.png" alt="image-20210906095821146"></p><ul><li>S0C:第一个幸存区的大小，单位KB </li><li>S1C:第二个幸存区的大小 </li><li>S0U:第一个幸存区的使用大小</li><li>S1U:第二个幸存区的使用大小 </li><li>EC:伊甸园区的大小 </li><li>EU:伊甸园区的使用大小 </li><li>OC:老年代大小</li><li>OU:老年代使用大小 </li><li>MC:方法区大小(元空间) </li><li>MU:方法区使用大小 </li><li>CCSC:压缩类空间大小 </li><li>CCSU:压缩类空间使用大小 </li><li>YGC:年轻代垃圾回收次数 </li><li>YGCT:年轻代垃圾回收消耗时间，单位s</li><li>FGC:老年代垃圾回收次数 </li><li>FGCT:老年代垃圾回收消耗时间，单位s </li><li>GCT:垃圾回收消耗总时间，单位s</li></ul><h3 id="堆内存统计"><a href="#堆内存统计" class="headerlink" title="堆内存统计"></a>堆内存统计</h3><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906100655.png" alt="image-20210906100655045"></p><ul><li>NGCMN:新生代最小容量 </li><li>NGCMX:新生代最大容量 </li><li>NGC:当前新生代容量 </li><li>S0C:第一个幸存区大小 </li><li>S1C:第二个幸存区的大小 </li><li>EC:伊甸园区的大小 </li><li>OGCMN:老年代最小容量 </li><li>OGCMX:老年代最大容量 </li><li>OGC:当前老年代大小 </li><li>OC:当前老年代大小 </li><li>MCMN:最小元数据容量 </li><li>MCMX:最大元数据容量 </li><li>MC:当前元数据空间大小 </li><li>CCSMN:最小压缩类空间大小 </li><li>CCSMX:最大压缩类空间大小 </li><li>CCSC:当前压缩类空间大小 </li><li>YGC:年轻代gc次数 </li><li>FGC:老年代GC次数</li></ul><h3 id="新生代垃圾回收统计"><a href="#新生代垃圾回收统计" class="headerlink" title="新生代垃圾回收统计"></a>新生代垃圾回收统计</h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906100909.png" alt="image-20210906100909534" style="zoom:50%;" /><ul><li>S0C:第一个幸存区的大小 </li><li>S1C:第二个幸存区的大小 </li><li>S0U:第一个幸存区的使用大小 </li><li>S1U:第二个幸存区的使用大小 </li><li>TT:对象在新生代存活的次数 </li><li>MTT:对象在新生代存活的最大次数 </li><li>DSS:期望的幸存区大小 </li><li>EC:伊甸园区的大小 </li><li>EU:伊甸园区的使用大小 </li><li>YGC:年轻代垃圾回收次数 </li><li>YGCT:年轻代垃圾回收消耗时间</li></ul><h3 id="新生代内存统计"><a href="#新生代内存统计" class="headerlink" title="新生代内存统计"></a>新生代内存统计</h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906101032.png" alt="image-20210906101032642" style="zoom:50%;" /><ul><li>NGCMN:新生代最小容量 </li><li>NGCMX:新生代最大容量 </li><li>NGC:当前新生代容量 </li><li>S0CMX:最大幸存1区大小 </li><li>S0C:当前幸存1区大小 </li><li>S1CMX:最大幸存2区大小 </li><li>S1C:当前幸存2区大小 </li><li>ECMX:最大伊甸园区大小 </li><li>EC:当前伊甸园区大小 </li><li>YGC:年轻代垃圾回收次数 </li><li>FGC:老年代回收次数</li></ul><h3 id="老年代垃圾回收统计"><a href="#老年代垃圾回收统计" class="headerlink" title="老年代垃圾回收统计"></a>老年代垃圾回收统计</h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906101146.png" alt="image-20210906101146539" style="zoom:50%;" /><ul><li>MC:方法区大小 </li><li>MU:方法区使用大小 </li><li>CCSC:压缩类空间大小 </li><li>CCSU:压缩类空间使用大小 </li><li>OC:老年代大小 </li><li>OU:老年代使用大小 </li><li>YGC:年轻代垃圾回收次数 </li><li>FGC:老年代垃圾回收次数 </li><li>FGCT:老年代垃圾回收消耗时间 </li><li>GCT:垃圾回收消耗总时间</li></ul><h3 id="老年代内存统计"><a href="#老年代内存统计" class="headerlink" title="老年代内存统计"></a>老年代内存统计</h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906101227.png" alt="image-20210906101227167" style="zoom:50%;" /><ul><li>OGCMN:老年代最小容量 </li><li>OGCMX:老年代最大容量 </li><li>OGC:当前老年代大小 </li><li>OC:老年代大小 </li><li>YGC:年轻代垃圾回收次数 </li><li>FGC:老年代垃圾回收次数 </li><li>FGCT:老年代垃圾回收消耗时间 </li><li>GCT:垃圾回收消耗总时间</li></ul><h3 id="元数据空间统计"><a href="#元数据空间统计" class="headerlink" title="元数据空间统计"></a>元数据空间统计</h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906101332.png" alt="image-20210906101332101" style="zoom:50%;" /><ul><li>MCMN:最小元数据容量 </li><li>MCMX:最大元数据容量 </li><li>MC:当前元数据空间大小 </li><li>CCSMN:最小压缩类空间大小 </li><li>CCSMX:最大压缩类空间大小 </li><li>CCSC:当前压缩类空间大小 </li><li>YGC:年轻代垃圾回收次数 </li><li>FGC:老年代垃圾回收次数 </li><li>FGCT:老年代垃圾回收消耗时间 </li><li>GCT:垃圾回收消耗总时间</li></ul><h3 id="GC情况统计"><a href="#GC情况统计" class="headerlink" title="GC情况统计"></a>GC情况统计</h3><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906101556.png" alt="image-20210906101556508" style="zoom:50%;" /><ul><li>S0:幸存1区当前使用比例 </li><li>S1:幸存2区当前使用比例 </li><li>E:伊甸园区使用比例 </li><li>O:老年代使用比例 </li><li>M:元数据区使用比例 </li><li>CCS:压缩使用比例 </li><li>YGC:年轻代垃圾回收次数 </li><li>FGC:老年代垃圾回收次数 </li><li>FGCT:老年代垃圾回收消耗时间 </li><li>GCT:垃圾回收消耗总时间</li></ul><h1 id="JVM运行情况预估"><a href="#JVM运行情况预估" class="headerlink" title="JVM运行情况预估"></a>JVM运行情况预估</h1><blockquote><p>用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的 JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。</p></blockquote><h2 id="年轻代对象增长的速率"><a href="#年轻代对象增长的速率" class="headerlink" title="年轻代对象增长的速率"></a>年轻代对象增长的速率</h2><p>可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对 象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。</p><p>注意，一般系统可能有高峰期和日常期，所以需要在不同的时间分别估算不同情况下对象增长速率。</p><h2 id="Young-GC的触发频率和每次耗时"><a href="#Young-GC的触发频率和每次耗时" class="headerlink" title="Young GC的触发频率和每次耗时"></a>Young GC的触发频率和每次耗时</h2><p>知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC 公式算出，根据结果我们大概就能知道系统大概多久会因为Young GC的执行而卡顿多久。</p><h2 id="每次Young-GC后有多少对象存活和进入老年代"><a href="#每次Young-GC后有多少对象存活和进入老年代" class="headerlink" title="每次Young GC后有多少对象存活和进入老年代"></a>每次Young GC后有多少对象存活和进入老年代</h2><p>这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden， survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次 Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出老年代对象增长速率。</p><h2 id="Full-GC的触发频率和每次耗时"><a href="#Full-GC的触发频率和每次耗时" class="headerlink" title="Full GC的触发频率和每次耗时"></a>Full GC的触发频率和每次耗时</h2><p>知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。</p><p><strong>优化思路其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年 代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。</strong></p><h1 id="系统频繁Full-GC导致系统卡顿"><a href="#系统频繁Full-GC导致系统卡顿" class="headerlink" title="系统频繁Full GC导致系统卡顿"></a>系统频繁Full GC导致系统卡顿</h1><ul><li>机器配置:2核4G</li><li>JVM内存大小:2G</li><li>系统运行时间:7天</li><li>期间发生的Full GC次数和耗时:500多次，200多秒 期间发生的Young GC次数和耗时:1万多次，500多秒</li></ul><p>大致算下来每天会发生70多次Full GC，平均每小时3次，每次Full GC在400毫秒左右; </p><p>每天会发生1000多次Young GC，每分钟会发生1次，每次Young GC在50毫秒左右。</p><p>JVM参数设置如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">‐Xms1536M ‐Xmx1536M ‐Xmn512M ‐Xss256K ‐XX:SurvivorRatio=6 ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M</span><br><span class="line">‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC ‐XX:CMSInitiatingOccupancyFraction=75 ‐XX:+UseCMSInitiatingOccupancyOnly</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210906104252.png" alt="image-20210906104252576" style="zoom:50%;" /><p>可以结合对象挪动到老年代那些规则推理下我们这个程序可能存在的一些问题 </p><p>经过分析感觉可能会由于对象动态年龄判断机制导致full gc较为频繁</p><p>此处模拟一个工程，打印state结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat ‐gc 13456 2000 10000</span><br></pre></td></tr></table></figure><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916105042.png" alt="image-20210916105041861"></p><p>对于对象动态年龄判断机制导致的full gc较为频繁可以先试着优化下JVM参数，把年轻代适当调大点:</p><figure class="highlight shell"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">‐Xms1536M ‐Xmx1536M ‐Xmn1024M ‐Xss256K ‐XX:SurvivorRatio=6 ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M</span><br><span class="line">‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC ‐XX:CMSInitiatingOccupancyFraction=92 ‐XX:+UseCMSInitiatingOccupancyOnly</span><br></pre></td></tr></table></figure><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916105713.png" alt="image-20210916105713701" style="zoom:50%;" /><p>再次查看state，优化完发现没什么变化，full gc的次数比minor gc的次数还多了</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916110242.png" alt="image-20210916110242369"></p><p>我们可以推测下full gc比minor gc还多的原因有哪些?<br> 1、元空间不够导致的多余full gc<br> 2、显示调用System.gc()造成多余的full gc，这种一般线上尽量通过­XX:+DisableExplicitGC参数禁用，如果加上了这个JVM启动参数，那 么代码中调用System.gc()没有任何效果<br> 3、老年代空间分配担保机制</p><p>最快速度分析完这些我们推测的原因以及优化后，我们发现young gc和full gc依然很频繁了，而且看到有大量的对象频繁的被挪动到老年 代，这种情况我们可以借助jmap命令大概看下是什么对象</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210916110906.png" alt="image-20210916110906110"></p><p>查到了有大量User对象产生，这个可能是问题所在，但不确定，还必须找到对应的代码确认，如何去找对应的代码了? </p><p>1、代码里全文搜索生成User对象的地方(适合只有少数几处地方的情况)</p><p>2、如果生成User对象的地方太多，无法定位具体代码，我们可以同时分析下占用cpu较高的线程，一般有大量对象不断产生，对应的方法 代码肯定会被频繁调用，占用的cpu必然较高</p><p>可以用上面讲过的jstack或jvisualvm来定位cpu使用较高的代码，最终定位到的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span></span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/user/process&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">processUserData</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     ArrayList&lt;User&gt; users = queryUsers();</span><br><span class="line">     <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">       <span class="comment">//TODO 业务处理</span></span><br><span class="line">       System.out.println(<span class="string">&quot;user:&quot;</span> + user.toString());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;end&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟批量查询用户场景</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> ArrayList&lt;User&gt; <span class="title">queryUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(inti=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">   users.add(<span class="keyword">new</span> User(i,<span class="string">&quot;zhuge&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> users;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，java的代码也是需要优化的，一次查询出500M的对象出来，明显不合适，要根据之前说的各种原则尽量优化到合适的值，尽量消 除这种朝生夕死的对象导致的full gc</p><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>一般电商架构可能会使用多级缓存架构，就是redis加上JVM级缓存，大多数可能为了图方便对于JVM级缓存就简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏，对于一些老旧数据没有及时清理导致一直占用着宝贵的内存资源，时间长了除了导致full gc，还有可能导致OOM。 </p><p>这种情况完全可以考虑采用一些成熟的JVM级缓存框架来解决，比如ehcache等自带一些LRU数据淘汰算法的框架来作为JVM级的缓存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM自带命令&quot;&gt;&lt;a href=&quot;#JVM自带命令&quot; class=&quot;headerlink&quot; title=&quot;JVM自带命令&quot;&gt;&lt;/a&gt;JVM自带命令&lt;/h1&gt;&lt;h2 id=&quot;jmap&quot;&gt;&lt;a href=&quot;#jmap&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="JVM" scheme="https://tj-ever.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾收集</title>
    <link href="https://tj-ever.github.io/2021/09/03/JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <id>https://tj-ever.github.io/2021/09/03/JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</id>
    <published>2021-09-02T16:00:00.000Z</published>
    <updated>2021-09-03T08:33:40.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210828013442.png" alt="image-20210828013442792" style="zoom:50%;" /><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><blockquote><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样可以根据各个年代的特点选择合适的垃圾收集算法。 </p><p>在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</p><p>老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选 择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p></blockquote><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><blockquote><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p></blockquote><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210828022541.png" alt="image-20210828022541952" style="zoom:50%;" /><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><blockquote><p>算法分为“标记”和“清除”阶段。标记存活的对象， 统一回收所有未被标记的对象(一般选择这种);也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。</p><p>它是最基础的收集算法，比较简单，但是会带来两个明显的问题:</p><ul><li>效率问题 (如果需要标记的对象太多，效率不高) </li><li>空间问题(标记清除后会产生大量不连续的碎片)</li></ul></blockquote><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210828120242.png" alt="image-20210828120242833" style="zoom:50%;" /><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><blockquote><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p></blockquote><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210828120419.png" alt="image-20210828120419499" style="zoom:50%;" /><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210828121235.png" alt="image-20210828121235035"></p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p><code>-XX:+UseSerialGC</code> <code>-XX:+UseSerialOldGC</code></p><p>Serial(串行)收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工 作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。 </p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210829014649.png" alt="image-20210829014649433" style="zoom:50%;" /><p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短 (仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续)。</p><p>但是Serial收集器有没有优于其他垃圾收集器的地方呢?当然有，它简单而高效(与其他收集器的单线程相比)。</p><p>Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p><p>Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器。</p><p>它主要有两大用途:一种是在JDK1.5 以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种是作为CMS收集器的后备方案。</p><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p><code>-XX:+UseParallelGC</code>(年轻代),<code>-XX:+UseParallelOldGC</code>(老年代)</p><p>Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、回收策略等等)和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数<code>-XX:ParallelGCThreads</code>指定收集线程数，但是一般不推荐修改。</p><p>Parallel Scavenge收集器关注点是吞吐量(高效率的利用CPU)，所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间(提高用户体验)。</p><p>Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210829015648.png" alt="image-20210829015648366" style="zoom:50%;" /><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。</p><p>在注重吞吐量以及 CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(JDK8默认的新生代和老年代收集 器)。</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p><code>-XX:+UseParNewGC</code></p><p>ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。 </p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210829020054.png" alt="image-20210829020054041" style="zoom:50%;" /><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器(真正意义上的并发收集器)配合工作。</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p><code>-XX:+UseConcMarkSweepGC</code>(老年代)</p><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程 (基本上)同时工作。</p><p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤:</p><ol><li>初始标记: 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快。</li><li>并发标记: 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li><li>重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法做重新标记。</li><li>并发清理: 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理</li><li>并发重置:重置本次GC过程中的标记数据。</li></ol><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210829033034.png" alt="image-20210829033034895" style="zoom:50%;" /><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点:并发收集、低停顿。</p><p>但是它有下面几个明显的缺点: </p><ul><li>对CPU资源敏感(会和服务抢资源);</li><li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了);</li><li>使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数<code>-XX:+UseCMSCompactAtFullCollection</code>可以让jvm在执行完标记清除后再做整理。</li><li>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，<strong>特别是在并发标记和并发清理阶段会出现</strong>，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure”，<strong>此时会进入stop the world，用serial old垃圾收集器来回收</strong></li></ul><h3 id="CMS的相关核心参数"><a href="#CMS的相关核心参数" class="headerlink" title="CMS的相关核心参数"></a>CMS的相关核心参数</h3><blockquote><ol><li><p>-XX:+UseConcMarkSweepGC:启用cms</p></li><li><p>-XX:ConcGCThreads:并发的GC线程数</p></li><li><p>-XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩整理(减少碎片)</p></li><li><p>-XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次</p></li><li><p>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC(默认是92，这是百分比)</p></li><li><p>XX:+UseCMSInitiatingOccupancyOnly:只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设 定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</p></li><li><p>-XX:+CMSScavengeBeforeRemark:在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段</p></li><li><p>-XX:+CMSParallellnitialMarkEnabled:表示在初始标记的时候多线程执行，缩短STW</p></li><li><p>-XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行，缩短STW;</p></li></ol></blockquote><h2 id="JVM参数优化设置-ParNew-CMS"><a href="#JVM参数优化设置-ParNew-CMS" class="headerlink" title="JVM参数优化设置(ParNew+CMS)"></a>JVM参数优化设置(ParNew+CMS)</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210829042403.png" alt="image-20210827104352014" style="zoom:50%;" /><p>对于8G内存，我们一般是分配4G内存给JVM，正常的JVM参数配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‐Xms3072M ‐Xmx3072M ‐Xss1M ‐XX:MetaspaceSize&#x3D;256M ‐XX:MaxMetaspaceSize&#x3D;256M ‐XX:SurvivorRatio&#x3D;8</span><br></pre></td></tr></table></figure><p>上节课说过，这样设置可能会由于<strong>动态对象年龄判断原则导致频繁full gc</strong>。</p><p>于是我们可以更新下JVM参数设置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‐Xms3072M ‐Xmx3072M ‐Xmn2048M ‐Xss1M ‐XX:MetaspaceSize&#x3D;256M ‐XX:MaxMetaspaceSize&#x3D;256M ‐XX:SurvivorRatio&#x3D;8</span><br></pre></td></tr></table></figure><p>这样就降低了因为对象动态年龄判断原则导致的对象频繁进入老年代的问题，其实很多优化无非就是让短期存活的对象尽量都留在survivor里，不要进入老年代，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc。</p><p>对于对象年龄应该为多少才移动到老年代比较合适，本例中一次minor gc要间隔14秒，大多数对象一般在几秒内就 会变为垃圾，完全可以将默认的15岁改小一点，比如改为5，那么意味着对象要经过5次minor gc才会进入老年代，整个时间也有一两分钟了，如果对象这么长时间都没被回收，完全可以认为这些对象是会存活的比较长的对象，可以移动到老年代，而不是继续一直占用survivor区空间。</p><blockquote><p><strong>结论</strong></p><p><strong>JVM优化就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。</strong></p></blockquote><p>对于多大的对象直接进入老年代(参数-XX:PretenureSizeThreshold)，这个一般可以结合你自己系统看下有没有什么大对象生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始化分配的缓存对象，比如大的缓存List，Map之类的对象。</p><p>可以适当调整JVM参数如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‐Xms3072M ‐Xmx3072M ‐Xmn2048M ‐Xss1M ‐XX:MetaspaceSize&#x3D;256M ‐XX:MaxMetaspaceSize&#x3D;256M ‐XX:SurvivorRatio&#x3D;8 2 ‐XX:MaxTenuringThreshold&#x3D;5‐XX:PretenureSizeThreshold&#x3D;1M</span><br></pre></td></tr></table></figure><p>对于JDK8默认的垃圾回收器是<code>-XX:+UseParallelGC</code>(年轻代)和-XX:+UseParallelOldGC(老年代)</p><p>如果内存较大，系统对停顿时间比较敏感，我们可以使用ParNew+CMS(<code>-XX:+UseParNewGC</code> <code>-XX:+UseConcMarkSweepGC</code>) </p><p>对于老年代CMS的参数如何设置我们可以思考下，首先我们想下当前这个系统有哪些对象可能会长期存活躲过5次以上 minor gc最终进入老年代。 </p><p>无非就是那些Spring容器里的Bean，线程池对象，一些初始化缓存数据对象等，这些加起来充其量也就几十MB。 还有就是某次minor gc完了之后还有超过一两百M的对象存活，那么就会直接进入老年代，比如突然某一秒瞬间要处理五六百单，那么每秒生成的对象可能有一百多M，再加上整个系统可能压力剧增，一个订单要好几秒才能处理完，下一秒可能又有很多订单过来。 我们可以估算下大概每隔五六分钟出现一次这样的情况，那么大概半小时到一小时之间就可能因为老年代满了触发一次 Full GC，Full GC的触发条件还有我们之前说过的老年代空间分配担保机制，历次的minor gc挪动到老年代的对象大小肯定是非常小的，所以几乎不会在minor gc触发之前由于老年代空间分配担保失败而产生full gc，其实在半小时后发生 full gc，这时候已经过了抢购的最高峰期，后续可能几小时才做一次FullGC。 对于碎片整理，因为都是1小时或几小时才做一次FullGC，是可以每做完一次就开始碎片整理，或者两到三次之后再做一次也行。</p><p>综上，只要年轻代参数设置合理，老年代CMS的参数设置基本都可以用默认值，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">‐Xms3072M ‐Xmx3072M ‐Xmn2048M ‐Xss1M ‐XX:MetaspaceSize&#x3D;256M ‐XX:MaxMetaspaceSize&#x3D;256M ‐XX:SurvivorRatio&#x3D;8 ‐XX:MaxTenuringThreshold&#x3D;5 ‐XX:PretenureSizeThreshold&#x3D;1M ‐XX:+UseParNewGC‐XX:+UseConcMarkSweepGC</span><br><span class="line">‐XX:CMSInitiatingOccupancyFraction&#x3D;92 ‐XX:+UseCMSCompactAtFullCollection‐XX:CMSFullGCsBeforeCompaction&#x3D;0</span><br></pre></td></tr></table></figure><h2 id="垃圾收集底层算法实现"><a href="#垃圾收集底层算法实现" class="headerlink" title="垃圾收集底层算法实现"></a>垃圾收集底层算法实现</h2><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p>在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。 </p><p>这里引入“三色标记”，把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色:</p><ul><li>黑色: 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接(不经过 灰色对象) 指向某个白色对象。</li><li>灰色: 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</li><li>白色: 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210829042708.png" alt="image-20210829042708631" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 垃圾收集算法细节之三色标记</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeColorRemark</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  A a= <span class="keyword">new</span> A();</span><br><span class="line"><span class="comment">//开始做并发标记 </span></span><br><span class="line">    D d = a.b.d;<span class="comment">// 1.读 </span></span><br><span class="line">    a.b.d = <span class="keyword">null</span>;   <span class="comment">// 2.写 </span></span><br><span class="line">    a.d =d;  <span class="comment">// 3.写</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123; </span><br><span class="line">  B b = <span class="keyword">new</span> B(); </span><br><span class="line">  D d = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123; </span><br><span class="line">  C c = <span class="keyword">new</span> C(); </span><br><span class="line">  D d = <span class="keyword">new</span> D();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多标-浮动垃圾"><a href="#多标-浮动垃圾" class="headerlink" title="多标-浮动垃圾"></a>多标-浮动垃圾</h3><p>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gc root)被销毁，这个gc root引用的对象之前又被扫描过 (被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动 垃圾”。</p><p>浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。 另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</p><h3 id="漏标-读写屏障"><a href="#漏标-读写屏障" class="headerlink" title="漏标-读写屏障"></a>漏标-读写屏障</h3><p>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案: </p><p>增量更新(Incremental Update) 和原始快照(Snapshot At The Beginning，SATB) 。 </p><p>增量更新就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之 后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向 白色对象的引用之后， 它就变回灰色对象了。</p><p>原始快照就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾) 以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。</p><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>给某个对象的成员变量赋值时，其底层代码大概长这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param field 某对象的成员变量，如 a.b.d</span></span><br><span class="line"><span class="comment"> * @param new_value 新值，如 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field,oop new_value)</span></span>&#123;</span><br><span class="line"> *field = new_value; <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的写屏障，其实就是指在赋值操作前后，加入一些处理(可以参考AOP的概念):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field,oop new_value)</span></span>&#123;</span><br><span class="line"> pre_write_barrier(field); <span class="comment">// 写屏障‐写前操作</span></span><br><span class="line"> *field = new_value;</span><br><span class="line"> post_write_barrier(field, value); <span class="comment">// 写屏障‐写后操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="写屏障实现SATB"><a href="#写屏障实现SATB" class="headerlink" title="写屏障实现SATB"></a>写屏障实现SATB</h5><p>当对象B的成员变量的引用发生变化时，比如引用消失(a.b.d = null)，我们可以利用写屏障，将B原来成员变量的引用 对象D记录下来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_write_barrier</span><span class="params">(oop* field)</span></span>&#123;</span><br><span class="line"> oop old_value = *field; <span class="comment">// 获取旧值</span></span><br><span class="line"> remark_set.add(old_value); <span class="comment">// 记录原来的引用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="写屏障实现增量更新"><a href="#写屏障实现增量更新" class="headerlink" title="写屏障实现增量更新"></a>写屏障实现增量更新</h5><p>当对象A的成员变量的引用发生变化时，比如新增引用(a.d = d)，我们可以利用写屏障，将A新的成员变量引用对象D 记录下来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_write_barrier</span><span class="params">(oop* field,oopnew_value)</span></span>&#123; </span><br><span class="line">  remark_set.add(new_value); <span class="comment">// 记录新引用的对象</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">oop <span class="title">oop_field_load</span><span class="params">(oop* field)</span></span>&#123;</span><br><span class="line"> pre_load_barrier(field); <span class="comment">// 读屏障‐读取前操作</span></span><br><span class="line">   <span class="keyword">return</span> *field; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读屏障是直接针对第一步:D d = a.b.d，当读取成员变量时，一律记录下来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_load_barrier</span><span class="params">(oop* field)</span></span>&#123;</span><br><span class="line"> oop old_value = *field;</span><br><span class="line"> remark_set.add(old_value); <span class="comment">// 记录读取到的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现代追踪式(可达性分析)的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同:比如白色/黑色 集合一般都不会出现(但是有其他体现颜色的地方)、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可 以是广度/深度遍历等等。<br> 对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下:</p><p>CMS:写屏障 + 增量更新  </p><p>G1，Shenandoah:写屏障 + SATB </p><p>ZGC:读屏障</p><p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代/区引用的变化，读屏障可以用于支持移动对象的并 发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p><p><strong>为什么G1用SATB?CMS用增量更新?</strong> </p><p>我的理解:SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描 被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代 区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC 再深度扫描。</p><h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p>在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。 为此，在新生代可以引入记录集(Remember Set)的数据结构(记录从非收集区到收集区的指针集合)，避免把整个 老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集 (Partial GC) 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。 垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引 用指针的全部细节。 hotspot使用一种叫做“卡表”(cardtable)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。</p><p>卡表是使用一个字节数组实现:CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡 页”。<br> hotSpot使用的卡页是2^9大小，即512字节</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210829043754.png" alt="image-20210829043754169" style="zoom:50%;" /><p>一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变 脏，否则为0.<br> GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。<br> 卡表的维护 卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。 Hotspot使用写屏障维护卡表状态。</p><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC 停顿时间要求的同时,还具备高吞吐量性能特征.</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210831163944.png" alt="image-20210831163944234" style="zoom:50%;" /><blockquote><p>G1将Java堆划分为多个大小相等的独立区域(Region)，JVM最多可以有2048个Region。 </p><p>一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数”- XX:G1HeapRegionSize”手动指定Region大小，但是推荐默认的计算方式。</p><p>G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是可以不连续的Region的集合。</p><p>默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个 Region，可以通过“-XX:G1NewSizePercent”设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”调整。</p><p>年轻代中的Eden和 Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100 个，s1对应100个。 一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。</p><p>G1垃圾收集器对于对象什么时候会转移到老年代跟之前的原则一样，唯一不同的是对大对象的处理，G1有专门分配大对象的Region叫Humongous区，而不是让大对象直接进入老年代的Region中。</p><p>在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放 入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。 Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。</p><p>Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。</p></blockquote><p>G1收集器一次GC的运作过程大致分为以下几个步骤:</p><ul><li><p>初始标记(initial mark，STW): 暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ;</p></li><li><p>并发标记(Concurrent Marking): 同CMS的并发标记；</p></li><li><p>最终标记(Remark，STW): 同CMS的重新标记；</p></li><li><p>筛选回收(Cleanup，STW): 筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间(可用 <code>-XX:MaxGCPauseMillis</code>指定)来制定回收计划，比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(Collection Set，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。</p><p>这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代或是老年代，回收算法主要用的是复制算法，将一个region中的存活对象复制到另一个region中，这种不会像CMS那样回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片。(注意:CMS回收阶 段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本)</p></li></ul><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210831164936.png" alt="image-20210831164936897" style="zoom:50%;" /><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First的由来)，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。</p><p>被视为JDK1.7以上版本Java虚拟机的一个重要进化特征。它具备以下特点: </p><ul><li><p>并行与并发: G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU(CPU或者CPU核心)来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</p></li><li><p>分代收集: 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</p></li><li><p>空间整合: 与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器;从局部 上来看是基于“复制”算法实现的。</p></li><li><p>可预测的停顿: 这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数”<code>- XX:MaxGCPauseMillis</code>“指定)内完成垃圾收集。</p></li></ul><p>设置不同的期望停顿时间，可使得G1在不 同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。不过， 这里设置的“期望值”必须是符合实际的， 不能异想天开， 毕竟G1是要冻结用户线程来复制对象的， 这个停顿时间再怎么低也得有个限度。 </p><p>它默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间， 但应用运行时间一长就不行了， 最终占满堆引发 Full GC反而降低性能， 所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。</p><h3 id="G1垃圾收集分类"><a href="#G1垃圾收集分类" class="headerlink" title="G1垃圾收集分类"></a>G1垃圾收集分类</h3><ul><li><p>YoungGC </p><p>YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 <code>-XX:MaxGCPauseMills</code> 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 <code>-XX:MaxGCPauseMills</code> 设定的值，那么就会触发Young GC</p></li><li><p>MixedGC</p><p>不是FullGC，老年代的堆占有率达到参数(<code>-XX:InitiatingHeapOccupancyPercent</code>)设定的值则触发，回收所有的 Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做 MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC</p></li><li><p>Full GC </p><p>停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)</p></li></ul><h3 id="G1收集器参数设置"><a href="#G1收集器参数设置" class="headerlink" title="G1收集器参数设置"></a>G1收集器参数设置</h3><ul><li><p>-XX:+UseG1GC</p><p>使用G1收集器</p></li><li><p>-XX:ParallelGCThreads</p><p>指定GC工作的线程数量 </p></li><li><p>-XX:G1HeapRegionSize</p><p>指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区 </p></li><li><p>-XX:MaxGCPauseMillis</p><p>目标暂停时间(默认200ms)</p></li><li><p>-XX:G1NewSizePercent</p><p>新生代内存初始空间(默认整堆5%)</p></li><li><p>-XX:G1MaxNewSizePercent</p><p>新生代内存最大空间 </p></li><li><p>-XX:TargetSurvivorRatio</p><p>Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代 </p></li><li><p>-XX:MaxTenuringThreshold</p><p>最大年龄阈值(默认15) </p></li><li><p>-XX:InitiatingHeapOccupancyPercent</p><p>老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(MixedGC)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能 就要触发MixedGC了</p></li><li><p>-XX:G1MixedGCLiveThresholdPercent</p><p>默认85%,region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。</p></li><li><p>-XX:G1MixedGCCountTarget</p><p>在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一 会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长。</p></li><li><p>-XX:G1HeapWastePercent</p><p>默认5%，gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清 理掉，这样的话在回收过程就会不断空出来新Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。</p></li></ul><h3 id="G1垃圾收集器优化建议"><a href="#G1垃圾收集器优化建议" class="headerlink" title="G1垃圾收集器优化建议"></a>G1垃圾收集器优化建议</h3><p>假设参数 <code>-XX:MaxGCPauseMills</code> 设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才触发年轻代gc。 那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。 或者是你年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。</p><p>所以这里核心还是在于调节 <code>-XX:MaxGCPauseMills</code> 这个参数的值，在保证他的年轻代gc别太频繁的同时，还得考虑 每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触发mixed gc.</p><h3 id="G1使用场景"><a href="#G1使用场景" class="headerlink" title="G1使用场景"></a>G1使用场景</h3><ul><li>50%以上的堆被存活对象占用</li><li>对象分配和晋升的速度变化非常大 3. 垃圾回收时间特别长，超过1秒</li><li>8GB以上的堆内存(建议值)</li><li>停顿时间是500ms以内</li></ul><h2 id="ZGC收集器-XX-UseZGC"><a href="#ZGC收集器-XX-UseZGC" class="headerlink" title="ZGC收集器(-XX:+UseZGC)"></a>ZGC收集器(-XX:+UseZGC)</h2><p>参考文章:<a href="https://wiki.openjdk.java.net/display/zgc/Main">https://wiki.openjdk.java.net/display/zgc/Main</a> <a href="http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf">http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf</a></p><p>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器，ZGC可以说源自于是Azul System公司开发的 C4(Concurrent Continuously Compacting Collector) 收集器。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903151247.png" alt="image-20210903151246992" style="zoom:50%;" /><p>ZGC目标</p><p>如下图所示，ZGC的目标主要有4个:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903152053.png" alt="image-20210903152053533" style="zoom:50%;" /><ul><li><p>支持TB量级的堆。</p></li><li><p>最大GC停顿时间不超10ms。目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右， Major GC一般都需要100ms以上(G1可以调节停顿时间，但是如果调的过低的话，反而会适得其反)，之所以能做到这一点是因为它的停顿时间主要跟Root扫描有关，而Root数量和堆大小是没有任何关系的。</p></li><li><p>奠定未来GC特性的基础。</p></li><li><p>最糟糕的情况下吞吐量会降低15%。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。 另外，Oracle官方提到了它最大的优点是，它的停顿时间不会随着堆的增大而增长!也就是说，几十G堆的停顿时间是 10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。</p></li></ul><h3 id="不分代-暂时"><a href="#不分代-暂时" class="headerlink" title="不分代(暂时)"></a>不分代(暂时)</h3><p>单代，即ZGC「没有分代」。我们知道以前的垃圾回收器之所以分代，是因为源于“「大部分对象朝生夕死」”的假设，事实上大部分系统的对象分配行为也确实符合这个假设。 那么为什么ZGC就不分代呢。因为分代实现起来麻烦，作者就先实现出一个比较简单可用的单代版本，后续会优化。</p><h3 id="ZGC内存布局"><a href="#ZGC内存布局" class="headerlink" title="ZGC内存布局"></a>ZGC内存布局</h3><p>ZGC收集器是一款基于Region内存布局的， 暂时不设分代的， 使A用了读屏障、 颜色指针等技术来实现可并发的标记-整理算法的， 以低延迟为首要目标的一款垃圾收集器。<br>ZGC的Region可以具有大、 中、 小三类容量:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903154342.png" alt="image-20210903154342436" style="zoom:50%;" /><ul><li><p>小型Region(Small Region) : 容量固定为2MB， 用于放置小于256KB的小对象。 </p></li><li><p>中型Region(Medium Region) : 容量固定为32MB， 用于放置大于等于256KB但小于4MB的对象。 </p></li><li><p>大型Region(Large Region) : 容量不固定， 可以动态变化， 但必须为2MB的整数倍， 用于放置4MB或以上的大对象。 每个大型Region中只会存放一个大对象， 这也预示着虽然名字叫作“大型Region”， 但它的实际容量完全有可能小于中型Region， 最小容量可低至4MB。 大型Region在ZGC的实现中是不会被重分配的， 因为复制一个大对象的代价非常高昂。</p></li></ul><h3 id="NUMA-aware"><a href="#NUMA-aware" class="headerlink" title="NUMA-aware"></a>NUMA-aware</h3><p>NUMA对应的有UMA，UMA即Uniform Memory Access Architecture，NUMA就是Non Uniform Memory Access Architecture。UMA表示内存只有一块，所有CPU都去访问这一块内存，那么就会存在竞争问题(争夺内存总线访问权)，有竞争就会有锁，有锁效率就会受到影响，而且CPU核心数越多，竞争就越激烈。NUMA的话每个CPU对应有一 块内存，且这块内存在主板上离这个CPU是最近的，每个CPU优先访问这块内存，那效率自然就提高了:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903155148.png" alt="image-20210903155148324" style="zoom:50%;" /><p>服务器的NUMA架构在中大型系统上一直非常盛行，也是高性能的解决方案，尤其在系统延迟方面表现都很优秀。ZGC 是能自动感知NUMA架构并充分利用NUMA架构特性的。</p><h3 id="颜色指针"><a href="#颜色指针" class="headerlink" title="颜色指针"></a>颜色指针</h3><p>Colored Pointers，即颜色指针，如下图所示，ZGC的核心设计之一。以前的垃圾回收器的GC信息都保存在对象头中， 而ZGC的GC信息保存在指针中。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903155251.png" alt="image-20210903155251322" style="zoom:50%;" /><p>每个对象有一个64位指针，这64位被分为:</p><ul><li>18位:预留给以后使用;</li><li> 1位:Finalizable标识，此位与并发引用处理有关，它表示这个对象只能通过finalizer才能访问; </li><li>1位:Remapped标识，设置此位的值后，对象未指向relocation set中(relocation set表示需要GC的Region集合);</li><li>1位:Marked1标识; </li><li>1位:Marked0标识，和上面的Marked1都是标记对象用于辅助GC;</li><li> 42位:对象的地址(所以它可以支持2^42=4T内存):</li></ul><h4 id="为什么有2个mark标记"><a href="#为什么有2个mark标记" class="headerlink" title="为什么有2个mark标记?"></a>为什么有2个mark标记?</h4><p>每一个GC周期开始时，会交换使用的标记位，使上次GC周期中修正的已标记状态失效，所有引用都变成未标记。</p><ul><li>GC周期1:使用mark0, 则周期结束所有引用mark标记都会成为01。</li><li>GC周期2:使用mark1, 则期待的mark标记10，所有引用都能被重新标记。 通过对配置ZGC后对象指针分析我们可知，对象指针必须是64位，那么ZGC就无法支持32位操作系统，同样的也就无法支持压缩指针了(CompressedOops，压缩指针也是32位)。</li></ul><h4 id="颜色指针的三大优势"><a href="#颜色指针的三大优势" class="headerlink" title="颜色指针的三大优势:"></a>颜色指针的三大优势:</h4><ol><li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。</li><li>颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。</li><li>颜色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数 据，以便日后进一步提高性能。</li></ol><h4 id="读屏障-1"><a href="#读屏障-1" class="headerlink" title="读屏障"></a>读屏障</h4><p>之前的GC都是采用Write Barrier，这次ZGC采用了完全不同的方案读屏障，这个是ZGC一个非常重要的特性。 在标记和移动对象的阶段，每次「从堆里对象的引用类型中读取一个指针」的时候，都需要加上一个Load Barriers。 </p><p>那么我们该如何理解它呢?看下面的代码，第一行代码我们尝试读取堆中的一个对象引用obj.fieldA并赋给引用 o(fieldA也是一个对象时才会加上读屏障)。如果这时候对象在GC时被移动了，接下来JVM就会加上一个读屏障，这个屏障会把读出的指针更新到对象的新地址上，并且把堆里的这个指针“修正”到原本的字段里。这样就算GC把对象移动了，读屏障也会发现并修正指针，于是应用代码就永远都会持有更新后的有效指针，而且不需要STW。 </p><p>JVM是如何判断对象被移动过呢?就是利用上面提到的颜色指针，如果指针是Bad Color，那么程序还不能往下执行，需要「slow path」，修正指针;如果指针是Good Color，那么正常往下执行即可:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903160045.png" alt="image-20210903160045800" style="zoom:50%;" /><p>这个动作是不是非常像JDK并发中用到的CAS自旋?读取的值发现已经失效了，需要重新读取。而ZGC这里是之前持有的指针由于GC后失效了，需要通过读屏障修正指针。<br>后面3行代码都不需要加读屏障:</p><p>Object p = o这行代码并没有从堆中读取数据;</p><p>o.doSomething()也没有从堆中读取数据;</p><p>obj.fieldB不是对象引用，而是原子类型。</p><p>正是因为Load Barriers的存在，所以会导致配置ZGC的应用的吞吐量会变低。官方的测试数据是需要多出额外4%的开销:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903161130.png" alt="image-20210903161130125" style="zoom:50%;" /><p>判断对象是Bad Color还是Good Color的依据是什么呢?就是根据上一段提到的Colored Pointers的4个颜色位。 当加上读屏障时，根据对象指针中这4位的信息，就能知道当前对象是Bad/Good Color了。 </p><p>PS:既然低42位指针可以支持4T内存，那么能否通过预约更多位给对象地址来达到支持更大内存的目的呢?答案肯定是 不可以。因为目前主板地址总线最宽只有48bit，4位是颜色位，就只剩44位了，所以受限于目前的硬件，ZGC最大只能支持16T的内存，JDK13就把最大支持堆内存从4T扩大到了16T。</p><h3 id="ZGC运作过程"><a href="#ZGC运作过程" class="headerlink" title="ZGC运作过程"></a>ZGC运作过程</h3><p>ZGC的运作过程大致可划分为以下四个大的阶段:</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903161312.png" alt="image-20210903161312851" style="zoom:50%;" /><ul><li><p>并发标记(Concurrent Mark)</p><p>与G1一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记 (Mark Start)和最终标记(Mark End)也会出现短暂的停顿，与G1不同的是， ZGC的标记是在指针上而不是在对象上进行的， 标记阶段会更新染色指针中的Marked 0、 Marked 1标志位。</p></li><li><p>并发预备重分配(Concurrent Prepare for Relocate)</p><p>这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集(Relocation Set)。ZGC每次回收都会扫描所有的 Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</p></li><li><p>并发重分配(Concurrent Relocate)</p><p>重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表(Forward Table)，记录从旧对象 到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障(读屏障)所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”(Self-Healing)能力。</p></li><li><p>并发重映射(Concurrent Remap):重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。</p></li></ul><h3 id="ZGC存在的问题"><a href="#ZGC存在的问题" class="headerlink" title="ZGC存在的问题"></a>ZGC存在的问题</h3><p>ZGC最大的问题是浮动垃圾。ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。</p><p>ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。 </p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p><h3 id="ZGC参数设置"><a href="#ZGC参数设置" class="headerlink" title="ZGC参数设置"></a>ZGC参数设置</h3><p>启用ZGC比较简单，设置JVM参数即可:-XX:+UnlockExperimentalVMOptions 「-XX:+UseZGC」。调优也并不难， 因为ZGC调优参数并不多，远不像CMS那么复杂。它和G1一样，可以调优的参数都比较少，大部分工作JVM能很好的自 动完成。下图所示是ZGC可以调优的参数:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903162648.png" alt="image-20210903162648690"></p><h3 id="ZGC触发时机"><a href="#ZGC触发时机" class="headerlink" title="ZGC触发时机"></a>ZGC触发时机</h3><p>ZGC目前有4中机制触发GC</p><ul><li>定时触发，默认为不使用，可通过ZCollectionInterval参数配置。 </li><li>预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要时统计GC时间，为其他GC机制使用。</li><li>分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC(耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间)。</li><li>主动触发，(默认开启，可通过ZProactive参数配置) 距上次GC堆内存增长10%，或超过5分钟时，对比距上次GC的间隔时间跟(49 * 一次GC的最大持续时间)，超过则触发。</li></ul><h1 id="如何选择垃圾收集器"><a href="#如何选择垃圾收集器" class="headerlink" title="如何选择垃圾收集器"></a>如何选择垃圾收集器</h1><ul><li>优先调整堆的大小让服务器自己来选择</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择</li><li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li><li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li><li>4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC</li></ul><p>下图有连线的可以搭配使用</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210903163013.png" alt="image-20210903163013327"></p><h1 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h1><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC等，所以GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发。 </p><p>这些特定的安全点位置主要有以下几种:</p><ul><li>方法返回之前</li><li>调用某个方法之后</li><li>抛出异常的位置</li><li>循环的末尾</li></ul><p>大体实现思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志位， 各个线程执行过程 时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。 轮询标志的地方和安全点是重合的。</p><h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>Safe Point 是对正在执行的线程设定的。<br>如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。<br>因此 JVM 引入了 Safe Region。<br>Safe Region 是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾收集算法&quot;&gt;&lt;a href=&quot;#垃圾收集算法&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集算法&quot;&gt;&lt;/a&gt;垃圾收集算法&lt;/h1&gt;&lt;img src=&quot;https://hexo-img-1301602913.cos.ap-shanghai.myq</summary>
      
    
    
    
    
    <category term="JVM" scheme="https://tj-ever.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 内存结构</title>
    <link href="https://tj-ever.github.io/2021/08/24/JVM%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://tj-ever.github.io/2021/08/24/JVM%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2021-08-23T16:00:00.000Z</published>
    <updated>2021-09-06T06:52:05.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整体结构及内存模型"><a href="#整体结构及内存模型" class="headerlink" title="整体结构及内存模型"></a>整体结构及内存模型</h1><p>JVM内存结构主要有三大块：<strong>堆内存</strong>、<strong>方法区</strong>和<strong>栈</strong>。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>,默认情况下年轻代按照<strong>8:1:1</strong>的比例来分配；</p><p>方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；</p><p>栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</p><p><strong>Java堆（Heap）</strong></p><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<strong>最大</strong>的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例都在这里分配内存</strong>。</p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong>GC堆</strong>”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：<strong>新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</strong></p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><p><strong>方法区（Method Area）</strong></p><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><p>方法区有时被称为持久代（PermGen）。</p><p><strong>程序计数器（Program Counter Register）</strong></p><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p><p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p><p><strong>JVM栈（JVM Stacks）</strong></p><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<strong>它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：</strong>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong></p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><p><strong>本地方法栈（Native Method Stacks）</strong></p><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务。</strong>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210824144146.png" alt="image-20210824144146815"></p><p>所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor Sapce)，老年代（Old Generation Space）。</p><p>方法的执行都是伴随着线程的。原始类型的本地变量以及引用都存放在线程栈中。而引用关联的对象比如String，都存在在堆中。为了更好的理解上面这段话，我们可以看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = Logger.getLogger(HelloWorld.class.getName()); </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String message)</span> </span>&#123; </span><br><span class="line">    SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;dd.MM.YYYY&quot;</span>); </span><br><span class="line">    String today = formatter.format(<span class="keyword">new</span> Date()); </span><br><span class="line">    LOGGER.info(today + <span class="string">&quot;: &quot;</span> + message); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序的数据在内存中的存放如下：</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210824151536.png" alt="image-20210824151536623"></p><h1 id="内存参数设置"><a href="#内存参数设置" class="headerlink" title="内存参数设置"></a>内存参数设置</h1><blockquote><p>控制参数</p><p>-Xms设置堆的最小空间大小。</p><p>-Xmx设置堆的最大空间大小。</p><p>-XX:NewSize设置新生代最小空间大小。</p><p>-XX:MaxNewSize设置新生代最大空间大小。</p><p>-XX:PermSize设置永久代最小空间大小。</p><p>-XX:MaxPermSize设置永久代最大空间大小。</p><p>-Xss设置每个线程的堆栈大小。</p><p>老年代空间大小=堆空间大小-年轻代大空间大小</p></blockquote><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210824150211.png" alt="image-20210824150211522" style="zoom:50%;" /><p>Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐eurek a‐server.jar</span><br></pre></td></tr></table></figure><p>关于元空间的JVM参数有两个:-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N<br> -XX:MaxMetaspaceSize: 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。<br> -XX:MetaspaceSize: 指定元空间触发Full gc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发 full gc进行类型卸载， 同时收集器会对该值进行调整: 如果释放了大量的空间， 就适当降低该值; </p><p>如果释放了很少的空间， 那么在不超过-XX:MaxMetaspaceSize 的情况下，适当提高该值。这个跟早期jdk版本的-XX:PermSize参数意思不一样，- XX:PermSize代表永久代的初始容量。<br>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生 了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大， 对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。</p><p>StackOverflowError示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JVM设置 ‐Xss128k(默认1M) </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflowTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    count++;</span><br><span class="line">    redo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">     redo();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">     t.printStackTrace();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果:</span></span><br><span class="line"><span class="comment">//java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">//at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:12)</span></span><br><span class="line"><span class="comment">//at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:13)</span></span><br><span class="line"><span class="comment">//at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:13)</span></span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure><p>结论:  -Xss设置越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多</p><h1 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h1><p>java对象由如下几部分组成：</p><ol><li>对象头：Mark word和klasspointer两部分组成，如果是数组，还包括数组长度</li><li>实例属性</li><li>对齐填充</li></ol><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210827142904.png" alt="image-20210827142904037" style="zoom:50%;" /><p>如何能看到上图结构？</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210827154023.png" alt="img"></p><p>注意：要打印上述内存结构图，需要引入如下依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>HotSpot虚拟机的对象头包括两部分信息。</p><p>第一部分用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p><p>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>如果是数组，还包括数组长度</strong></p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210827160139.png" alt="image-20210827160139439"></p><p><strong>注意：JVM会默认使用选项 +UseCompressedOops 开启指针压缩，将指针压缩至32位。</strong></p><h2 id="对象属性数据区"><a href="#对象属性数据区" class="headerlink" title="对象属性数据区"></a>对象属性数据区</h2><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210827163138.png" alt="img"></p><h2 id="对齐填充区"><a href="#对齐填充区" class="headerlink" title="对齐填充区"></a>对齐填充区</h2><p>Java对象占用空间是8字节对齐的，即所有Java对象占用字节数必须是8的倍数。如下图所示：</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210827163155.png" alt="img"></p><h1 id="对象创建流程"><a href="#对象创建流程" class="headerlink" title="对象创建流程"></a>对象创建流程</h1><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210827114230.png" alt="image-20210827114230551" style="zoom:50%;" /><h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a><strong>类加载检查</strong></h2><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 </p><p>new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。</p><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</p><p>这个步骤有两个问题:<br> 1.如何划分内存。<br> 2.在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p><h3 id="划分内存"><a href="#划分内存" class="headerlink" title="划分内存"></a>划分内存</h3><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><p>“指针碰撞”(Bump the Pointer)(默认用指针碰撞)</p><p>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p><h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><p>“空闲列表”(Free List)<br>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录</p><h3 id="解决并发"><a href="#解决并发" class="headerlink" title="解决并发"></a>解决并发</h3><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS(compare and swap) 虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</p><h4 id="本地线程分配缓冲"><a href="#本地线程分配缓冲" class="headerlink" title="本地线程分配缓冲"></a>本地线程分配缓冲</h4><p>本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)，把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过­XX:+/­ UseTLAB参数来设定虚拟机是否使用TLAB(JVM会默认开启­XX:+UseTLAB)，­XX:TLABSize 指定TLAB大小。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。 </p><h2 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h2><p> 执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值(注意，这与上面的赋零值不同，这是由程序员赋的值)，和执行构造方法。</p><h1 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h1><p>jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩 </p><p>jvm配置参数:UseCompressedOops，compressed­­压缩、oop(ordinary object pointer)­­对象指针 </p><p>启用指针压缩:­XX:+UseCompressedOops(默认开启)，禁止指针压缩:­XX:­-UseCompressedOops</p><p><strong>为什么要进行指针压缩</strong> </p><ol><li><p>在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据， 占用较大宽带，同时GC也会承受较大压力，为了减少64位平台下内存的消耗，启用指针压缩功能 </p></li><li><p>在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm 只用32位地址就可以支持更大的内存配置(小于等于32G)</p></li><li><p>堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间 </p></li><li><p>堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p></li></ol><h1 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h1><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210827165138.png" alt="image-20210827165138282"></p><h2 id="对象栈上分配"><a href="#对象栈上分配" class="headerlink" title="对象栈上分配"></a>对象栈上分配</h2><p>通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。</p><p>为了减少临时对象在堆内分配的数量，JVM通过逃逸分析确定该对象不会被外部访问。<strong>如果不会逃逸可以将该对象在栈上分配内存</strong>，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><h3 id="对象逃逸分析"><a href="#对象逃逸分析" class="headerlink" title="对象逃逸分析"></a>对象逃逸分析</h3><p>就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   User user = <span class="keyword">new</span> User();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setName(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">   <span class="comment">//TODO 保存到数据库</span></span><br><span class="line">   <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"> User user = <span class="keyword">new</span> User(); </span><br><span class="line"> user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setName(<span class="string">&quot;zhuge&quot;</span>); </span><br><span class="line">   <span class="comment">//TODO 保存到数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然test1方法中的user对象被返回了，这个对象的作用域范围不确定，test2方法中的user对象我们可以确定当方法结束这个对象就可以认为是无效对象了，对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内 存一起被回收掉。</p><p> JVM对于这种情况可以通过开启逃逸分析参数(<code>-XX:+DoEscapeAnalysis</code>)来优化对象内存分配位置，使其通过标量替换优先分配在栈上(栈上分配)。JDK7之后默认开启逃逸分析，如果要关闭使用参数(<code>-XX:-DoEscapeAnalysis</code>) </p><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p>通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是<strong>将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间</strong>，这样就不会因为没有一大块连续空间导致对象内存不够分配。</p><p>开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认 开启。 </p><h3 id="标量与聚合量"><a href="#标量与聚合量" class="headerlink" title="标量与聚合量"></a>标量与聚合量</h3><p>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量(如:int，long等基本数据类型以及 reference类型等)，标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一 步分解的聚合量。</p><h3 id="栈上分配示例"><a href="#栈上分配示例" class="headerlink" title="栈上分配示例"></a>栈上分配示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 栈上分配，标量替换 代码调用了1亿次alloc()，如果是分配到堆上，大概需要1GB以上堆空间，如果堆空间小于该值，必然会触发GC。</span></span><br><span class="line"><span class="comment">* 使用如下参数不会发生GC</span></span><br><span class="line"><span class="comment">* ‐Xmx15m ‐Xms15m ‐XX:+DoEscapeAnalysis ‐XX:+PrintGC ‐XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment">* 使用如下参数都会发生大量GC</span></span><br><span class="line"><span class="comment">* ‐Xmx15m ‐Xms15m ‐XX:‐DoEscapeAnalysis ‐XX:+PrintGC ‐XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment">* ‐Xmx15m ‐Xms15m ‐XX:+DoEscapeAnalysis ‐XX:+PrintGC ‐XX:‐EliminateAllocations</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllotOnStack</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123; </span><br><span class="line">      alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis(); </span><br><span class="line">    System.out.println(end ‐ start);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>); </span><br><span class="line">    user.setName(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论:栈上分配依赖于逃逸分析和标量替换</strong></p><h2 id="对象在Eden区分配"><a href="#对象在Eden区分配" class="headerlink" title="对象在Eden区分配"></a>对象在Eden区分配</h2><blockquote><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><p>Minor GC/Young GC:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</p><p>Major GC/Full GC:一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢 10倍以上。</p><p>Eden与Survivor区默认8:1:1</p></blockquote><p>大量对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，让eden区尽量的大，survivor区够用即可。</p><p>JVM默认有这个参数<code>-XX:+UseAdaptiveSizePolicy</code>(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数</p><p><code>-XX:-UseAdaptiveSizePolicy</code></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加运行JVM参数: ‐XX:+PrintGCDetails </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2<span class="comment">/*, allocation3, allocation4, allocation5, allocation6*/</span>;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//allocation2 = new byte[8000*1024];</span></span><br><span class="line">    <span class="comment">/*allocation3 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">allocation4 = new byte[1000*1024]; </span></span><br><span class="line"><span class="comment">allocation5 = new byte[1000*1024]; </span></span><br><span class="line"><span class="comment">allocation6 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">Heap</span><br><span class="line">  PSYoungGen total 76288K, used 65536K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000770900000</span>, <span class="number">0x00000007c0000000</span>) </span><br><span class="line">  eden space 65536K, <span class="number">100</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076fe80000</span>,<span class="number">0x000000076fe80000</span>,<span class="number">0x0000000770900000</span>)</span><br><span class="line">  to space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f400000</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line">  ParOldGen total 175104K, used 0K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>) </span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006cc700000</span>) Metaspace used 3342K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 361<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>可以看出eden区内存几乎已经被分配完全(即使程序什么也不做，新生代也会使用至少几M内存)。假如再为 allocation2分配内存会出现什么情况呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加运行JVM参数: ‐XX:+PrintGCDetails </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2<span class="comment">/*, allocation3, allocation4, allocation5, allocation6*/</span>;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8000</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">/*allocation3 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">allocation4 = new byte[1000*1024]; </span></span><br><span class="line"><span class="comment">allocation5 = new byte[1000*1024]; </span></span><br><span class="line"><span class="comment">allocation6 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">[GC(AllocationFailure)[PSYoungGen:65253K‐&gt;936K(76288K)]65253K‐&gt;60944K(251392K),<span class="number">0.</span>0279083secs][Times:user=<span class="number">0.13</span> sys=<span class="number">0.02</span>, real=<span class="number">0.03</span> secs]</span><br><span class="line">Heap</span><br><span class="line">  PSYoungGen total 76288K, used 9591K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000774900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">13</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076bc73ef8</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space 10752K, <span class="number">8</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f4ea020</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line">  to space 10752K, <span class="number">0</span>% used [<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000774900000</span>)</span><br><span class="line">  ParOldGen total 175104K, used 60008K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space 175104K, <span class="number">34</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c569a010</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line">  Metaspace used 3342K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 361<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>给allocation2分配内存的时候eden区内存几乎已经被分配完了，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，GC期间虚拟机又发现allocation1无法存入 Survior空间，所以只好把新生代的对象提前转移到老年代中去，老年代上的空间足够存放allocation1，所以不会出现 Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。</p><p>可以执行如下代码验证:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加运行JVM参数: ‐XX:+PrintGCDetails </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2<span class="comment">/*, allocation3, allocation4, allocation5, allocation6*/</span>;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8000</span>*<span class="number">1024</span>];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>]; </span><br><span class="line">allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>]; </span><br><span class="line">allocation6 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">[GC(AllocationFailure)[PSYoungGen:65253K‐&gt;952K(76288K)]65253K‐&gt;60960K(251392K),<span class="number">0.</span>0311467secs][Times: user=<span class="number">0.08</span> sys=<span class="number">0.02</span>, real=<span class="number">0.03</span> secs]</span><br><span class="line">Heap</span><br><span class="line">  PSYoungGen total 76288K, used 13878K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000774900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">19</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076c09fb68</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space 10752K, <span class="number">8</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f4ee030</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line">  to space 10752K, <span class="number">0</span>% used [<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000774900000</span>)</span><br><span class="line">  ParOldGen total 175104K, used 60008K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space 175104K, <span class="number">34</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c569a010</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line">  Metaspace used 3343K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 361<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>大对象就是需要大量连续内存空间的对象(比如:字符串、数组)。</p><p>JVM参数 <code>-XX:PretenureSizeThreshold</code> 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。</p><p>比如设置JVM参数:<code>-XX:PretenureSizeThreshold=1000000</code> (单位是字节) <code>-XX:+UseSerialGC</code> ，再执行下上面的第一个程序会发现大对象直接进了老年代</p><p>为什么要这样呢?<br>为了避免为大对象分配内存时的复制操作而降低效率。</p><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>虚拟机采用了分代收集的思想来管理内存，内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中，为了做到这一点，虚拟机给每个对象一个对象年龄(Age)计数器。<br>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度 (默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同)，就会被晋升到老年代中。</p><p>对象晋升到老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>来设置。</p><h2 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a>对象动态年龄判断</h2><p>当前放对象的Survivor区域里，一批对象的总大小大于这块Survivor区域内存大小的 50%(<code>-XX:TargetSurvivorRatio</code>可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了。</p><p>例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发的。</p><h2 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a>老年代空间分配担保机制</h2><p>年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间 ，如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象) </p><p>，就会看一个<code>-XX:-HandlePromotionFailure</code>(jdk1.8默认就设置了)的参数是否设置了 。</p><p>如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。 如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾， 如果回收完还是没有足够空间存放新的对象就会发生”OOM”</p><p>当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210827175652.png" alt="image-20210827175651987" style="zoom:50%;" /><h1 id="对象内存回收"><a href="#对象内存回收" class="headerlink" title="对象内存回收"></a>对象内存回收</h1><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡(即不能再被任何途径使用的对象)</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1;当引用失效，计数器就减1;任何时候计数器为0 的对象就是不可能再被使用的。 </p><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 </p><p>所谓对象之间的相互引用问题，如下面代码所示:除了对象objA 和 objB 相互引用着对 方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算 法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span></span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>将“GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的对象都是垃圾对象。</p><p>GC Roots根节点:线程栈的本地变量、静态变量、本地方法栈的变量等等</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210827180518.png" alt="image-20210827180518060" style="zoom:50%;" /><h1 id="常见引用类型"><a href="#常见引用类型" class="headerlink" title="常见引用类型"></a>常见引用类型</h1><p>java的引用类型一般分为四种:强引用、软引用、弱引用、虚引用 </p><ul><li><p>强引用:</p><p>普通的变量引用 public static User user=new User();</p></li></ul><ul><li><p>软引用</p><p>将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放 新的对象，则会把这些软引用的对象回收掉。软引用可用来实现内存敏感的高速缓存。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;User&gt; user = <span class="keyword">new</span> SoftReference&lt;User&gt;(newUser());</span><br></pre></td></tr></table></figure></li><li><p>弱引用</p><p>将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WeakReference&lt;User&gt;user=newWeakReference&lt;User&gt;(newUser());</span><br></pre></td></tr></table></figure></li><li><p>虚引用</p><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</p></li></ul><h1 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h1><p>finalize()方法最终判定对象是否存活</p><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p><p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong></p><ul><li><p>第一次标记并进行一次筛选。</p><p>筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize方法，对象将直接被回收。</p></li><li><p>第二次标记</p><p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。 </p><p>注意:一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。</p></li></ul><h1 id="判断一个类是无用的类"><a href="#判断一个类是无用的类" class="headerlink" title="判断一个类是无用的类"></a>判断一个类是无用的类</h1><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢</p><p>类需要同时满足下面3个条件才能算是 “无用的类” :</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;整体结构及内存模型&quot;&gt;&lt;a href=&quot;#整体结构及内存模型&quot; class=&quot;headerlink&quot; title=&quot;整体结构及内存模型&quot;&gt;&lt;/a&gt;整体结构及内存模型&lt;/h1&gt;&lt;p&gt;JVM内存结构主要有三大块：&lt;strong&gt;堆内存&lt;/strong&gt;、&lt;strong</summary>
      
    
    
    
    
    <category term="JVM" scheme="https://tj-ever.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 类加载机制</title>
    <link href="https://tj-ever.github.io/2021/08/24/JVM%20%E7%B1%BB%E5%8A%A0%E8%BD%BD&amp;%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"/>
    <id>https://tj-ever.github.io/2021/08/24/JVM%20%E7%B1%BB%E5%8A%A0%E8%BD%BD&amp;%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</id>
    <published>2021-08-23T16:00:00.000Z</published>
    <updated>2021-08-24T06:24:45.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h1><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的<code>Class</code>对象，<code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210824104244.png" alt="202105221032358441.png"></p><p>类加载</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）。如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><p><strong>加载.class文件的方式</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210824104404.png" alt="202105221032365332.png"></p><p>类的生命周期</p><p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>查找并加载类的二进制数据。加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</li></ul><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><strong>确保被加载的类的正确性</strong></p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了<code>java.lang.Object</code>之外。</li><li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><strong>符号引用验证</strong>：确保解析动作能正确执行。</li></ul><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>为类的<code>静态变量</code>分配内存，并将其初始化为默认值</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ul><li>1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li></ul><p>假设一个类变量的定义为：<code>public static int value = 3;</code></p><p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>public static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p><blockquote><p>这里还需要注意如下几点：</p><ul><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li></ul></blockquote><ul><li>3、如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</li></ul><p>假设上面的类变量value被定义为： <code>public static final int value = 3</code>；</p><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据<code>ConstantValue</code>的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><strong>把类中的符号引用转换为直接引用</strong></p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><p><strong>符号引用</strong>就是一组符号来描述目标，可以是任何字面量。</p><p><strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>①声明类变量时指定初始值</li><li>②使用静态代码块为类变量指定初始值</li></ul><p>JVM初始化步骤</p><ul><li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如<code>Class.forName(“com.shengsiyuan.Test”)</code>）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类（<code>Java Test</code>），直接使用<code>java.exe</code>命令来运行某个主类</li></ul><h2 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h2><p>在如下几种情况下，Java虚拟机将结束生命周期：</p><ul><li>执行了<code>System.exit()</code>方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行后，输出结果：</span></span><br><span class="line"><span class="comment">//sun.misc.Launcher$AppClassLoader@64fef26a</span></span><br><span class="line"><span class="comment">//sun.misc.Launcher$ExtClassLoader@1ddd40f3</span></span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure><p><strong>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code>的父Loader，原因是<code>Bootstrap Loader</code>（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</strong></p><p>这几种类加载器的层次关系如下图所示：</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210824110943.png" alt="202105221032370933.png"></p><p>类加载器的层次关系</p><blockquote><p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：</p><ul><li><strong><em>启动类加载器</em></strong>：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；</li><li><strong><em>其它的类加载器</em></strong>：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li></ul><p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p><ul><li><strong>启动类加载器</strong>：<code>Bootstrap ClassLoader</code>，负责加载存放在<code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被<code>Bootstrap ClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。</li><li><strong>扩展类加载器</strong>：<code>Extension ClassLoader</code>，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li><li><strong>应用程序类加载器</strong>：<code>Application ClassLoader</code>，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，<strong>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</strong></li></ul><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li>1、在执行非置信代码之前，自动验证数字签名。</li><li>2、动态地创建符合用户特定需要的定制化构建类。</li><li>3、从特定的场所取得java class，例如数据库中和网络中。</li></ul><p><strong>JVM类加载机制</strong></p><ul><li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。<strong>这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</strong></li></ul><h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><p>类加载有三种方式：</p><ul><li>1、命令行启动应用时候由JVM初始化加载</li><li>2、通过Class.forName()方法动态加载</li><li>3、通过ClassLoader.loadClass()方法动态加载</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoaderTest</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123; </span><br><span class="line">           ClassLoader loader = Test2.class.getClassLoader(); </span><br><span class="line">           System.out.println(loader); </span><br><span class="line">           <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">           loader.loadClass(<span class="string">&quot;Test2&quot;</span>); </span><br><span class="line">          </span><br><span class="line">      <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line">           <span class="comment">//Class.forName(&quot;Test2&quot;); </span></span><br><span class="line">           </span><br><span class="line">      <span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line">           <span class="comment">//Class.forName(&quot;Test2&quot;, false, loader); </span></span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123; </span><br><span class="line">        <span class="keyword">static</span> &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;静态初始化块执行了！&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别切换加载方式，会有不同的输出结果。</p><p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p><ul><li><code>Class.forName()</code>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。</li><li><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance时才会去执行static块。</li><li><code>Class.forName(name, initialize, loader)</code>：带参函数可控制是否加载static块。initialize为true时加载，为false时不加载。</li></ul><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p><strong>一个类加载器示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDKClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(String.class.getClassLoader());</span><br><span class="line">     System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</span><br><span class="line">     System.out.println(TestJDKClassLoader.class.getClassLoader().getClass().<span class="function">getN <span class="title">ame</span><span class="params">()</span>)</span>;</span><br><span class="line"></span><br><span class="line">   System.out.println();</span><br><span class="line">     ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">     ClassLoader extClassloader = appClassLoader.getParent();</span><br><span class="line">     ClassLoader bootstrapLoader = extClassloader.getParent();</span><br><span class="line">     System.out.println(<span class="string">&quot;the bootstrapLoader : &quot;</span> + bootstrapLoader);</span><br><span class="line">     System.out.println(<span class="string">&quot;the extClassloader : &quot;</span> + extClassloader);</span><br><span class="line">     System.out.println(<span class="string">&quot;the appClassLoader : &quot;</span> + appClassLoader);</span><br><span class="line">    </span><br><span class="line">     System.out.println(); </span><br><span class="line">     System.out.println(<span class="string">&quot;bootstrapLoader加载以下文件:&quot;</span>); </span><br><span class="line">     URL[] urls = Launcher.getBootstrapClassPath().getURLs(); </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123; </span><br><span class="line">        System.out.println(urls[i]);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(<span class="string">&quot;extClassloader加载以下文件:&quot;</span>); </span><br><span class="line">    System.out.println(System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line">    System.out.println(); System.out.println(<span class="string">&quot;appClassLoader加载以下文件:&quot;</span>);</span><br><span class="line">    System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果:</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line">  </span><br><span class="line">the bootstrapLoader:<span class="keyword">null</span> theextClassloader:sun.misc.Launcher$ExtClassLoader@<span class="number">3764951d</span></span><br><span class="line">the appClassLoader:sun.misc.Launcher$AppClassLoader@14dad5dc</span><br><span class="line"></span><br><span class="line">bootstrapLoader加载以下文件: </span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/resources.jar </span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/rt.jar </span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/sunrsasign.jar </span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/jsse.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/jce.jar </span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/charsets.jar </span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/jfr.jar </span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/classes</span><br><span class="line">  </span><br><span class="line">extClassloader加载以下文件:</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br><span class="line"></span><br><span class="line">appClassLoader加载以下文件:(全部加载)</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\charsets.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\deploy.jar;</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\access‐bridge‐<span class="number">64.</span>jar;</span><br><span class="line">D:\dev\Jav\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\cldrdata.jar;</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\dnsns.jar;</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\jaccess.jar;</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\jfxrt.jar;</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\localedata.jar;</span><br><span class="line">......</span><br><span class="line">C:\Users\zhuge\.m2\repository\netty\netty\<span class="number">3.10</span><span class="number">.6</span>.Final\netty‐<span class="number">3.10</span><span class="number">.6</span>.Final.jar;</span><br><span class="line">C:\Users\zhuge\.m2\repository\com\google\j2objc\j2objc‐annotations\<span class="number">1.1</span>\jobjc‐annotations‐<span class="number">1.1</span>.jar;</span><br><span class="line">D:\dev\IntelliJ IDEA <span class="number">2018.3</span><span class="number">.2</span>\lib\idea_rt.jar</span><br></pre></td></tr></table></figure><h2 id="类加载器初始化过程"><a href="#类加载器初始化过程" class="headerlink" title="类加载器初始化过程"></a>类加载器初始化过程</h2><p>JVM启动会创建实例sun.misc.Launcher。 </p><p>sun.misc.Launcher初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个 sun.misc.Launcher实例。<br>在Launcher构造方法内部，其创建了两个类加载器，分别是 sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应用类加载器)。</p><p><strong>JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们的应用程序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Launcher的构造方法 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span></span>&#123;</span><br><span class="line">Launcher.ExtClassLoader var1;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//构造扩展类加载器，在构造的过程中将其父加载器设置为null</span></span><br><span class="line">var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="comment">//构造应用类加载器，在构造的过程中将其父加载器设置为ExtClassLoader，</span></span><br><span class="line"> <span class="comment">//Launcher的loader属性值是AppClassLoader，我们一般都是用这个类加载器来加载我们自己写的应用程序</span></span><br><span class="line"> <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader); </span><br><span class="line">   String var2 = System.getProperty(<span class="string">&quot;java.security.manager&quot;</span>);</span><br><span class="line">  <span class="comment">//。。。 。。。 省略一些不需关注代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM类加载器是有亲子结构的</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210824120634.png" alt="image-20210824120634926"></p><p>这里类加载其实就有一个双亲委派机制，加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。 </p><p>比如我们自己写的DTO类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天没找到DTO类，则向下退回加载DTO类的请求，扩展类加载器收到回复就自己加载，在自己的类加载路径里找了半天也没找到DTO类，又向下退回DTO类的加载请求给应用程序类加载器， 应用程序类加载器于是在自己的类加载路径里找DTO类，结果找到了就自己加载了。</p><p> 双亲委派机制说简单点就是，先找parent（双亲）加载，不行再由儿子自己加载。</p><p><strong>双亲委派机制：</strong></p><ul><li><p>1、当<code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</p></li><li><p>2、当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</p></li><li><p>3、如果<code>BootStrapClassLoader</code>加载失败（例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用<code>ExtClassLoader</code>来尝试加载；</p></li><li><p>4、若ExtClassLoader也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</p></li></ul><p>ClassLoader源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 首先判断该类型是否已经被加载</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//如果存在父类加载器，就委派给父类加载器加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，</span></span><br><span class="line">                <span class="comment">//通过调用本地方法native Class findBootstrapClass(String name)</span></span><br><span class="line">                    c = findBootstrapClass0(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">             <span class="comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>为什么要设计双亲委派机制</strong>? </p><p>沙箱安全机制:自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改 </p><p>避免类的重复加载:当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性</p><p>看一个类加载示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">      System.out.println(<span class="string">&quot;**************My String Class**************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args)</span></span><br><span class="line"><span class="comment">//否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，</p><p>一个是 loadClass(String, boolean)，实现了双亲委派机制，</p><p>还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是重写该方法。</p><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自<code>ClassLoader</code>类，从上面对<code>loadClass</code>方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.classloader;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">         <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">         <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">         String fileName = root + File.separatorChar</span><br><span class="line">                 + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">             ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">             <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">             <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">             <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                 baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.root = root;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">         <span class="comment">//初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载</span></span><br><span class="line"> <span class="comment">//器设置为应用程序类加载器AppClassLoader</span></span><br><span class="line">         MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">       </span><br><span class="line">         <span class="comment">//E盘创建 temp/com/neo/classloader 几级目录，将Test类的复制类Test2.class丢入该目录</span></span><br><span class="line">         classLoader.setRoot(<span class="string">&quot;E:\\temp&quot;</span>);</span><br><span class="line">    </span><br><span class="line">         Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             testClass = classLoader.loadClass(<span class="string">&quot;com.neo.classloader.Test2&quot;</span>);</span><br><span class="line">             Object object = testClass.newInstance();</span><br><span class="line">             System.out.println(object.getClass().getClassLoader());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p><ul><li>1、这里传递的文件名需要是类的全限定性名称，即<code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的。</li><li>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</li><li>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把<code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由<code>AppClassLoader</code>加载，而不会通过我们自定义类加载器来加载。</li></ul><h2 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h2><p>再来一个沙箱安全机制示例，尝试打破双亲委派机制，用自定义类加载器加载我们自己实现的 java.lang.String.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">         FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">&quot;/&quot;</span> + name + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">         <span class="keyword">int</span> len = fis.available();</span><br><span class="line">         <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">         fis.read(data);</span><br><span class="line">         fis.close();</span><br><span class="line">         <span class="keyword">return</span> data;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123; </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line"><span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"><span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"><span class="keyword">if</span>(c==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">      <span class="comment">//尝试用自己改写类加载机制去加载自己写的java.lang.String.class</span></span><br><span class="line">       Class clazz = classLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"> Object obj = clazz.newInstance();</span><br><span class="line"> Method method= clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"> method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"> System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果:</span></span><br><span class="line"><span class="comment">// java.lang.SecurityException:Prohibitedpackagename:java.lang</span></span><br><span class="line"><span class="comment">// at java.lang.ClassLoader.preDefineClass(ClassLoader.java:659)</span></span><br><span class="line"><span class="comment">// at java.lang.ClassLoader.defineClass(ClassLoader.java:758)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要将       Class clazz = classLoader.loadClass(&quot;java.lang.String&quot;);</span></span><br><span class="line"><span class="comment">//改为非java开头路径 ，这是jvm的安全机制</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h1><p>双亲委派模型主要出现过 3 较大规模的“被破坏”情况。</p><ol><li>双亲委派模型在引入之前已经存在破坏它的代码存在了。<br>双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 <code>java.lang.ClassLoader</code> 则在 JDK 1.0 时代就已经存在，JDK 1.2之后，其添加了一个新的 protected 方法 <code>findClass()</code>，在此之前，用户去继承 ClassLoader 类的唯一目的就是为了重写 <code>loadClass()</code> 方法，而双亲委派的具体逻辑就实现在这个方法之中，JDK 1.2 之后已不提倡用户再去覆盖 <code>loadClass()</code> 方法，而应当把自己的类加载逻辑写到 <code>findClass()</code> 方法中，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</li><li>基础类无法调用类加载器加载用户提供的代码。<br>双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），但如果基础类又要调用用户的代码，例如 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进去的 rt.jar ），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI,Service Provider Interface，例如 JDBC 驱动就是由 MySQL 等接口提供者提供的）的代码，但启动类加载器只能加载基础类，无法加载用户类。</li></ol><blockquote><p>为此 Java 引入了线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过 <code>java.lang.Thread.setContextClassLoaser()</code> 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br>如此，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。</p></blockquote><ol><li>用户对程序动态性的追求。<br>代码热替换（HotSwap）、模块热部署（Hot Deployment）等，OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。</li></ol><blockquote><p>在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：<br>1）将以 java.* 开头的类委派给父类加载器加载。<br>2）否则，将委派列表名单内的类委派给父类加载器加载。<br>3）否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载。<br>4）否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。<br>5）否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。<br>6）否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。<br>7）否则，类查找失败。<br>上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。OSGi 的 Bundle 类加载器之间只有规则，没有固定的委派关系。</p></blockquote><p><strong>第四次破坏双亲委派：JDK的模块化</strong></p><p>在JDK9之前，JVM的基础类以前都是在rt.jar这个包里，这个包也是JRE运行的基石。这不仅是违反了单一职责原则，同样程序在编译的时候会将很多无用的类也一并打包，造成臃肿。</p><p>在JDK9中，整个JDK都基于模块化进行构建，以前的rt.jar, tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块，同时各个类加载器各司其职，只加载自己负责的模块。</p><p><strong>模块化加载源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = findLoadedClass(cn);</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 找到当前类属于哪个模块</span></span><br><span class="line">         LoadedModule loadedModule = findLoadedModule(cn);</span><br><span class="line">         <span class="keyword">if</span> (loadedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取当前模块的类加载器</span></span><br><span class="line">            BuiltinClassLoader loader = loadedModule.loader();</span><br><span class="line">            <span class="comment">//进行类加载</span></span><br><span class="line">            c = findClassInModuleOrNull(loadedModule, cn);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找不到模块信息才会进行双亲委派</span></span><br><span class="line">         <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">           c = parent.loadClassOrNull(cn);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是类的加载&quot;&gt;&lt;a href=&quot;#什么是类的加载&quot; class=&quot;headerlink&quot; title=&quot;什么是类的加载&quot;&gt;&lt;/a&gt;什么是类的加载&lt;/h1&gt;&lt;p&gt;类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后</summary>
      
    
    
    
    
    <category term="JVM" scheme="https://tj-ever.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线程池相关学习</title>
    <link href="https://tj-ever.github.io/2021/08/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/"/>
    <id>https://tj-ever.github.io/2021/08/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-08-10T06:27:38.342Z</published>
    <updated>2021-08-17T09:57:15.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在执行一个异步任务或并发任务时，往往是通过直接<code>new Thread()</code>方法来创建新的线程，这样做弊端较多，更好的解决方案是合理地利用线程池，线程池的优势很明显，如下：</p><ol><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li><li>提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行；</li><li>方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率；</li><li>更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。</li></ol><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h3><p>实现runnanle接口的类将被Thread执行，表示一个基本的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// run方法就是实际执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p>callable接口同样是任务，与runnable接口的区别是它接收泛型，并且执行任务后带有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 相对于run方法带有返回值的call方法</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法。</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210816152127.png" alt="image-20210816152126848"></p><p>Executor下有一个重要子接口ExecutorService，其中定义了线程池的具体行为</p><ul><li><p>execute(Runnable command):履行Ruannable类型的任务</p></li><li><p>submit(task):可用来提交Callable或Runnable任务，并返回代表此任务的Future 对象</p></li><li><p>shutdown():在完成已提交的任务后封闭办事，不再接管新任务</p></li><li><p>shutdownNow():停止所有正在履行的任务并封闭办事</p></li><li><p>isTerminated():测试是否所有任务都履行完毕了</p></li><li><p>isShutdown():测试是否该ExecutorService已被关闭</p></li></ul><h2 id="重点属性"><a href="#重点属性" class="headerlink" title="重点属性"></a>重点属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来标记线程池状态（高3位），线程个数（低29位）</span></span><br><span class="line"><span class="comment">//默认是RUNNING状态，线程个数为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程个数掩码位数，并不是所有平台int类型是32位，所以准确说是具体平台下Integer的二进制位数-3后的剩余位数才是线程的个数，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程最大个数(低29位)00011111111111111111111111111111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池状态</span></span><br><span class="line"><span class="comment">//（高3位）：11100000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（高3位）：00000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（高3位）：00100000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（高3位）：01000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（高3位）：01100000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 获取高三位 运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取低29位 线程个数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算ctl新值，线程状态 与 线程个数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h2 id="线程池状态切换"><a href="#线程池状态切换" class="headerlink" title="线程池状态切换"></a>线程池状态切换</h2><p>1、RUNNING</p><ul><li>状态说明:线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。</li><li>状态切换:线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0</li></ul><p>2、 SHUTDOWN</p><ul><li>状态说明:线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</li><li>状态切换:调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</li></ul><p>3、STOP</p><ul><li>状态说明:线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中 断正在处理的任务。</li><li>状态切换:调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</li></ul><p>4、TIDYING</p><ul><li>状态说明:当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING 状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在 ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理; 可以通过重载terminated()函数来实现。</li><li>状态切换:当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</li></ul><p>5、 TERMINATED</p><ul><li><p>状态说明:线程池彻底终止，就变成TERMINATED状态。</p></li><li><p>状态切换:线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING - &gt; TERMINATED。<br> 进入TERMINATED的条件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程池不是RUNNING状态; </span><br><span class="line">线程池状态不是TIDYING状态或TERMINATED状态; </span><br><span class="line">如果线程池状态是SHUTDOWN并且workerQueue为空;</span><br><span class="line">workerCount为0;</span><br></pre></td></tr></table></figure><p>设置TIDYING状态成功。</p></li></ul><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210816153555.png" alt="image-20210816153554981"></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="excute"><a href="#excute" class="headerlink" title="excute"></a>excute</h2><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210730113607.png" alt="img" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1) 如果任务为null，则抛出NPE异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（2）获取当前线程池的状态+线程个数变量的组合值</span></span><br><span class="line">  <span class="comment">//  clt记录着runState和workerCount</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（3） workerCountOf方法取出低29位的值，表示当前活动的线程数;</span></span><br><span class="line"><span class="comment">// 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中，并把任务添加到该线程中。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize 来判断还是maximumPoolSize来判断;</span></span><br><span class="line"><span class="comment">        * 如果为true，根据corePoolSize来判断;</span></span><br><span class="line"><span class="comment">        * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 如果添加失败，则重新获取ctl值</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（4）如果线程池处于RUNNING状态，则添加任务到阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（4.1）二次检查，重新获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//（4.2）如果当前线程池状态不是RUNNING则从队列删除任务，并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//（4.3）否则如果当前线程池线程空，则添加一个线程</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">        * 这里传入的参数表示:</span></span><br><span class="line"><span class="comment">        * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动;</span></span><br><span class="line"><span class="comment">        * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为</span></span><br><span class="line"><span class="comment">        maximumPoolSize，添加线程时根据maximumPoolSize来判断;</span></span><br><span class="line"><span class="comment">        * 如果判断workerCount大于0，则直接返回，在workQueue中新增的</span></span><br><span class="line"><span class="comment">       command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（5）如果队列满了，则新增线程，新增失败则执行拒绝策略</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果执行到这里，有两种情况:</span></span><br><span class="line"><span class="comment">     * 1. 线程池已经不是RUNNING状态;</span></span><br><span class="line"><span class="comment">     * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且 workQueue已满。</span></span><br><span class="line"><span class="comment">     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限 线程数量的上限设置为maximumPoolSize;</span></span><br><span class="line"><span class="comment">     * 如果失败则拒绝该任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下:</p><ol><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任 务;</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添 加到该阻塞队列中;</li><li>如果 workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新 提交的任务;</li><li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><p>这里要注意一下addWorker(null, false);，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中 获取任务。所以，在workerCountOf(recheck) == 0时执行addWorker(null, false);也是 为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。</p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210816155952.png" alt="image-20210816155952194" style="zoom:50%;" /><h2 id="addworker"><a href="#addworker" class="headerlink" title="addworker"></a>addworker</h2><p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线 程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于 maximumPoolSize，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个if判断</span></span><br><span class="line"><span class="comment">         * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务;</span></span><br><span class="line"><span class="comment">         * 接着判断以下3个条件，只要有1个不满足，则返回false:</span></span><br><span class="line"><span class="comment">         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">         * 2. firsTask为空</span></span><br><span class="line"><span class="comment">         * 3. 阻塞队列不为空 *</span></span><br><span class="line"><span class="comment">         * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false;</span></span><br><span class="line"><span class="comment">         * 然后，如果firstTask为空，并且workQueue也为空，则返回false， * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">       <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">             ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                     firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     ! workQueue.isEmpty()))</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 获取线程数</span></span><br><span class="line">          <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">          <span class="comment">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值(二进制是29个1)，返回false;</span></span><br><span class="line">          <span class="comment">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span></span><br><span class="line">          <span class="comment">// 如果为false则根据maximumPoolSize来比较。</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">         <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                 wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 尝试增加workerCount，如果成功，则跳出第一个for循环 </span></span><br><span class="line">           <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">          <span class="keyword">break</span> retry;</span><br><span class="line">          <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class="line">          c = ctl.get();  <span class="comment">// Reread ctl</span></span><br><span class="line">           <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个 for循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">               <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">      w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">      <span class="comment">// 每一个Worker对象都会创建一个线程 </span></span><br><span class="line">      <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">      <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">          mainLock.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">            <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态;</span></span><br><span class="line">            <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class="line">            <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class="line">            <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException(); </span><br><span class="line">            <span class="comment">// workers是一个HashSet</span></span><br><span class="line">            workers.add(w);</span><br><span class="line">            <span class="keyword">int</span> s = workers.size();</span><br><span class="line">            <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">               largestPoolSize = s;</span><br><span class="line">               workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">              <span class="comment">// 启动线程</span></span><br><span class="line">              t.start(); workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">      &#125;       </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;              </span><br><span class="line">      <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h2><p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组 Worker对象，请参见JDK源码。</p><p>Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性:firstTask用它来保存传入的任务;thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p><p>在调用构造方法时，需要把任务传入，这里通过 getThreadFactory().newThread(this); 来 新 建 一 个 线 程 ， newThread 方 法 传 入 的 参 数 是 this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在 启动的时候会调用Worker类中的run方法。</p><p>Worker继承了AQS，使用AQS来实现独占锁的功能。</p><ul><li><p>lock方法一旦获取了独占锁，表示当前线程正在执行任务中;</p></li><li><p>如果正在执行任务，则不应该中断线程;</p></li><li><p>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务， 这时可以对该线程进行中断;</p></li><li><p>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers 方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程 池中的线程是否是空闲状态;</p></li><li><p>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的 线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果 在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线 程。</p><p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。 此外，在构造方法中执行了setState(-1);，把state变量设置为-1，为什么这么做呢? 是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123; <span class="comment">//cas修改state，不可重入</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire方法是根据state是否是0来判断的，所以，setState(-1);将state设置为-1是 为了禁止在执行任务前对线程进行中断。</p><p>正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为 0。</p></li></ul><h2 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h2><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取第一个任务</span></span><br><span class="line">Runnable task = w.firstTask;</span><br><span class="line">w.firstTask = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//允许中断</span></span><br><span class="line">w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line"><span class="comment">// 是否因为异常退出循环</span></span><br><span class="line"><span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果task为空，通过getTask获取任务 </span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说明一下第一个if判断，目的是: 如果线程池正在停止，那么要保证当前线程是中断状态; 如果不是的话，则要保证当前线程不是中断状态;</p><p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会 把状态设置为STOP，回顾一下STOP状态:</p><p>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到 该状态。</p><p>STOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断 是 为 了 确 保 在 RUNNING 或 者 SHUTDOWN 状 态 时 线 程 是 非 中 断 状 态 的 ， 因 为 Thread.interrupted()方法会复位中断的状态。<br> 总结一下runWorker方法的执行过程:</p><ul><li>while循环不断地通过getTask()方法获取任务;</li><li>getTask()方法从阻塞队列中取任务;</li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是 中断状态;</li><li>调用task.run()执行任务;</li><li>如果task为null则跳出循环，执行processWorkerExit()方法;</li><li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li></ul><p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给 子类来实现。<br> completedAbruptly 变 量 来 表 示 在 执 行 任 务 过 程 中 是 否 出 现 了 异 常 ， 在 processWorkerExit方法中会对该变量的值进行判断。</p><h2 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h2><p>getTask方法用来从阻塞队列中取任务，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// timeOut 变量表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line"><span class="comment">// 如果线程池状态rs &gt;= SHUTDOWN 也就是非RUNNING状态，再进行以下判断</span></span><br><span class="line">        <span class="comment">// 1. rs &gt;= STOP,线程池是否正在stop</span></span><br><span class="line">      <span class="comment">// 2. 阻塞队列是否为空</span></span><br><span class="line">      <span class="comment">// 如果以上条件成立，则workerCount减1并返回null</span></span><br><span class="line">      <span class="comment">// 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列添加任务</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty()))&#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">       <span class="comment">// timed变量用于判断是否需要进行超时控制</span></span><br><span class="line">      <span class="comment">// allowCoreThreadTimeOut 默认为false，也就是核心线程不允许超时</span></span><br><span class="line">      <span class="comment">// wc &gt; corePoolSize 表示线程池中的线程数量大于核心线程数量</span></span><br><span class="line">      <span class="comment">// 对于超过核心线程数量的线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * wc &gt; maximumPoolSize 的情况是因为在此方法执行阶段的同时执行了setMaximumPoolSize方法</span></span><br><span class="line"><span class="comment">         * timed &amp;&amp; timedOut如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试workerCount减一</span></span><br><span class="line"><span class="comment">         * 如果减一失败，则重试</span></span><br><span class="line"><span class="comment">         * 如果wc == 1，也就说明当前线程是线程池中唯一的线程了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                    &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据timed来判断，</span></span><br><span class="line">            <span class="comment">// 如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null  </span></span><br><span class="line">            <span class="comment">// 否则通过take方法，如果此时队列为空，则take方法会阻塞直到队列不为空</span></span><br><span class="line">              Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS) :workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line"><span class="comment">// 如果 r == null timedOut</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false，并返回循环重试</span></span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于 maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。</p><p>什么时候会销毁?当然是runWorker方法执行完之后，也就是Worker中的run方法执 行完，由JVM自动回收。</p><p>getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行 processWorkerExit方法。</p><h2 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果completedAbruptly的值为true，说明线程执行时出了异常，需要将workerCount减一</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask（）方法中已经对workerCount进行了减一操作，这里就不必再减了</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 统计完成的任务数</span></span><br><span class="line">           completedTaskCount += w.completedTasks;</span><br><span class="line">         <span class="comment">// 从workers中移除，也就表示从线程池中移除了一个工作线程</span></span><br><span class="line">           workers.remove(w);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据线程池状态判断是否结束线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">// 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker</span></span><br><span class="line">  <span class="comment">// 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker</span></span><br><span class="line">    <span class="comment">// 如果allowCoreThreadTimeOut=false，workderCount不少于corePoolSize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">          <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">          <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">              min = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">              <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">      addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程， runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入 processWorkerExit方法，整个线程结束，如图所示:</p><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210817175104.png" alt="image-20210817175103885"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Executors类提供4个静态工厂方法：newCachedThreadPool()、newFixedThreadPool(int)、newSingleThreadExecutor和newScheduledThreadPool(int)。这些方法最终都是通过ThreadPoolExecutor类来完成的，这里强烈建议大家直接使用Executors类提供的便捷的工厂方法，能完成绝大多数的用户场景，当需要更细节地调整配置，需要先了解每一项参数的意义。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，才会根据是否存在空闲线程，来决定是否需要创建新的线程。除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。</p></li><li><p>maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</p></li><li><p>keepAliveTime（线程存活保持时间）：默认情况下，当线程池的线程个数多于corePoolSize时，线程的空闲时间超过keepAliveTime则会终止。但只要keepAliveTime大于0，allowCoreThreadTimeOut(boolean) 方法也可将此超时策略应用于核心线程。另外，也可以使用setKeepAliveTime()动态地更改参数。</p></li><li><p>unit（存活时间的单位）：时间单位，分为7类，从细到粗顺序：NANOSECONDS（纳秒），MICROSECONDS（微妙），MILLISECONDS（毫秒），SECONDS（秒），MINUTES（分），HOURS（小时），DAYS（天）；</p></li><li><p>workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。可以使用此队列与线程池进行交互：</p><ul><li>如果运行的线程数少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。</li><li>如果运行的线程数等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。</li><li>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。</li></ul></li><li><p>threadFactory（线程工厂）：用于创建新线程。由同一个threadFactory创建的线程，属于同一个ThreadGroup，创建的线程优先级都为Thread.NORM_PRIORITY，以及是非守护进程状态。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：<code>pool-m-thread-n</code>（m为线程池的编号，n为线程池内的线程编号）;</p></li><li><p>handler（线程饱和策略）：线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务。线程池提供了4种策略: </p><ol><li>AbortPolicy:直接抛出异常，默认策略; </li><li>CallerRunsPolicy:用调用者所在的线程来执行任务; </li><li>DiscardOldestPolicy:丢弃阻塞队列中靠最前的任务，并执行当前任务; </li><li>DiscardPolicy:直接丢弃任务;</li></ol><p>上面的4种策略都是ThreadPoolExecutor的内部类。</p><p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如 记录日志或持久化存储不能处理的任务。</p></li></ol><h2 id="排队策略"><a href="#排队策略" class="headerlink" title="排队策略"></a>排队策略</h2><ul><li>直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li><li>无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li><li>有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</li></ul><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><strong>实现BlockingQueue接口的常见类如下：</strong></p><ul><li>ArrayBlockingQueue：基于数组的有界阻塞队列。队列按FIFO原则对元素进行排序，队列头部是在队列中存活时间最长的元素，队尾则是存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。 这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。ArrayBlockingQueue构造方法可通过设置fairness参数来选择是否采用公平策略，公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”，可根据情况来决策。</li><li>LinkedBlockingQueue：基于链表的无界阻塞队列。与ArrayBlockingQueue一样采用FIFO原则对元素进行排序。基于链表的队列吞吐量通常要高于基于数组的队列。</li><li>SynchronousQueue：同步的阻塞队列。其中每个插入操作必须等待另一个线程的对应移除操作，等待过程一直处于阻塞状态，同理，每一个移除操作必须等到另一个线程的对应插入操作。SynchronousQueue没有任何容量。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。Executors.newCachedThreadPool使用了该队列。</li><li>PriorityBlockingQueue：基于优先级的无界阻塞队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 null 元素。依靠自然顺序的优先级队列还不允许插入不可比较的对象（这样做可能导致 ClassCastException）。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致 OutOfMemoryError）。</li></ul><h2 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h2><p>调用线程池的shutdown()或shutdownNow()方法来关闭线程池</p><ul><li>shutdown原理：将线程池状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li><li>shutdownNow原理：将线程池的状态设置成STOP状态，然后中断所有任务(包括正在执行的)的线程，并返回等待执行任务的列表。</li></ul><p>中断采用interrupt方法，所以无法响应中断的任务可能永远无法终止。但调用上述的两个关闭之一，isShutdown()方法返回值为true，当所有任务都已关闭，表示线程池关闭完成，则isTerminated()方法返回值为true。当需要立刻中断所有的线程，不一定需要执行完任务，可直接调用shutdownNow()方法。</p><h2 id="线程池流程"><a href="#线程池流程" class="headerlink" title="线程池流程"></a>线程池流程</h2><p><img src="https://hexo-img-1301602913.cos.ap-shanghai.myqcloud.com/20210730105728.jpg" alt="thread-pool"></p><ol><li>判断核心线程池是否已满，即已创建线程数是否小于corePoolSize？没满则创建一个新的工作线程来执行任务。已满则进入下个流程。</li><li>判断工作队列是否已满？没满则将新提交的任务添加在工作队列，等待执行。已满则进入下个流程。</li><li>判断整个线程池是否已满，即已创建线程数是否小于maximumPoolSize？没满则创建一个新的工作线程来执行任务，已满则交给饱和策略来处理这个任务。</li></ol><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>Java API针对不同需求，利用<code>Executors</code>类提供了4种不同的线程池：newCachedThreadPool, newFixedThreadPool, newScheduledThreadPool, newSingleThreadExecutor。</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><p>创建一个可缓存的无界线程池，该方法无参数。当线程池中的线程空闲时间超过60s则会自动回收该线程，当任务超过线程池的线程数则创建新线程。线程池的大小上限为Integer.MAX_VALUE，可看做是无限大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cachedThreadPoolDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">        cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;, index=&quot;</span>+index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, index=<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, index=<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, index=<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, index=<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, index=<span class="number">4</span></span><br></pre></td></tr></table></figure><p>从运行结果可以看出，整个过程都在同一个线程<code>pool-1-thread-1</code>中运行，后面线程复用前面的线程。</p><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><p>创建一个固定大小的线程池，该方法可指定线程池的固定大小，对于超出的线程会在<code>LinkedBlockingQueue</code>队列中等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixedThreadPoolDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">        fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;, index=&quot;</span>+index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, index=<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>, index=<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>, index=<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, index=<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>, index=<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>, index=<span class="number">5</span></span><br></pre></td></tr></table></figure><p>从运行结果可以看出，线程池大小为3，每休眠1s后将任务提交给线程池的各个线程轮番交错地执行。线程池的大小设置，可参数Runtime.getRuntime().availableProcessors()。</p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><p>创建一个只有线程的线程池，该方法无参数，所有任务都保存队列LinkedBlockingQueue中，等待唯一的单线程来执行任务，并保证所有任务按照指定顺序(FIFO或优先级)执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleThreadExecutorDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">        singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;, index=&quot;</span>+index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, index=<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, index=<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, index=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>从运行结果可以看出，所有任务都是在单一线程运行的。</p><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><p>创建一个可定时执行或周期执行任务的线程池，该方法可指定线程池的核心线程个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledThreadPoolDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//定时执行一次的任务，延迟1s后执行</span></span><br><span class="line">    scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;, delay 1s&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//周期性地执行任务，延迟2s后，每3s一次地周期性执行任务</span></span><br><span class="line">    scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;, every 3s&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, delay 1s</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>, every 3s</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>, every 3s</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>, every 3s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>schedule(Runnable command, long delay, TimeUnit unit)，延迟一定时间后执行Runnable任务；</li><li>schedule(Callable callable, long delay, TimeUnit unit)，延迟一定时间后执行Callable任务；</li><li>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)，延迟一定时间后，以间隔period时间的频率周期性地执行任务；</li><li>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit)，与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔，也就是这一些任务系列的触发时间都是可预知的。</li></ul><p>ScheduledExecutorService功能强大，对于定时执行的任务，建议多采用该方法。</p><h2 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h2><table><thead><tr><th align="left">工厂方法</th><th align="left">corePoolSize</th><th align="left">maximumPoolSize</th><th align="left">keepAliveTime</th><th align="left">workQueue</th></tr></thead><tbody><tr><td align="left">newCachedThreadPool</td><td align="left">0</td><td align="left">Integer.MAX_VALUE</td><td align="left">60s</td><td align="left">SynchronousQueue</td></tr><tr><td align="left">newFixedThreadPool</td><td align="left">nThreads</td><td align="left">nThreads</td><td align="left">0</td><td align="left">LinkedBlockingQueue</td></tr><tr><td align="left">newSingleThreadExecutor</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">LinkedBlockingQueue</td></tr><tr><td align="left">newScheduledThreadPool</td><td align="left">corePoolSize</td><td align="left">Integer.MAX_VALUE</td><td align="left">0</td><td align="left">DelayedWorkQueue</td></tr></tbody></table><p>其他参数都相同，其中线程工厂的默认类为DefaultThreadFactory，线程饱和的默认策略为ThreadPoolExecutor.AbortPolicy。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h2><p>需要针对具体情况而具体处理，不同的任务类别应采用不同规模的线程池，任务类别可划分为CPU密集型任务、IO密集型任务和混合型任务。</p><ul><li>对于CPU密集型任务：线程池中线程个数应尽量少，不应大于CPU核心数；</li><li>对于IO密集型任务：由于IO操作速度远低于CPU速度，那么在运行这类任务时，CPU绝大多数时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高CPU利用率；</li><li>对于混合型任务：可以拆分为CPU密集型任务和IO密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义。</li></ul><h2 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h2><p>利用线程池提供的参数进行监控，参数如下：</p><ul><li>taskCount：线程池需要执行的任务数量。</li><li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li><li>largestPoolSize：线程池曾经创建过的最大线程数量，通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li><li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</li><li>getActiveCount：获取活动的线程数。</li></ul><p>通过扩展线程池进行监控：继承线程池并重写线程池的beforeExecute()，afterExecute()和terminated()方法，可以在任务执行前、后和线程池关闭前自定义行为。如监控任务的平均执行时间，最大执行时间和最小执行时间等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在执行一个异步任务或并发任务时，往往是通过直接&lt;code&gt;new Thread()&lt;/code&gt;方法来创建新的线程，这样做弊端较多，更好的解</summary>
      
    
    
    
    
    <category term="并发编程" scheme="https://tj-ever.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
